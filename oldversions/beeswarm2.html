<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grass Swarm Simulator</title>

<style>
*{box-sizing:border-box}
:root{--bee-slot-size:60px}
body{
margin:0;
background:#141414;
font-family:Arial,sans-serif;
color:white;
display:flex;
justify-content:center;
align-items:center;
height:100vh;
overflow:hidden;
}
.game{
display:flex;
gap:18px;
background:#1b1b1b;
padding:18px;
border-radius:0px;
align-items:flex-start;
}

/* FIELD LIST */
.field-panel{width:220px;background:#202020;padding:8px;border-radius:0px;max-height:80vh;overflow-y:auto}
.field-panel{position:absolute;left:18px;top:18px;display:none;z-index:1200;box-shadow:0 10px 30px rgba(0,0,0,0.7)}
.field-panel.open{display:block}
.field-panel::-webkit-scrollbar{width:8px}
.field-panel::-webkit-scrollbar-thumb{background:#444;border-radius:0px}
.field-item{padding:6px;margin-bottom:8px;background:#262626;border-radius:0px;cursor:pointer;font-size:13px;display:flex;align-items:center;justify-content:space-between;gap:8px}
 .field-item img{width:36px;height:28px;object-fit:cover;margin-right:8px;border-radius:0px}
.field-item .left{display:flex;align-items:center;gap:8px;flex:1}
.field-item .name{flex:1}
.field-item .req-bees{margin-left:8px;color:#f1c40f;font-weight:bold}
.field-item.locked{opacity:0.5;cursor:not-allowed}
.field-item.active{background:#f1c40f;color:black;font-weight:bold}

/* CENTER */
.center{width:480px;display:flex;flex-direction:column}
.stats{display:flex;gap:8px;margin-bottom:8px}
.stat{flex:1;background:#262626;padding:8px;border-radius:0px;text-align:center;font-size:13px}
.field{background:#0f0f0f;padding:12px;border-radius:0px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.6);border:1px solid #181818}
.field .field-title{position:absolute;left:12px;top:6px;font-size:13px;color:#f1c40f}
.grid{display:grid;grid-template-columns:repeat(15,24px);gap:4px;justify-content:center}
.grid{background:linear-gradient(180deg,#071214,transparent);padding:6px;border-radius:0px}
.tile{width:24px;height:24px;background:#27ae60;cursor:pointer;position:relative;overflow:visible}
.tile.transparent{background:#1b8a3c;border:1px solid #1b8a3c;opacity:1}
.tile.transparent img{display:none}
.tile img{width:100%;height:100%;pointer-events:none}

/* Fire effect overlay */
.tile.fire-effect::before{
  content:'';
  position:absolute;
  top:-2px;right:-2px;bottom:-2px;left:-2px;
  border:2px solid #FF4500;
  box-shadow:0 0 6px #FF4500, inset 0 0 4px rgba(255,69,0,0.5);
  pointer-events:none;
  animation:fire-pulse 0.6s ease-in-out infinite;
}
@keyframes fire-pulse{
  0%,100%{box-shadow:0 0 6px #FF4500, inset 0 0 4px rgba(255,69,0,0.5)}
  50%{box-shadow:0 0 12px #FF6347, inset 0 0 8px rgba(255,99,71,0.7)}
}

/* Dark fire effect overlay */
.tile.dark-fire-effect::before{
  content:'';
  position:absolute;
  top:-2px;right:-2px;bottom:-2px;left:-2px;
  border:2px solid;
  border-image:linear-gradient(135deg, #4a0080, #7d3c98, #a855c2, #d946ef) 1;
  box-shadow:
    0 0 8px rgba(125,60,152,0.8),
    0 0 12px rgba(168,85,194,0.6),
    inset 0 0 6px rgba(217,70,239,0.3);
  pointer-events:none;
  animation:dark-fire-pulse 0.7s ease-in-out infinite;
}
@keyframes dark-fire-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(125,60,152,0.8),
    0 0 12px rgba(168,85,194,0.6),
    inset 0 0 6px rgba(217,70,239,0.3)}
  50%{box-shadow:
    0 0 12px rgba(125,60,152,1),
    0 0 18px rgba(168,85,194,0.8),
    inset 0 0 10px rgba(217,70,239,0.5)}
}

/* Goo effect overlay */
.tile.goo-effect::before{
  content:'';
  position:absolute;
  top:-3px;right:-3px;bottom:-3px;left:-3px;
  border:3px solid;
  box-shadow:
    0 0 8px rgba(255,105,180,0.7),
    0 0 12px rgba(57,255,20,0.5),
    inset 0 0 6px rgba(157,78,221,0.3);
  pointer-events:none;
  animation:goo-pulse 0.8s ease-in-out infinite, goo-color-shift 3s ease-in-out infinite;
}
@keyframes goo-color-shift{
  0%{border-color:#FF69B4}
  33%{border-color:#39FF14}
  66%{border-color:#9D4EDD}
  100%{border-color:#FF69B4}
}
@keyframes goo-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(255,105,180,0.7),
    0 0 12px rgba(57,255,20,0.5),
    inset 0 0 6px rgba(157,78,221,0.3)}
  50%{box-shadow:
    0 0 12px rgba(255,105,180,0.9),
    0 0 16px rgba(57,255,20,0.7),
    inset 0 0 10px rgba(157,78,221,0.5)}
}

/* Energy effect overlay */
.tile.energy-effect::before{
  content:'';
  position:absolute;
  top:-3px;right:-3px;bottom:-3px;left:-3px;
  border:3px solid;
  border-image:linear-gradient(135deg, #4169E1, #00BFFF, #1E90FF, #4169E1) 1;
  box-shadow:
    0 0 8px rgba(65,105,225,0.8),
    0 0 12px rgba(0,191,255,0.6),
    inset 0 0 6px rgba(30,144,255,0.3);
  pointer-events:none;
  animation:energy-pulse 0.7s ease-in-out infinite;
}
@keyframes energy-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(65,105,225,0.8),
    0 0 12px rgba(0,191,255,0.6),
    inset 0 0 6px rgba(30,144,255,0.3)}
  50%{box-shadow:
    0 0 12px rgba(65,105,225,1),
    0 0 16px rgba(0,191,255,0.8),
    inset 0 0 10px rgba(30,144,255,0.5)}
}

/* Photon Bee effect */
@keyframes photonGlow{
  0%,100%{
    box-shadow: 0 0 8px rgba(255,215,0,0.6), inset 0 0 4px rgba(255,215,0,0.3);
  }
  50%{
    box-shadow: 0 0 16px rgba(255,215,0,1), inset 0 0 8px rgba(255,215,0,0.6);
  }
}

.bee-grid{
  display:grid;
  grid-template-columns:repeat(5,var(--bee-slot-size));
  gap:2px;
  margin-top:8px;
  justify-content:flex-start;
}
.bee-slot{
  width:var(--bee-slot-size);
  height:var(--bee-slot-size);
  border-radius:0px;
  cursor:pointer;
  border:1px solid #444;
  background:#151515;
  position:relative;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:14px;
  font-weight:bold;
  transition:all 0.12s;
}
.bee-slot img{
  width:100%;
  height:100%;
  object-fit:cover;
}
.bee-slot:hover{
  border-color:#f1c40f;
}

.tool-pattern{
  display:inline-block;
}
.tool-pattern .row{
  display:flex;
}
.tool-pattern span{
  width:10px;
  height:10px;
  margin:1px;
  background:#333;
}
.tool-pattern .on{
  background:#f1c40f;
}

/* tool-grid cells */
.tool-grid{display:grid;grid-template-columns:repeat(9,12px);grid-auto-rows:12px;gap:3px}
.tool-grid .cell{width:12px;height:12px;background:#2a2a2a;border-radius:0px}
.tool-grid .cell.on{background:#f1c40f}

/* Tool frame layout (taller so price is below the pattern) */
.tool-frame{display:grid;grid-template-columns:1fr 90px;grid-template-rows:auto auto auto auto;gap:10px;align-items:start;padding:16px;border-radius:0px;background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);border:1px solid rgba(255,215,0,0.1);min-height:auto;box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05)}
.tool-top{grid-column:1/2;grid-row:1/2}
.tool-name{font-weight:bold;color:#f1c40f;font-size:14px;margin-bottom:4px}
.tool-desc{font-size:12px;color:#ccc;margin-top:2px;line-height:1.4}
.tool-stats{grid-column:1/2;grid-row:3/4;list-style:none;padding-left:12px;color:#ddd;font-size:11px;margin:4px 0;display:flex;flex-direction:column;gap:2px}
.tool-stats li{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}
.tool-pattern{grid-column:2/3;grid-row:1/5;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:8px;background:rgba(0,0,0,0.2);border-radius:0px}
.tool-bottom{grid-column:1/3;grid-row:4/5;display:flex;justify-content:space-between;align-items:flex-end;gap:10px;margin-top:4px;flex-wrap:wrap}
.tool-bottom .price-label{margin-right:4px;align-self:flex-end;font-size:11px}
.tool-price-wrap{grid-column:1/3;grid-row:4/5;display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap}

/* make upgrade frames match tool-frame layout */
.upgrade-frame{display:grid;grid-template-columns:1fr 96px;grid-template-rows:auto 1fr auto auto;gap:8px;align-items:start;padding:12px;border-radius:0px;background:#262626;border:1px solid rgba(255,255,255,0.03);min-height:140px;transition:all 0.3s ease-out}
.upgrade-top{grid-column:1/2;grid-row:1/2}
.upgrade-desc{font-size:12px;color:#ccc;margin-top:4px}
.upgrade-bottom{grid-column:1/3;grid-row:3/4;display:flex;justify-content:space-between;align-items:flex-end;margin-top:6px;padding-bottom:6px}
.upgrade-price-wrap{grid-column:1/3;grid-row:4/5;display:flex;justify-content:flex-end;margin-top:8px}

/* nicer scrollbars for panels */
.section::-webkit-scrollbar, .field-panel::-webkit-scrollbar, .player-stats-panel::-webkit-scrollbar, .hive-panel::-webkit-scrollbar{width:8px;height:8px}
.section::-webkit-scrollbar-track, .field-panel::-webkit-scrollbar-track, .player-stats-panel::-webkit-scrollbar-track, .hive-panel::-webkit-scrollbar-track{background:#1a1a1a;border-radius:8px}
.section::-webkit-scrollbar-thumb, .field-panel::-webkit-scrollbar-thumb, .player-stats-panel::-webkit-scrollbar-thumb, .hive-panel::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#333,#555);border-radius:8px}
.section::-webkit-scrollbar-thumb:hover, .field-panel::-webkit-scrollbar-thumb:hover, .player-stats-panel::-webkit-scrollbar-thumb:hover, .hive-panel::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,#444,#666)}

/* FLOATING */
.floating{
position:absolute;
font-weight:bold;
pointer-events:none;
animation:float 1.2s ease-out forwards;
}
@keyframes float{
to{opacity:0;transform:translate(var(--x),-35px) rotate(var(--r))}
}

@keyframes particle-burst{
to{
  opacity:0;
  transform:translate(var(--px), var(--py)) scale(0);
}
}

@keyframes starGrow{
0%{
  transform:scale(0);
  opacity:0;
}
50%{
  transform:scale(1.2);
}
100%{
  transform:scale(1);
  opacity:1;
}
}

@keyframes starParticle{
0%{
  opacity:1;
  transform:translate(0,0) scale(1);
}
100%{
  opacity:0;
  transform:translate(var(--px), var(--py)) scale(0);
}
}

/* SHOP */
.shop{
width:450px;
background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
border-radius:0px;
padding:12px;
display:flex;
flex-direction:column;
box-shadow:0 8px 24px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);
position:relative;
border:1px solid rgba(255,215,0,0.15);
}

.hive-panel{margin-bottom:8px;padding:10px;background:linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);border-radius:0px;border:1px solid rgba(255,215,0,0.1);overflow-x:hidden}
.hive-panel{max-height:calc(var(--bee-slot-size)*1.5 + 16px);overflow-y:auto}
.hive-panel .bee-grid{grid-template-columns:repeat(5,var(--bee-slot-size));grid-auto-rows:var(--bee-slot-size);justify-items:stretch}
.bee-slot img{width:100%;height:100%;object-fit:cover}
.shop-tabs{
display:flex;
gap:8px;
margin-bottom:6px;
flex-wrap:nowrap;
justify-content:space-between;
align-items:center;
}
.shop-tabs button{
flex:1;
cursor:pointer;
min-width:65px;
padding:12px 10px;
font-size:13px;
white-space:nowrap;
border-radius:0px;
background:linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
border:1px solid rgba(255,215,0,0.2);
color:#f1c40f;
font-weight:500;
transition:all 0.3s ease;
}
.shop-tabs button:hover{
background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
border-color:rgba(255,215,0,0.4);
box-shadow:0 4px 12px rgba(255,215,0,0.1);
}
.section{
  display:none;
  max-height:500px;
  overflow-y:auto;
  padding:12px;
  background:linear-gradient(135deg, rgba(42,42,42,0.5) 0%, rgba(26,26,26,0.5) 100%);
  border-radius:0px;
  margin-bottom:8px;
}
.section.active{display:block}

.section::-webkit-scrollbar{
  width:6px;
}
.section::-webkit-scrollbar-thumb{
  background:#444;
  border-radius:0px;
}


/* UPGRADE */
.upgrade-frame{
background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
padding:14px;
border-radius:0px;
margin-bottom:10px;
position:relative;
min-height:90px;
border:1px solid rgba(255,215,0,0.1);
box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
transition:all 0.3s ease;
}
.upgrade-frame img{
position:absolute;
top:8px;
right:8px;
width:42px;
height:42px;
}
.upgrade-frame button{
width:100%;
margin-top:8px;
}

/* PLAYER STATS */
.player-stats-panel{
width:350px;
background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
border-radius:4px;
padding:16px;
font-size:13px;
max-height:560px;
overflow-y:auto;
box-shadow:0 8px 24px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);
border:1px solid rgba(255,215,0,0.15);
}
.player-stats-panel::-webkit-scrollbar {
  width: 6px;
}
.player-stats-panel::-webkit-scrollbar-track {
  background: #1a1a1a;
  border-radius: 0px;
}
.player-stats-panel::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 0px;
}
.player-stats-panel::-webkit-scrollbar-thumb:hover {
  background: #777;
}
.player-stats-panel h3{
margin:0 0 8px 0;
text-align:center;
font-size:14px;
}
.player-stat{
display:flex;
justify-content:space-between;
margin-bottom:6px;
}
.player-stat span:last-child{
font-weight:bold;
}
.small-btn{background:#202020;color:#f1c40f;border:1px solid #333;padding:4px 6px;border-radius:0px;cursor:pointer}
.small-btn{padding:6px 10px;font-size:11px;border-radius:4px;background:linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);border:1px solid rgba(255,215,0,0.2);transition:all 0.3s ease;font-weight:500}
.small-btn:hover{background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);border-color:rgba(255,215,0,0.4)}
.shop-tabs button.active-tab{background:linear-gradient(135deg, #FFD700, #FFA500);color:#111;font-weight:bold;box-shadow:0 6px 16px rgba(255,215,0,0.3);border-color:rgba(255,215,0,0.8)}

/* Convert button active honey gradient and drop particles */
.convert-active{background:linear-gradient(180deg,#f7c948,#f1a12d);color:#1b1b1b;border-color:#e07b00;box-shadow:0 6px 18px rgba(240,180,60,0.12) !important}
@keyframes honey-drop-fall{0%{transform:translateY(0);opacity:1}100%{transform:translateY(80px);opacity:0}}
.honey-drop{width:6px;height:12px;border-radius:0px;position:fixed;pointer-events:none;background:linear-gradient(180deg,#ffd166,#f39c12);box-shadow:0 2px 6px rgba(0,0,0,0.3);animation:honey-drop-fall 800ms linear forwards}

/* Egg / Tool frame visuals */
.egg-frame{padding:10px;border-radius:0px;background:#222;border:1px solid rgba(255,255,255,0.03);position:relative;overflow:hidden}
.egg-frame .egg-art{position:absolute;right:8px;top:8px;width:48px;height:48px}
.egg-frame .prob-list{margin-top:8px;color:#ddd;font-size:12px;padding-left:14px}
.egg-frame .prob-list li{margin:2px 0}
.egg-frame .egg-art img{animation:egg-swing 2.6s ease-in-out infinite;transform-origin:center center}
@keyframes egg-swing{0%{transform:rotate(-5deg)}50%{transform:rotate(5deg)}100%{transform:rotate(-5deg)}}
/* Mythic egg pulsing purple glow */
@keyframes mythic-glow{0%{box-shadow:0 0 6px #7b1fa2}50%{box-shadow:0 0 18px #9b59b6}100%{box-shadow:0 0 6px #7b1fa2}}
.egg-frame.mythic-egg{animation:mythic-glow 3s ease-in-out infinite;border:1px solid #8e44ad}

/* Bee details swing animation */
@keyframes bee-swing{0%{transform:rotate(-4deg)}50%{transform:rotate(4deg)}100%{transform:rotate(-4deg)}}
.bee-details-panel{animation:bee-swing 2.8s ease-in-out infinite;transform-origin:center top}

/* Bee catalog frame */
.bee-catalog-frame{display:flex;gap:10px;align-items:center;padding:10px;border-radius:0px;margin-bottom:8px;transition:all 0.2s;width:100%;box-sizing:border-box}

/* Particles inside art containers */
.egg-art{position:relative;animation:egg-swing 2.6s ease-in-out infinite;transform-origin:center center;display:block}
.egg-art .particle{width:4px;height:4px;border-radius:0px;position:absolute;opacity:0.95;animation:particle-float 1600ms linear infinite}
@keyframes particle-float{0%{transform:translate(0,0);opacity:1}100%{transform:translate(var(--px,0px),var(--py,0px));opacity:0}}

@keyframes mythic-pulse{0%{box-shadow:0 0 6px rgba(155,89,182,0.45)}50%{box-shadow:0 0 20px rgba(155,89,182,0.75)}100%{box-shadow:0 0 6px rgba(155,89,182,0.45)}}

@keyframes reward-unlock{0%{transform:scale(0.8);opacity:0}50%{transform:scale(1.1)}100%{transform:scale(1);opacity:1}}
@keyframes reward-claim{0%{transform:translateY(0)}50%{transform:translateY(-8px);opacity:1}100%{transform:translateY(0);opacity:0.5}}

.rarity-title-container{display:flex;gap:12px;align-items:center;margin:14px 0 10px 0;justify-content:space-between}
.bee-slot.mythic-bee{animation:mythic-pulse 2.2s ease-in-out infinite;border:1px solid rgba(155,89,182,0.8)}

@keyframes special-pulse{0%{box-shadow:0 0 6px rgba(76,175,80,0.45)}50%{box-shadow:0 0 20px rgba(76,175,80,0.75)}100%{box-shadow:0 0 6px rgba(76,175,80,0.45)}}
.bee-slot.special-bee{animation:special-pulse 2.2s ease-in-out infinite;border:3px solid #4CAF50;background:linear-gradient(90deg,rgba(76,175,80,0.1),transparent,rgba(76,175,80,0.1))}

/* bee tooltip */
.bee-tooltip{position:fixed;pointer-events:none;background:rgba(20,20,20,0.95);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:0px;color:#fff;font-size:12px;z-index:2000;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
.bee-tooltip b{color:#f1c40f}
.price-label{color:#f1c40f;font-weight:bold}

/* Abilities grid */
.abilities-grid-container{display:flex;flex-direction:column;gap:4px;margin-top:12px;padding:8px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,215,0,0.1);max-height:90px;overflow-y:hidden}
.abilities-title{display:none}
.abilities-grid{display:flex;gap:2px;padding:4px;overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth}
.abilities-grid::-webkit-scrollbar{height:6px}
.abilities-grid::-webkit-scrollbar-track{background:rgba(0,0,0,0.3)}
.abilities-grid::-webkit-scrollbar-thumb{background:rgba(255,215,0,0.3);border-radius:0px}
.abilities-grid::-webkit-scrollbar-thumb:hover{background:rgba(255,215,0,0.5)}
.ability-slot{width:40px;height:40px;min-width:40px;position:relative;cursor:pointer;border:1px solid rgba(255,255,255,0.2);display:flex;align-items:flex-end;justify-content:flex-end;font-size:10px;color:#fff;overflow:visible;transition:filter 0.2s;flex-shrink:0}
.ability-slot.special{border:2px solid #4CAF50;box-shadow:0 0 12px rgba(76,175,80,0.8),0 0 24px rgba(76,175,80,0.4),inset 0 0 8px rgba(76,175,80,0.3)}
.ability-slot img{width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;z-index:1}
.ability-cooldown{position:absolute;bottom:2px;right:2px;font-size:10px;font-weight:bold;background:rgba(0,0,0,0.8);padding:1px 2px;color:#fff;z-index:20}
.ability-tooltip{position:fixed;background:rgba(20,20,20,0.95);border:1px solid rgba(255,215,0,0.2);padding:10px;border-radius:0px;color:#fff;font-size:11px;z-index:2100;box-shadow:0 6px 18px rgba(0,0,0,0.8);pointer-events:none;max-width:200px;white-space:normal}

/* STATS PANEL TABS */
.stats-panel-tabs{display:flex;gap:4px;margin-bottom:12px;border-bottom:1px solid rgba(255,215,0,0.2);padding-bottom:8px}
.stats-panel-tabs button{flex:1;padding:6px 8px;font-size:11px;background:#262626;border:1px solid #333;border-radius:0px;color:#ccc;cursor:pointer;transition:all 0.2s}
.stats-panel-tabs button.active{background:#f1c40f;color:#111;font-weight:bold}
.stats-panel-tabs button:hover:not(.active){background:#323232;color:#f1c40f}

/* SETTINGS CONTAINER */
.settings-container{max-height:520px;overflow-y:auto}
.settings-container::-webkit-scrollbar{width:6px}
.settings-container::-webkit-scrollbar-thumb{background:#555;border-radius:0px}
.settings-container::-webkit-scrollbar-thumb:hover{background:#777}

/* SETTINGS CATEGORY */
.settings-category{margin-bottom:16px}
.settings-category-title{font-weight:bold;color:#f1c40f;font-size:12px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid rgba(255,215,0,0.1)}

/* SETTINGS FRAME */
.settings-frame{background:#262626;border:1px solid #333;padding:8px;margin-bottom:8px;border-radius:0px}
.settings-frame-header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:4px}
.settings-frame-title{font-weight:bold;color:#e0e0e0;font-size:12px}
.settings-frame-desc{color:#999;font-size:11px;margin-top:2px;line-height:1.3}

/* SETTINGS CONTROLS */
.settings-control{display:flex;align-items:center;justify-content:flex-end;gap:6px}
.checkbox-toggle{width:30px;height:16px;background:#444;border:1px solid #555;border-radius:2px;cursor:pointer;position:relative;transition:all 0.2s}
.checkbox-toggle.checked{background:#4CAF50}
.checkbox-toggle::after{content:'';position:absolute;width:12px;height:12px;background:#fff;border-radius:1px;top:2px;left:2px;transition:left 0.2s}
.checkbox-toggle.checked::after{left:16px}

/* SLIDER CONTROL */
.slider-container{display:flex;flex-direction:column;gap:4px;align-items:flex-end}
.slider-container input[type="range"]{width:80px;height:6px;border-radius:0px;background:linear-gradient(to right,#444 0%,#555 100%);outline:none;-webkit-appearance:none;cursor:pointer}
.slider-container input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:0px;background:#f1c40f;cursor:pointer;border:1px solid #e0b000}
.slider-container input[type="range"]::-moz-range-thumb{width:12px;height:12px;border-radius:0px;background:#f1c40f;cursor:pointer;border:1px solid #e0b000}
.slider-value{font-weight:bold;color:#f1c40f;font-size:11px;min-width:24px;text-align:right}
</style>
</head>

<body>
<div class="game">

<div class="field-panel" id="fieldList"></div>

<div class="center">
  <div style="display:flex;justify-content:flex-start;margin-bottom:8px">
    <button id="toggleFieldListBtn" class="small-btn">Fields List</button>
    <button id="convertBtn" class="small-btn" style="margin-left:8px;">Convert</button>
  </div>
  <div id="currentFieldTitle" style="margin-bottom:8px;text-align:left">
    <div id="fieldName" style="font-weight:bold;color:#f1c40f;font-size:14px"></div>
    <div id="fieldReq" style="font-size:12px;color:#bbb">Field</div>
  </div>
  <div id="fieldInfo" style="position:absolute;right:24px;top:18px;text-align:right;color:#ccc;font-size:12px"></div>
<div class="stats">
<div class="stat">
üå∏ Pollen<br>
<b><span id="pollen">0</span>/<span id="capacity">100</span></b><br>
<small><span id="pollenSec">0</span>/s</small>
</div>
<div class="stat">
ÔøΩ Tickets<br>
<b><span id="tickets">0</span></b><br>
<small>Special</small>
</div>
<div class="stat">
ÔøΩüçØ Honey<br>
<b><span id="honey">0</span></b><br>
<small><span id="honeySec">0</span>/s</small>
</div>
</div>
<div class="field">
<div class="grid" id="grid"></div>
<div class="abilities-grid-container">
  <div class="abilities-title">üî• Abilities</div>
  <div class="abilities-grid" id="abilitiesGrid"></div>
</div>
</div>
</div>

<div class="shop">
<div class="shop-tabs">
<button class="small-btn" onclick="openShop('upgrades')">Upgrades</button>
<button class="small-btn" onclick="openShop('tilesUpgrades')">Tiles</button>
<button class="small-btn" onclick="openShop('tools')">Tools</button>
<button class="small-btn" onclick="openShop('storage')">Storage</button>
<button class="small-btn" onclick="openShop('bees')">Bees</button>
<button class="small-btn" onclick="openShop('eggs')">Eggs</button>
</div>
<div id="upgrades" class="section active"></div>
<div id="tilesUpgrades" class="section"></div>
<div id="tools" class="section">Tools coming soon</div>
<div id="storage" class="section">Storage coming soon</div>
<div id="bees" class="section">Bees coming soon</div>
<div id="eggs" class="section">Eggs coming soon</div>

  <!-- hive panel moved to bottom of shop -->
  <div class="hive-panel" style="margin-top:8px;">
    <div id="beeGrid" class="bee-grid"></div>
  </div>
</div>

<div class="player-stats-panel" id="playerStatsPanel"></div>

</div>

<script>
/* ================= SAVE ================= */
const SAVE_KEY="grassSave";

/* ================= FORMAT ================= */
const ABBR=["","K","M","B","T","Qa","Qi","Sx","Sp","Oc","No","Dc"];
function fmt(n){
if(n<1000)return n.toFixed(1);
let e=Math.floor(Math.log10(n)/3);
return (n/10**(e*3)).toFixed(2)+ABBR[e];
}

/* ================= STATS ================= */
const stats={
pollen:0,
honey:0,
totalHoney:0,
pollenCapacity:120,
pollenBonus:0,
convertBonus:0,
cooldown:2000,
redBonus:0,
blueBonus:0,
whiteBonus:0,
yellowBonus:0,
purpleBonus:0,
redTotal:0,
blueTotal:0,
whiteTotal:0,
yellowTotal:0,
purpleTotal:0,
backpack:0,
criticalPower:2,
criticalChance:5,
instantConversion:20,
beePollenBonus:0,
beeConvertBonus:0,
beeCriticalChance:0,
beeCriticalPower:0,
beeInstantConversion:0,
beeHoneyBonus:0,
beeCapacityBonus:0,
superCriticalChance:3,
gooPollenCollected:0,
gooMultiplier:1,
fireMultiplier:2,
darkFireMultiplier:7
};

// Ability definitions
const ABILITY_TYPES = {
  'fireBeeAbility': {
    name: 'Fire',
    desc: 'Burns 1-5 random tiles with fire.',
    color: '#FF4500',
    img: 'fire.png'
  },
  'spicyAbility': {
    name: 'Spicy',
    desc: 'Generates spices in 2-4 tiles.',
    color: '#FF1493',
    img: 'spicy.png'
  },
  'demonBeeAbility': {
    name: 'Dark Aura',
    desc: 'Creates a dark aura that destroys 1-3 tiles.',
    color: '#8B008B',
    img: 'demon.png'
  },
  'laserBeeAbility': {
    name: 'Laser Beam',
    desc: 'Fires a laser beam that crosses the field.',
    color: '#00FF00',
    img: 'laser.png'
  },
  'teslaBeeAbility': {
    name: 'Tesla Shock',
    desc: 'Generates electrical discharges in multiple tiles.',
    color: '#FFD700',
    img: 'tesla.png'
  },
  'thunderBeeAbility': {
    name: 'Thunder',
    desc: 'Creates energy tiles with thunder.',
    color: '#4169E1',
    img: 'thunder.png'
  },
  'gooAbility': {
    name: 'Goo',
    desc: 'Generates a magical sticky substance.',
    color: '#FF69B4',
    img: 'goo.png'
  },
  'photonAbility': {
    name: 'Photon Beam',
    desc: 'Fires a golden photon beam.',
    color: '#FFD700',
    img: 'photon.png'
  },
  'digitalRandomEffect': {
    name: 'Digital Glitch',
    desc: 'Random effect from the digital world.',
    color: '#00FF00',
    img: 'digital.png'
  },
  'digitalGlitch': {
    name: 'Digital Corruption',
    desc: 'Corrupts tiles with digital glitch.',
    color: '#00FF00',
    img: 'digital.png'
  },
  'moonBeeAbility': {
    name: 'Moon Laser',
    desc: 'Fires a moonlight beam.',
    color: '#E0FFFF',
    img: 'moon.png'
  },
  'lionBeeAutoDestruct': {
    name: 'Roar',
    desc: 'Destroys 3 tiles with a powerful roar.',
    color: '#FFA500',
    img: 'lion.png'
  },
  'fourFormation': {
    name: 'Four Elements',
    desc: 'Invokes the four natural elements.',
    color: '#9370DB',
    img: 'four.png'
  },
  'gummyBee': {
    name: 'Goo Creation',
    desc: 'Creates magical goo tiles with animated colors.',
    color: '#FF69B4',
    img: 'goo.png'
  },
  'royalGuard': {
    name: 'Critical Spike',
    desc: 'Grants massive critical chance boost.',
    color: '#DC143C',
    img: 'royal.png'
  },
  'teslaBee': {
    name: 'Tesla Lasers',
    desc: 'Generates 5 blue laser beams with energy buff.',
    color: '#4169E1',
    img: 'tesla.png'
  },
  'photonBee': {
    name: 'Photon Blast',
    desc: 'Destroys multiple tiles with golden laser effect.',
    color: '#FFD700',
    img: 'photon.png'
  },
  'digitalBee': {
    name: 'Digital Effects',
    desc: 'Random digital world effects and glitch corruption.',
    color: '#00FF00',
    img: 'digital.png'
  },
  'goldenQueen': {
    name: 'Golden Queen',
    desc: 'Massive conversion rate boost with basic bees.',
    color: '#FFD700',
    img: 'golden.png'
  },
  'fuzzyBuff': {
    name: 'Fuzzy Buff',
    desc: 'Grants massive pollen boost every 20 tiles.',
    color: '#9932CC',
    img: 'fuzzy.png'
  },
  'ticketBee': {
    name: 'Ticket Generation',
    desc: 'Chance to generate tickets every minute.',
    color: '#9370DB',
    img: 'ticket.png'
  }
};

let tickets = 0; // Currency for buying special bees
let ticketBeeAbilityTime = 0;
let goldenBeeAbilityTime = 0;
let tileTicketProbBonus = 0; // Bonus to tile ticket spawn chance from Golden Bee

/* ================= SETTINGS ================= */
const settings = {
  gameplay: {
    numbersPopups: true,
    tileAnimations: true,
    simpleEffectTiles: false,
    simpleFlowerTiles: false,
    particles: true,
    toolPatternVisible: false
  },
  music: {
    mainVolume: 100,
    sfxVolume: 100,
    musicVolume: 100,
    abilityVolume: 100
  },
  page: {
    zoom: 100
  }
};

let currentStatsTab = 'stats'; // Track which tab is currently open


let ownedTools=["shovel"];
let equippedToolId="shovel";

let ownedBees=[];
let equippedBees=[];
let discoveredBees=[]; // Array of bee IDs that have been unlocked
let ownedSpecialBees=[]; // Array of special bee IDs that have been purchased
let equippedSpecialBees=[]; // Array of up to 3 special bee IDs that are currently equipped
let claimedRewards={}; // Track which rarity rewards have been claimed

// Abilities execution tracking
let activeAbilities = []; // Array of {ability, name, color, img, desc, executeTime} for recently executed abilities
let abilityLastState = {}; // Track last cooldown state to detect execution

// per-field statistics
let fieldStats = {};
let lastFieldEnter = Date.now();

function ensureFieldStats(f){
  if(!fieldStats[f]) fieldStats[f] = {pollenCollected:0, timeSpentSeconds:0, clicks:0};
}

// Storage system
let ownedStorages = [];
let equippedStorageId = null;

// Fire Bee ability system
let lastFireBeeAbility = 0;
let fireBeeTilesActive = {};

// Bouyan Bee ability system (Blue flower tracking)
let bouyanbeeMultiplier = 1.0; // x1.0 to x1.5+ (50 stacks max)
let bouyanbeeStackCount = 0; // 0-50 stacks
let bouyanbeeBlueCount = 0; // Count blue tiles destroyed
let bouyanbeeLastBlueTime = 0; // Track last blue tile destruction
let bouyanbeeBaseCapacity = 120; // Base capacity to multiply from

// Fuzzy Bee (Alchemist) tile destruction buff system
let fuzzyDestructionCount = 0; // Count destroyed tiles
let fuzzyBuffActive = false;
let fuzzyBuffEndTime = 0;
let fuzzyBuffCooldownEnd = 0;

// Royal Guard ability system
let royalGuardCritCount = 0;
let royalGuardBuffActive = false;
let royalGuardCooldownActive = false;
let royalGuardBuffStartTime = 0;
let royalGuardCooldownStartTime = 0;

// Spicy Bee ability system
let lastSpicyAbility = 0;
let spicyTilesActive = {};
let nextSpicyAbilityTime = 0;

// Gummy Bee ability system
let gooTiles = {}; // {idx: {gooColor, createdAt, active}}
let gooTokenActive = false;
let lastGooGeneration = 0;
let gooDestroyedCount = 0;
let lastGooTokenTime = 0;
let gooTokenInterval = null;
let gooColorCycle = 0;
const gooColorList = ['#FF69B4', '#39FF14', '#9D4EDD'];

// Tile upgrade system - Goo Tile generation
let lastGooTileGeneration = 0;
let activeGooTileIndices = []; // Track current active goo tiles from upgrades

// Color pollen multipliers (for Tenacity, Bubble, Petal, Lion/Photon)
let redPollenMultiplier = 1.0;
let bluePollenMultiplier = 1.0;
let whitePollenMultiplier = 1.0;
let yellowPollenMultiplier = 1.0;
let purplePollenMultiplier = 1.0;

// Demon Bee ability system
let lastDemonAbility = 0;
let demonTilesActive = {};

// Laser Bee ability system
let lastLaserAbility = 0;
let activeLaserLines = {}; // {idx: {direction, startTime, tiles}}
let energyTiles = {}; // {idx: {createdAt, fieldKey}} - tiles with energy buff
let lastTeslaBeeAbility = 0;
let lastThunderBeeAbility = 0;

// Lion Bee ability system
let lastLionAbility = 0;
let lastLionDestruction = 0;

// Photon Bee ability system
let lastPhotonAbility = 0;

// Digital Bee ability system
let lastDigitalRandomEffect = 0;
let lastDigitalGlitch = 0;
let glitchedTiles = {}; // {idx: {createdAt, durationMs}}

// Moon Bee ability system
let lastMoonLaser = 0;

// Four Bee ability system
let lastFourFormation = 0;
let photonTilesActive = {}; // {idx: {isMarked: true}} - tiles marked for photon destruction

// track applied bonuses to remove when switching
let currentToolBonuses = {};
let currentStorageBonuses = {};

let equippedTool="Shovel";
let playTime=0;
let pollenThisSec=0,
honeyThisSec=0,
lastClick=0,
currentField="dandelion";
// M√°ximo hist√≥rico de abejas equipadas a la vez (permanece aunque se desequipen)
let maxEquippedBeesEver = 0;
// Max slots available to equip (starts with 30 free, up to 50 purchasable)
let maxSlots = 30;

// Helper function to generate bee image name from bee name
function getBeeImageName(name) {
  const firstWord = name.split(' ')[0].toLowerCase();
  return `bee_${firstWord}.png`;
}

setInterval(()=>{
  pollenThisSec*=0.5;
  honeyThisSec*=0.5;
  updateBeeAbilities(); // Update abilities every second to check Royal Guard buff
  updateUI();
},1000);

/* ================= DATA ================= */
const flowerTypes={
  0:{pollen:{min:1, max:5}},

  1:{pollen:{min:5, max:10}},

  2:{pollen:{min:10, max:20}},
  
  3:{pollen:{min:20, max:50}},
  
  4:{pollen:{min:50, max:100}},
  
  5:{pollen:{min:100, max:500}},
};
const fields={
    grandmaster:{name:"Grandmaster Field",colors:{
    red:{chance:50,flowers:{5:100}},
    blue:{chance:50,flowers:{5:100}},
    white:{chance:50,flowers:{5:100}},
    yellow:{chance:50,flowers:{5:100}},
    purple:{chance:50,flowers:{5:100}},
}},
dandelion:{name:"Dandelion Field",colors:{
    white:{chance:100,flowers:{0:25,1:50,2:1}},}},
sunflower:{name:"Sunflower Field",colors:{
    red:{chance:15,flowers:{0:25,1:50,2:5}},
    blue:{chance:15,flowers:{0:25,1:50,2:5}},
    yellow:{chance:40,flowers:{1:40,2:10}},
    white:{chance:15,flowers:{0:25,1:50,2:5}}
}},
mushroom:{name:"Mushroom Field",colors:{
    red:{chance:100,flowers:{0:25,1:50,2:1}},
}},
blueflower:{name:"Blue Flower Field",colors:{
    blue:{chance:100,flowers:{0:25,1:50,2:1}},
    purple:{chance:20,flowers:{0:25,1:50,2:1}},
}},
clover:{name:"Clover Field",colors:{
    red:{chance:60,flowers:{0:25,1:50,2:5}},
    blue:{chance:60,flowers:{0:25,1:50,2:5}},
    white:{chance:20,flowers:{0:25,1:50,2:5}}
}},
spider:{name:"Spider Field",colors:{
    white:{chance:100,flowers:{1:50,2:10}},
}},
bamboo:{name:"Bamboo Field",colors:{
    blue:{chance:80,flowers:{1:50,2:10}},
    purple:{chance:20,flowers:{1:50,2:10}},
    white:{chance:10,flowers:{1:1,2:0.3}}
}},
strawberry:{name:"Strawberry Field",colors:{
    red:{chance:80,flowers:{1:50,2:10}},
    white:{chance:10,flowers:{1:1,2:0.3}}
}},
pineaple:{name:"Pineapple Field",colors:{
    red:{chance:10,flowers:{1:50,2:10}},
    blue:{chance:10,flowers:{1:50,2:10}},
    yellow:{chance:60,flowers:{1:40,2:10}},
    white:{chance:40,flowers:{1:1,2:0.3}}
}},
cactus:{name:"Cactus Field",colors:{
    red:{chance:80,flowers:{1:30,2:10, 3:5}},
    blue:{chance:80,flowers:{1:30,2:10, 3:5}},
    white:{chance:10,flowers:{1:1,2:0.3}}
}},
pumpkin:{name:"Pumpkin Field",colors:{
    red:{chance:5,flowers:{1:30,2:10, 3:5}},
    blue:{chance:5,flowers:{1:30,2:10, 3:5}},
    yellow:{chance:50,flowers:{1:30,2:10, 3:5}},
    white:{chance:60,flowers:{1:30,2:10,3:1}}
}},
pinecone:{name:"Pinecone Tree Field",colors:{
    blue:{chance:90,flowers:{1:30,2:10, 3:10}},
    white:{chance:10,flowers:{1:30,2:10,3:1}}
}},
rose:{name:"Rose Field",colors:{
    red:{chance:90,flowers:{1:30,2:10, 3:10}},
    white:{chance:10,flowers:{1:30,2:10,3:1}}
}},

};
let fieldData={};
// Requisitos de bees para desbloquear campos (por defecto 0 = desbloqueado)
const fieldRequirements = {
  grandmaster: 50,
  dandelion: 0,
  sunflower: 0,
  mushroom: 0,
  blueflower: 0,
  clover: 0,
  spider: 5,
  bamboo: 5,
  strawberry: 5,
  pineaple: 10,
  cactus: 20,
  pumpkin: 20,
  pinecone: 20,
  rose: 20
};

/* ================= BEES ================= */
const BEES = [
{id:"bee1",name:"Basic Bee",rarity:"common",color:"#FFD700",colorType:"colorless",img:"bee_basic.png",desc:"Increases Pollen +5%",ability:"pollenBonus",value:5,synergies:["golden"],tier:1},
{id:"bee2",name:"Cool Bee",rarity:"rare",color:"#4169E1",colorType:"blue",img:"bee_cool.png",desc:"Increases Convert Rate +5%",ability:"convertBonus",value:5,synergies:["golden"],tier:2},
{id:"bee3",name:"Hasty Bee",rarity:"rare",color:"#8B0000",colorType:"colorless",img:"bee_hasty.png",desc:"Increases Crit Chance +2% and reduces tool cooldown -5%",ability:"criticalChance",value:2,synergies:["royal"],hastyBuff:0.95,tier:2},
{id:"bee4",name:"Honey Bee",rarity:"rare",color:"#FFD700",colorType:"yellow",img:"bee_honey.png",desc:"Increases Conversion Rate +20%",ability:"convertBonus",value:20,synergies:["royal"],tier:2},
{id:"bee5",name:"Fuzzy Bee",rarity:"mythic",color:"#9932CC",colorType:"colorless",img:"bee_fuzzy.png",desc:"Increases Instant Conversion +5%. Every 20 tiles: +500% pollen for 5s (cooldown 10s)",ability:"fuzzyBuff",value:5,synergies:["mystical"],mixedColors:["#9932CC","#FF1493"],tier:4},
{id:"bee6",name:"Fire Bee",rarity:"epic",color:"#FF4500",colorType:"red",img:"bee_fire.png",desc:"Marks 1-5 tiles every 20s-1.2min. On destruction: x2 pollen (no visual change)",ability:"fireBee",value:0,synergies:[],tier:3},
{id:"bee7",name:"Bouyan Bee",rarity:"mythic",color:"#9D4EDD",colorType:"blue",img:"bee_bouyan.png",desc:"Every 30 blue flowers: +x1.01 capacity (max 100 stacks per bee). Resets if 2min pass without blue flowers",ability:"bouyanbee",value:0,synergies:[],mixedColors:["#9D4EDD","#3A86FF"],tier:4},
{id:"bee8",name:"Spicy Bee",rarity:"mythic",color:"#FF1493",colorType:"red",img:"bee_spicy.png",desc:"Dark Fire on random tiles every 30s-2min. On destruction: x7 pollen (no visual change, buff 10s)",ability:"spicyBee",value:0,synergies:[],tier:4},
{id:"bee9",name:"Lazy Bee",rarity:"rare",color:"#CCCCCC",colorType:"colorless",img:"bee_lazy.png",desc:"Improves Instant Conversion +10%",ability:"instantConvBoost",value:10,synergies:[],tier:2},
{id:"bee10",name:"Commander Bee",rarity:"rare",color:"#4CAF50",colorType:"colorless",img:"bee_commander.png",desc:"Increases Critical Chance +2% and Critical Power +5%",ability:"commanderBuff",value:0,synergies:[],tier:2},
{id:"bee11",name:"Tenacity Bee",rarity:"epic",color:"#E74C3C",colorType:"red",img:"bee_tenacity.png",desc:"Buff x1.2 red pollen as passive",ability:"redPollenBoost",value:1.2,synergies:[],tier:3},
{id:"bee12",name:"Bubble Bee",rarity:"epic",color:"#3498DB",colorType:"blue",img:"bee_bubble.png",desc:"Buff x1.2 blue pollen as passive",ability:"bluePollenBoost",value:1.2,synergies:[],tier:3},
{id:"bee13",name:"Petal Bee",rarity:"epic",color:"#F8F8F8",colorType:"colorless",img:"bee_petal.png",desc:"Buff x1.2 white pollen as passive",ability:"whitePollenBoost",value:1.2,synergies:[],tier:3},
{id:"bee14",name:"Demon Bee",rarity:"legendary",color:"#FF0000",colorType:"red",img:"bee_demon.png",desc:"Buff Crit Chance +3%, Crit Power +15%. Ability: Creates Fire and Dark Fire on random tiles (80% fire, 20% dark), every 40s-1.5min, 1-3 amount",ability:"demonBee",value:0,synergies:[],tier:5},
{id:"bee15",name:"Diamond Bee",rarity:"legendary",color:"#40E0D0",colorType:"blue",img:"bee_diamond.png",desc:"Buff Convert Rate +25%",ability:"convertBonus",value:25,synergies:[],tier:5},
{id:"bee16",name:"Laser Bee",rarity:"legendary",color:"#FF0000",colorType:"red",img:"bee_laser.png",desc:"Buff Pollen +10%. Ability: Invokes laser beams (horizontal/vertical) every minute, automatically destroy tiles gaining x2 pollen, takes 2s to destroy",ability:"Laser Strike: Fires lasers in random locations every 60 seconds, destroying tiles in a line and granting x2 pollen bonus. Each equipped Laser Bee fires independently.",value:0,synergies:[],tier:5},
{id:"bee17",name:"Thunder Bee",rarity:"epic",color:"#4169E1",colorType:"blue",img:"bee_thunder.png",desc:"Buff Blue Pollen x1.5, Pollen +5%. Ability: Applies energy effect to 1-5 random tiles every 20s-1.2min",ability:"thunderBee",value:0,synergies:[],tier:3},
{id:"bee18",name:"Ticket Bee",rarity:"epic",color:"#9370DB",colorType:"colorless",img:"bee_ticket.png",desc:"Buff Instant Conversion +5%. Ability: 5% chance to get +1 ticket every 1 minute",ability:"ticketBee",value:0,synergies:[],tier:3},
{id:"bee19",name:"Golden Bee",rarity:"mythic",color:"#FFD700",colorType:"yellow",img:"bee_golden.png",desc:"Buff Instant Conversion +5%, Convert Rate +500%, Capacity +100,000. Ability: 20% chance to get +2 tickets every 1 minute, improves tile ticket spawn chance by +5%",ability:"goldenBee",value:500,synergies:[],tier:5},
{id:"bee20",name:"Lion Bee",rarity:"legendary",color:"#FFD700",colorType:"yellow",img:"bee_lion.png",desc:"Buff Pollen +20%, Critical Power +10%. Ability: Destroys 3 random tiles gaining +100% pollen from those tiles + guaranteed critical",ability:"lionBee",value:0,synergies:[],tier:5},
{id:"bee21",name:"Rad Bee",rarity:"rare",color:"#FF0000",colorType:"red",img:"bee_rad.png",desc:"Buff Convert Rate +5%",ability:"convertBonus",value:5,synergies:[],tier:2},
{id:"bee22",name:"Silver Bee",rarity:"rare",color:"#C0C0C0",colorType:"colorless",img:"bee_silver.png",desc:"Buff Pollen +20%, White Pollen x1.5",ability:"silverBee",value:0,synergies:[],tier:2},
{id:"bee23",name:"Moon Bee",rarity:"mythic",color:"#4B0082",colorType:"purple",img:"bee_moon.png",desc:"Buff Blue Pollen x2, Purple Pollen x2. Ability: Generates a tesla laser every 1min randomly in the field, destroys tiles and applies energy buff. 20% chance for dark fire",ability:"moonBee",value:0,synergies:[],tier:4},
{id:"bee24",name:"Devil Bee",rarity:"epic",color:"#8B0000",colorType:"red",img:"bee_devil.png",desc:"Buff Fire Pollen x2, Red Pollen x1.5",ability:"devilBee",value:0,synergies:[],tier:3},
{id:"bee25",name:"Four Bee",rarity:"legendary",color:"#1E90FF",colorType:"blue",img:"bee_four.png",desc:"Buff Pollen +44%, Crit Chance +4%, Crit Power +44%. Ability: Every 5 mins destroys tiles in 4 formation gaining x1.4 pollen",ability:"fourBee",value:0,synergies:[],tier:5},
{id:"bee26",name:"Spark Bee",rarity:"rare",color:"#FFB81C",colorType:"colorless",img:"bee_spark.png",desc:"Buff Pollen +3%, Convert Rate +3%",ability:"sparkBee",value:0,synergies:[],tier:2},
{id:"bee27",name:"Swift Bee",rarity:"rare",color:"#00CED1",colorType:"colorless",img:"bee_swift.png",desc:"Buff Pollen +4%, Crit Chance +1%",ability:"swiftBee",value:0,synergies:[],tier:2},
{id:"bee28",name:"Echo Bee",rarity:"rare",color:"#9370DB",colorType:"colorless",img:"bee_echo.png",desc:"Buff Convert Rate +4%, Instant Conversion +2%",ability:"echoBee",value:0,synergies:[],tier:2},
{id:"bee29",name:"Drift Bee",rarity:"rare",color:"#FF6347",colorType:"colorless",img:"bee_drift.png",desc:"Buff Pollen +5%",ability:"driftBee",value:0,synergies:[],tier:2},
{id:"bee30",name:"Glow Bee",rarity:"rare",color:"#32CD32",colorType:"colorless",img:"bee_glow.png",desc:"Buff Convert Rate +5%",ability:"glowBee",value:0,synergies:[],tier:2},
{id:"bee31",name:"Shade Bee",rarity:"rare",color:"#2F4F4F",colorType:"colorless",img:"bee_shade.png",desc:"Buff Crit Chance +2%, Crit Power +2%",ability:"shadeBee",value:0,synergies:[],tier:2},
{id:"bee32",name:"Aura Bee",rarity:"rare",color:"#FFDAB9",colorType:"colorless",img:"bee_aura.png",desc:"Buff Pollen +3%, Capacity +5000",ability:"auraBee",value:0,synergies:[],tier:2},
{id:"bee33",name:"Prism Bee",rarity:"rare",color:"#BA55D3",colorType:"colorless",img:"bee_prism.png",desc:"Buff Convert Rate +6%, Pollen +2%",ability:"prismBee",value:0,synergies:[],tier:2},
{id:"bee34",name:"Volt Bee",rarity:"rare",color:"#FFD700",colorType:"colorless",img:"bee_volt.png",desc:"Buff Pollen +4%, Convert Rate +4%",ability:"voltBee",value:0,synergies:[],tier:2},
{id:"bee35",name:"Ember Bee",rarity:"rare",color:"#FF4500",colorType:"red",img:"bee_ember.png",desc:"Buff Red Pollen x1.1, Pollen +2%",ability:"emberBee",value:0,synergies:[],tier:2},
{id:"bee36",name:"Inferno Bee",rarity:"epic",color:"#FF0000",colorType:"red",img:"bee_inferno.png",desc:"Buff Red Pollen x1.2, Pollen +6%",ability:"infernoBee",value:0,synergies:[],tier:3},
{id:"bee37",name:"Ocean Bee",rarity:"epic",color:"#1E90FF",colorType:"blue",img:"bee_ocean.png",desc:"Buff Blue Pollen x1.15, Convert Rate +8%",ability:"oceanBee",value:0,synergies:[],tier:3},
{id:"bee38",name:"Nature Bee",rarity:"epic",color:"#228B22",colorType:"colorless",img:"bee_nature.png",desc:"Buff Pollen +8%, Capacity +8000",ability:"natureBee",value:0,synergies:[],tier:3},
{id:"bee39",name:"Mystic Bee",rarity:"epic",color:"#9932CC",colorType:"colorless",img:"bee_mystic.png",desc:"Buff Pollen +10%, Crit Chance +3%",ability:"mysticBee",value:0,synergies:[],tier:3},
{id:"bee40",name:"Cosmic Bee",rarity:"epic",color:"#000080",colorType:"colorless",img:"bee_cosmic.png",desc:"Buff Convert Rate +10%, Instant Conversion +3%",ability:"cosmicBee",value:0,synergies:[],tier:3}
];

/* ================= SPECIAL BEES ================= */
const SPECIAL_BEES = [
{id:"special_bee1",name:"Golden Queen",rarity:"special",color:"#FFD700",colorType:"colorless",img:"bee_golden.png",desc:"5 Basic Bees: +3000% Convert Rate y +50% Instant Conversion",ability:"goldenQueen",value:0,priceType:"tickets",price:50,synergies:[],bonusMultipliers:{"bee1":11},tier:4},
{id:"special_bee2",name:"Royal Guard",rarity:"special",color:"#DC143C",colorType:"red",img:"bee_royal.png",desc:"Cada 10 cr√≠ticos: +1000% Critical Chance por 3s",ability:"royalGuard",value:0,priceType:"tickets",price:75,synergies:[],bonusMultipliers:{"bee3":11,"bee4":11},tier:4},
{id:"special_bee3",name:"Gummy Bee",rarity:"special",color:"#FF69B4",colorType:"colorless",img:"bee_gummy.png",desc:"Crea Goo en casillas (15-30s). Buff x3.75 (x2.5 + x1.5 bonus) + instant conv +100%. White Pollen x3, Goo Pollen x2. Colores animados",ability:"gummyBee",value:0,priceType:"tickets",price:30,synergies:[],mixedColors:["#FF69B4","#00FF00","#9D4EDD"],tier:4},
{id:"special_bee4",name:"Tesla Bee",rarity:"special",color:"#4169E1",colorType:"blue",img:"bee_tesla.png",desc:"Convert Rate +50%, Instant Convert +30%, Blue Pollen x2. Habilidad: Genera 5 laseres azules cada 30s-2min, aplican buff energy (2x pollen, 5x blue, 100% instant conv) por 10s",ability:"teslaBee",value:0,priceType:"tickets",price:1,synergies:[],bonusMultipliers:{"bee16":6,"bee17":6},tier:5},
{id:"special_bee5",name:"Photon Bee",rarity:"special",color:"#FFD700",colorType:"yellow",img:"bee_photon.png",desc:"Buff Instant Convert +25%, Convert Rate +200%, Yellow Pollen x2. Habilidad: Cada 1-2min destruye 20 tiles aleatorias con efecto laser dorado y glow",ability:"photonBee",value:0,priceType:"tickets",price:2,synergies:[],bonusMultipliers:{"bee20":3},tier:5},
{id:"special_bee6",name:"Digital Bee",rarity:"special",color:"#00FF00",colorType:"colorless",img:"bee_digital.png",desc:"Buff Pollen +1000%, Critical Chance +30%. Habilidad: Cada 30s genera efectos aleatorios (fire, dark fire, energy, goo, photon, laser). Cada 1-2min aplica glitch a 2-4 tiles: +3000% pollen, +5% super-crit",ability:"digitalBee",value:0,priceType:"tickets",price:3,synergies:[],mixedColors:["#FF0000","#00FF00","#000000"],tier:5}
];

// Egg definitions: name, price, image, rarity probabilities (sums to 100)
const EGGS = [
  {id:"egg_basic",name:"Basic Egg",price:100,img:"egg_basic.png",probs:{common:80,rare:15,epic:0,legendary:0,mythic:0},frameStyle:{bg:"#333",gradient:false},mult:2.4,cap:10000000},
  {id:"egg_silver",name:"Silver Egg",price:2500,img:"egg_silver.png",probs:{common:0,rare:70,epic:15,legendary:5,mythic:0},frameStyle:{bg:"linear-gradient(90deg,#bbb,#333)",gradient:true},mult:3.6,cap:250000000},
  {id:"egg_golden",name:"Golden Egg",price:10000,img:"egg_golden.png",probs:{common:0,rare:0,epic:60,legendary:40,mythic:0},frameStyle:{bg:"linear-gradient(90deg,#f1c40f,#333)",gradient:true},mult:4.8,cap:1000000000},
  {id:"egg_diamond",name:"Diamond Egg",price:300000,img:"egg_diamond.png",probs:{common:0,rare:0,epic:0,legendary:95,mythic:5},frameStyle:{bg:"linear-gradient(90deg,#7ef,#333)",gradient:true},mult:5.5,cap:20000000000},
  {id:"egg_mythic",name:"Mythic Egg",price:10000000,img:"egg_mythic.png",probs:{common:0,rare:0,epic:0,legendary:0,mythic:100},frameStyle:{bg:"linear-gradient(90deg,#ff1493,#333)",gradient:true},mult:7.2,cap:1500000000000}
];

// English ability descriptions
const ABILITY_DESCRIPTIONS_EN = {
  'pollenBonus': 'Increases pollen collection by a percentage amount',
  'convertBonus': 'Increases the conversion rate of pollen to honey',
  'criticalChance': 'Chance to deal critical damage on tile destruction',
  'criticalPower': 'Multiplier for critical hit damage',
  'fuzzyBuff': 'Every 10 clicks grants massive pollen boost on next collection',
  'fireBee': 'Automatically burns 1-5 random tiles for x3 pollen multiplier',
  'bouyanbee': 'Generates capacity tokens that boost hive capacity',
  'spicyBee': 'Burns tiles in binary pattern for x3 pollen multiplier',
  'instantConvBoost': 'Improves instant honey conversion on pollen collection',
  'commanderBuff': 'Boosts both critical chance and critical power',
  'redPollenBoost': 'Doubles red pollen collection efficiency',
  'bluePollenBoost': 'Doubles blue pollen collection efficiency',
  'whitePollenBoost': 'Doubles white/colorless pollen collection efficiency',
  'gummyBee': 'Creates special Goo tiles with enhanced collection bonuses',
  'goldenQueen': '5 Basic Bees in hive grants massive convert boost',
  'royalGuard': 'Every 10 critical hits grants crit chance spike',
  'demonBee': 'Randomly burns tiles with fire (x2) or dark fire (x7)',
  'diamondBee': 'At 50% capacity grants massive conversion rate boost',
  'laserBee': 'Fires laser beams that destroy entire lines of tiles automatically',
  'thunderBee': 'Generates energy tiles that grant massive bonuses to destroyed pollen',
  'teslaBee': 'Fires 5 blue lasers that apply energy buff to destroyed tiles',
  'none': 'No special ability'
};

// Buff descriptions for each bee
const BEE_BUFFS = {
  'bee1': [],
  'bee2': ['Convert Rate: +5%'],
  'bee3': ['Critical Chance: +2%', 'Tool Cooldown: -5%'],
  'bee4': ['Conversion Rate: +20%'],
  'bee5': ['Instant Conversion: +5%', 'Fuzzy Buff: Every 20 tiles +500% pollen for 5s'],
  'bee6': ['Fire Bee: Marks 1-5 tiles', 'Pollen Multiplier: x2 on destroyed tiles'],
  'bee7': ['Capacity Boost: +1% per blue pollen', 'Max: 100 stacks per bee'],
  'bee8': ['Dark Fire: Marks 1-5 random tiles', 'Pollen Multiplier: x7 on destroyed tiles'],
  'bee9': ['Instant Conversion: +10%'],
  'bee10': ['Critical Chance: +2%', 'Critical Power: +5%'],
  'bee11': ['Red Pollen: x1.2'],
  'bee12': ['Blue Pollen: x1.2'],
  'bee13': ['White Pollen: x1.2'],
  'bee14': ['Critical Chance: +3%', 'Critical Power: +15%', 'Fire & Dark Fire: Random tiles every 40s-1.5min'],
  'bee15': ['Convert Rate: +25%'],
  'bee16': ['Pollen Bonus: +10%', 'Laser Strike: Fires horizontal/vertical lasers every 60s'],
  'bee17': ['Blue Pollen: x1.5', 'Pollen Bonus: +5%', 'Energy Tiles: Marks 1-5 tiles every 20s-1.2min'],
  'bee18': ['Instant Conversion: +5%', 'Ticket Generation: 5% chance every 1 minute for +1 ticket'],
  'bee19': ['Instant Conversion: +5%', 'Convert Rate: +500%', 'Capacity Bonus: +100,000', 'Yellow Pollen: x2', 'Ticket Generation: 20% chance every 1 minute for +2 tickets', 'Tile Bonus: +5% ticket chance'],
  'bee20': ['Pollen Bonus: +20%', 'Critical Power: +10%', 'Lion Feast: Destroys 3 random tiles with +100% pollen & guaranteed crit'],
  'bee21': ['Convert Rate: +5%'],
  'bee22': ['Pollen Bonus: +20%', 'White Pollen: x1.5'],
  'bee23': ['Blue Pollen: x2', 'Purple Pollen: x2', 'Moon Laser: Generates random Tesla laser every 1 minute, destroys tiles with energy buff (x2-x5 pollen), 20% chance to apply dark fire'],
  'bee24': ['Fire Pollen: x2', 'Red Pollen: x1.5'],
  'bee25': ['Pollen Bonus: +44%', 'Critical Chance: +4%', 'Critical Power: +44%', 'Four Formation: Every 5 minutes destroys 4 tiles in formation with x1.4 pollen'],
  'bee26': ['Pollen Bonus: +3%', 'Convert Rate: +3%'],
  'bee27': ['Pollen Bonus: +4%', 'Critical Chance: +1%'],
  'bee28': ['Convert Rate: +4%', 'Instant Conversion: +2%'],
  'bee29': ['Pollen Bonus: +5%'],
  'bee30': ['Convert Rate: +5%'],
  'bee31': ['Critical Chance: +2%', 'Critical Power: +2%'],
  'bee32': ['Pollen Bonus: +3%', 'Capacity: +5000'],
  'bee33': ['Convert Rate: +6%', 'Pollen Bonus: +2%'],
  'bee34': ['Pollen Bonus: +4%', 'Convert Rate: +4%'],
  'bee35': ['Red Pollen: x1.1', 'Pollen Bonus: +2%'],
  'bee36': ['Red Pollen: x1.2', 'Pollen Bonus: +6%'],
  'bee37': ['Blue Pollen: x1.15', 'Convert Rate: +8%'],
  'bee38': ['Pollen Bonus: +8%', 'Capacity: +8000'],
  'bee39': ['Pollen Bonus: +10%', 'Critical Chance: +3%'],
  'bee40': ['Convert Rate: +10%', 'Instant Conversion: +3%'],
  'special_bee1': ['5 Basic Bees: Convert Rate +3000%', '5 Basic Bees: Instant Conversion +50%'],
  'special_bee2': ['Every 10 crits: Crit Chance +1000% for 3s'],
  'special_bee3': ['Creates Goo tiles', 'Pollen Multiplier: x3.75', 'White Pollen: x3', 'Goo Pollen: x2', 'Instant Conversion: +100%'],
  'special_bee4': ['Convert Rate: +50%', 'Instant Conversion: +30%', 'Blue Pollen: x2', 'Tesla Beams: 5 blue lasers every 30s-2min with Energy buff'],
  'special_bee5': ['Instant Conversion: +25%', 'Convert Rate: +200%', 'Yellow Pollen: x2', 'Photon Blast: Destroys 20 random tiles every 1-2min with golden laser effect', 'Destroyed tiles: x3 pollen, x5 for yellow'],
  'special_bee6': ['Pollen Bonus: +1000%', 'Critical Chance: +30%', 'Digital Effects: Random effects (fire, dark fire, energy, goo, photon, laser) every 30s', 'Glitch Tiles: Every 1-2min applies glitch to 2-4 tiles with +3000% pollen & +5% super-crit']
};

// Current dynamic prices per egg (will be persisted)
let eggPrices = {};
EGGS.forEach(e=>eggPrices[e.id]=e.price);

/* ================= SINERGIES ================= */
const SYNERGIES = [
  {id:"golden",name:"Golden Touch",requirement:["bee1","bee2"],bonus:{pollenBonus:15}},
  {id:"royal",name:"Royal Guard",requirement:["bee3","bee6"],bonus:{criticalChance:5,criticalPower:0.3}},
  {id:"worker",name:"Worker Colony",requirement:["bee7","bee10"],bonus:{pollenBonus:20,convertBonus:10}},
  {id:"mystical",name:"Mystical Convergence",requirement:["bee5","bee8","bee9"],bonus:{instantConversion:10,pollenBonus:10}},
  {id:"champion",name:"Champion\'s Path",requirement:["bee4","bee10"],bonus:{criticalPower:1,criticalChance:3}}
];

function applyToolPattern(centerIndex, fieldKey){
  const tool = TOOLS.find(t => t.id === equippedToolId);
  if (!tool) return;
  
  const GRID_W = 15;
  const GRID_H = 15;
  const cx = centerIndex % GRID_W;
  const cy = Math.floor(centerIndex / GRID_W);

  const patternSize = tool.pattern.length || 5;
  const centerOff = Math.floor(patternSize / 2);
  const tilesToDestroy = [];

  tool.pattern.forEach((row, py) => {
    row.forEach((cell, px) => {
      if (!cell) return;

      const gx = cx + (px - centerOff);
      const gy = cy + (py - centerOff);
      if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return;

      const idx = gy * GRID_W + gx;
      tilesToDestroy.push(idx);
    });
  });

  let destroyedCount = 0;
  tilesToDestroy.forEach(idx => {
    const tile = fieldData[fieldKey][idx];
    
    if (!tile) return;

    // Handle empty tiles (ty === 0) - give minimal pollen
    const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
    const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
    
    const totalCritChance = stats.criticalChance + stats.beeCriticalChance;
    let isCritical = Math.random() * 100 < totalCritChance;
    let isSuperCritical = false;
    
    // 3% chance of super critical when there's a critical hit
    if(isCritical && Math.random() * 100 < stats.superCriticalChance){
      isSuperCritical = true;
      isCritical = false; // Super critical replaces normal critical
    }
    
    const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
    const critMultiplier = isSuperCritical ? 10 : (isCritical ? totalCritPower : 1);
    const finalPollenValue = pollenValue * critMultiplier;
    
    // Track Royal Guard crit counter (only if no buff/cooldown active)
    if((isCritical || isSuperCritical) && equippedSpecialBees && equippedSpecialBees.includes('special_bee2')){
      if(!royalGuardBuffActive && !royalGuardCooldownActive){
        royalGuardCritCount++;
        if(royalGuardCritCount >= 10){
          royalGuardBuffActive = true;
          royalGuardBuffStartTime = Date.now();
          royalGuardCritCount = 0; // Reset counter after buff activates
          console.log('‚öîÔ∏è Royal Guard BUFF ACTIVATED! +1000% Crit Chance for 3s');
        }
      }
    }
    
    const totalInstantConv = stats.instantConversion + stats.beeInstantConversion;
    let isInstantConversion = Math.random() * 100 < totalInstantConv;
    let instantHoneyAmount = isInstantConversion ? finalPollenValue * 0.5 : 0;
    
    const pollenAfterConversion = finalPollenValue - instantHoneyAmount;
    
    const totalPollenBonus = stats.pollenBonus + stats.beePollenBonus;
    let gain = pollenAfterConversion
      * (1 + totalPollenBonus / 100)
      * (1 + tool.pollenBonus / 100);
    
    // Track destroyed tiles for Fuzzy Bee (every 20 tiles triggers +5000% buff for 5s)
    if(equippedBees && equippedBees.includes('bee5')){
      const now = Date.now();
      
      // Check if buff/cooldown expired
      if(fuzzyBuffActive && now > fuzzyBuffEndTime){
        fuzzyBuffActive = false;
      }
      if(now > fuzzyBuffCooldownEnd){
        fuzzyBuffCooldownEnd = 0;
      }
      
      // Increment destruction count
      fuzzyDestructionCount++;
      
      // Every 20 tiles destroyed and no cooldown active
      if(fuzzyDestructionCount >= 20 && !fuzzyBuffCooldownEnd){
        fuzzyBuffActive = true;
        fuzzyBuffEndTime = now + 5000; // 5 second buff
        fuzzyBuffCooldownEnd = now + 10000; // 10s cooldown (starts after buff ends, total 15s)
        fuzzyDestructionCount = 0;
        console.log('‚ú® Fuzzy Bee BUFF ACTIVATED! +500% pollen for 5s');
      }
    }
    
    // Track blue flower destruction for Bouyan Bee (every 30 blue = +x1.01 capacity bonus, max 50 stacks)
    if(equippedBees && equippedBees.includes('bee7')){
      const now = Date.now();
      
      // Check if 2 minutes have passed without blue flower destruction
      if(bouyanbeeBlueCount > 0 && (now - bouyanbeeLastBlueTime) > 120000){
        const previousCapacity = calculateCapacity();
        console.log('üü¶ Bouyan Bee: 2 minutes without blue flowers, resetting to x1.0');
        bouyanbeeStackCount = 0;
        bouyanbeeMultiplier = 1.0;
        bouyanbeeBlueCount = 0;
        const newCapacity = calculateCapacity(); // Will be recalculated
        console.log(`üü¶ Bouyan Reset! Capacity: ${previousCapacity} ‚Üí ${newCapacity}`);
      }
      
      // If this is a blue flower
      if(tile.c === 'blue'){
        bouyanbeeLastBlueTime = now;
        bouyanbeeBlueCount++;
        
        // Every 30 blue flowers, increase multiplier (max 100 stacks)
        if(bouyanbeeBlueCount >= 30 && bouyanbeeStackCount < 100){
          bouyanbeeBlueCount = 0;
          // Calculate capacity BEFORE incrementing
          const previousCapacity = calculateCapacity();
          bouyanbeeStackCount++;
          bouyanbeeMultiplier = Math.pow(1.01, bouyanbeeStackCount);
          
          // Notify player
          const newCapacity = calculateCapacity(); // Recalculated with new stack
          const capacityIncrease = newCapacity - previousCapacity;
          console.log(`üü¶ Bouyan Bee: Stack ${bouyanbeeStackCount}/100 (x${bouyanbeeMultiplier.toFixed(4)}) - Capacity: ${previousCapacity} ‚Üí ${newCapacity}`);
        }
      }
    }
    
    // Check if this tile is affected by Fire Bee (x2 pollen if destroyed)
    let fireBeeBuff = 1;
    if(fireBeeTilesActive[idx]){
      fireBeeBuff = 2; // x2 pollen for Fire Bee tiles
      // Devil Bee buff: Fire Pollen x2 (doubles the fire buff)
      const hasDevilBee = equippedBees && equippedBees.includes('bee24');
      if(hasDevilBee){
        fireBeeBuff *= 2; // x4 total with Devil Bee (x2 Fire Bee * x2 Devil Bee)
      }
      delete fireBeeTilesActive[idx]; // Remove after applying bonus
      // Remove fire border
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("fire-effect");
      }
    }
    
    // Check if this tile is affected by Spicy Bee / Dark Fire (x7 pollen if destroyed)
    let spicyBeeBuff = 1;
    if(spicyTilesActive[idx]){
      spicyBeeBuff = 7; // x7 pollen for Spicy Bee (Dark Fire) tiles
      delete spicyTilesActive[idx]; // Remove after applying bonus
      // Remove dark fire border
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("dark-fire-effect");
      }
    }
    
    // Apply Fire/Spicy Bee and Bouyan multipliers
    gain = gain * fireBeeBuff * spicyBeeBuff * bouyanbeeMultiplier;
    
    // Apply Fuzzy Bee buff (500% = x6 total)
    if(fuzzyBuffActive){
      gain *= 6; // 1 + 500%
    }
    
    // Apply Diamond Bee buff (+5000% convert rate = x51 on conversion)
    // Apply Goo multiplier if on this tile (x2.5 pollen + x1.5 from Gummy Bee = x3.75 + 100% instant conv)
    let hasGoo = false;
    if(gooTiles[idx]){
      const gooMultiplier = 2.5 * 1.5; // x3.75 total (x2.5 base + x1.5 Gummy Bee buff)
      gain *= gooMultiplier;
      stats.gooMultiplier = gooMultiplier; // Track goo multiplier
      isInstantConversion = true; // Force instant conversion for Goo
      instantHoneyAmount = gain * 0.5; // Recalculate honey with Goo buff
      hasGoo = true;
      
      // Apply Gummy Bee specific buffs
      // White pollen x3 and Goo pollen x2
      if(equippedSpecialBees && equippedSpecialBees.includes('special_bee3')){
        if(tile.c === 'white'){
          gain *= 3; // x3 white pollen bonus from Gummy Bee
        }
        gain *= 2; // x2 goo pollen bonus from Gummy Bee (applies to all goo)
      }
    }

    // === ENERGY TILE BUFF ===
    let hadEnergyBuff = false;
    if(energyTiles[idx]){
      hadEnergyBuff = true;
      // x5 blue pollen, x2 pollen para otras, 100% instant conv
      if(tile.c === 'blue'){
        gain *= bluePollenMultiplier * 5;
        stats.blueTotal += gain;
      } else {
        gain *= 2;
        if(tile.c === 'red') stats.redTotal += gain;
        else if(tile.c === 'white') stats.whiteTotal += gain;
        else if(tile.c === 'yellow') stats.yellowTotal = (stats.yellowTotal || 0) + gain;
        else if(tile.c === 'purple') stats.purpleTotal = (stats.purpleTotal || 0) + gain;
      }
      isInstantConversion = true;
      instantHoneyAmount = gain * 0.5;
      // Eliminar el energy buff de la tile
      delete energyTiles[idx];
    } else {
      // Apply color-based multipliers normalmente
      if(tile.c === 'red'){
        gain *= redPollenMultiplier;
        stats.redTotal += gain;
      } else if(tile.c === 'blue'){
        gain *= bluePollenMultiplier;
        stats.blueTotal += gain;
      } else if(tile.c === 'white'){
        gain *= whitePollenMultiplier;
        stats.whiteTotal += gain;
      } else if(tile.c === 'yellow'){
        gain *= yellowPollenMultiplier;
        stats.yellowTotal = (stats.yellowTotal || 0) + gain;
      } else if(tile.c === 'purple'){
        gain *= purplePollenMultiplier;
        stats.purpleTotal = (stats.purpleTotal || 0) + gain;
      }
    }

    const currentCapacity = calculateCapacity();
    const added = Math.min(currentCapacity - stats.pollen, gain);
    stats.pollen += added;
    try{ ensureFieldStats(fieldKey); fieldStats[fieldKey].pollenCollected = (fieldStats[fieldKey].pollenCollected||0) + added; }catch(e){}
    stats.honey += instantHoneyAmount;
    stats.totalHoney += instantHoneyAmount;
    pollenThisSec += added;
    
    // Track Goo pollen collected
    if(hasGoo){
      stats.gooPollenCollected += added;
    }
    
    // Track Goo destruction for Gummy token
    if(hasGoo){
      gooDestroyedCount++;
      delete gooTiles[idx];
      // Remove goo border styling
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("goo-effect");
      }
    }

    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if (tileEl) {
      const r = tileEl.getBoundingClientRect();
      
      // Crear part√≠culas de Goo que suben
      if(hasGoo){
        const now = Date.now();
        for(let p = 0; p < 6; p++){
          const particle = document.createElement('div');
          particle.style.position = 'fixed';
          particle.style.left = (r.left + r.width/2) + 'px';
          particle.style.top = (r.top + r.height/2) + 'px';
          particle.style.width = '4px';
          particle.style.height = '4px';
          particle.style.borderRadius = '50%';
          particle.style.background = gooColorList[Math.floor(Math.random() * gooColorList.length)];
          particle.style.pointerEvents = 'none';
          particle.style.zIndex = '9999';
          particle.style.boxShadow = '0 0 4px ' + particle.style.background;
          document.body.appendChild(particle);
          
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 100 + 50;
          const vx = Math.cos(angle) * speed;
          let px = r.left + r.width/2;
          let py = r.top + r.height/2;
          
          const particleAnim = setInterval(()=>{
            px += vx * 0.016;
            py -= 80 * 0.016; // Subir
            
            // Cambiar color durante la animaci√≥n
            const currentColorIndex = Math.floor((Date.now() - now) / 150) % gooColorList.length;
            particle.style.background = gooColorList[currentColorIndex];
            particle.style.boxShadow = '0 0 4px ' + gooColorList[currentColorIndex];
            
            particle.style.left = px + 'px';
            particle.style.top = py + 'px';
            particle.style.opacity = Math.max(0, 1 - (Date.now() - now) / 800);
            if(Date.now() - now > 800){
              clearInterval(particleAnim);
              particle.remove();
            }
          }, 16);
        }
      }
      
      // Limpiar efecto visual del Goo
      if(hasGoo){
        tileEl.style.filter = 'none';
      }
      
      floating(r.left + r.width / 2, r.top, gain, isCritical, hasGoo);
      if (isInstantConversion) {
        floating(r.left + r.width / 2, r.top + 20, instantHoneyAmount * 0.5, false, false, true);
      }
      
      // Update tile visual immediately to show it's been destroyed
      renderTile(tileEl, fieldData[fieldKey][idx]);
      
      tileEl.style.transition = "opacity 0.4s ease-out";
      tileEl.style.opacity = "0";
      
      // 1% chance to get a ticket from tile destruction
      if(Math.random() < (0.01 + (tileTicketProbBonus || 0))){
        tickets += 1;
        showFloatingText(r.left + r.width / 2, r.top, 'üé´ +1 Ticket', '#FFA500');
      }
    }

    console.log(`    -> DESTROYING tile ${idx}`);
    fieldData[fieldKey][idx] = {c: "", ty: 0, transparent: true};

    const capturedIdx = idx;
    const capturedFieldKey = fieldKey;
    // Random regeneration time using tileRegenerationRange
    const regenerationTime = tileRegenerationRange.min + Math.random() * (tileRegenerationRange.max - tileRegenerationRange.min);
    const regenerationTimer = setTimeout(() => {
      if (fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]) {
        fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
        if (currentField === capturedFieldKey) {
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
          if (tileEl) {
            tileEl.style.transition = "opacity 0.8s ease-in";
            tileEl.style.opacity = "0";
            // Force reflow to apply initial state
            void tileEl.offsetWidth;
            renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
            tileEl.style.opacity = "1";
          }
        }
        saveGame();
      }
    }, regenerationTime);
  });

  saveGame();
}

/* ================= UPGRADES ================= */
const UPGRADES=[
{
id:"pollen",
name:"üå∏ Pollen Power",
img:"pollen_upgrade.png",
stat:"pollenBonus",
description:"Increases pollen gained from each tile destruction",
levels:[
{price:10,percent:5},
{price:30,percent:5},
{price:50,percent:5},
{price:100,percent:10},
{price:750,percent:10},
{price:4500,percent:10},
{price:12000,percent:10},
{price:50000,percent:10},
{price:250000,percent:30},/* 100% pollen (con solo las mejoras) */
{price:1000000,percent:50},
{price:3500000,percent:50},/* 200% pollen (con solo las mejoras) */
{price:12000000,percent:100},/* 300% pollen (con solo las mejoras) */
{price:50000000,percent:100},/* 400% pollen (con solo las mejoras) */
]
},
{
id:"convert",
name:"üçØ Convert Rate",
img:"convert_upgrade.png",
stat:"convertBonus",
description:"Boosts the conversion rate of pollen into honey",
levels:[
{price:50,percent:10},
{price:250,percent:10},
{price:1500,percent:5},
{price:100,percent:10},
{price:750,percent:10},
{price:4500,percent:10},
{price:12000,percent:10},
{price:50000,percent:10},
{price:250000,percent:30},/* 100% pollen (con solo las mejoras) */
{price:1000000,percent:50},
{price:3500000,percent:50},/* 200% pollen (con solo las mejoras) */
{price:12000000,percent:100},/* 300% pollen (con solo las mejoras) */
{price:50000000,percent:100},/* 400% pollen (con solo las mejoras) */
]
},
{
id:"criticalChance",
name:"üí• Crit Chance",
img:"critical_chance_upgrade.png",
stat:"criticalChance",
description:"Increases the probability of critical hits",
levels:[
{price:200,percent:5},
{price:500,percent:8},
{price:1200,percent:10}
]
},
{
id:"criticalPower",
name:"‚ö° Crit Power",
img:"critical_power_upgrade.png",
stat:"criticalPower",
description:"Amplifies the damage multiplier of critical hits",
levels:[
{price:300,percent:0.5},
{price:800,percent:0.75},
{price:2000,percent:1}
]
},
{
id:"instantConversion",
name:"‚öôÔ∏è Instant Conv",
img:"instant_conversion_upgrade.png",
stat:"instantConversion",
description:"Instantly converts a portion of pollen to honey",
levels:[
{price:250,percent:10},
{price:650,percent:15},
{price:1500,percent:20}
]
},
{
id:"redPollen",
name:"üî¥ Red Pollen",
img:"pollen_upgrade.png",
stat:"redBonus",
description:"Improves efficiency of red pollen collection",
levels:[
{price:500,percent:10},
{price:1500,percent:15},
{price:4000,percent:20},
{price:15000,percent:30}
]
},
{
id:"whitePollen",
name:"‚ö™ White Pollen",
img:"pollen_upgrade.png",
stat:"whiteBonus",
description:"Improves efficiency of white pollen collection",
levels:[
{price:500,percent:10},
{price:1500,percent:15},
{price:4000,percent:20},
{price:15000,percent:30}
]
},
{
id:"bluePollen",
name:"üîµ Blue Pollen",
img:"pollen_upgrade.png",
stat:"blueBonus",
description:"Improves efficiency of blue pollen collection",
levels:[
{price:500,percent:10},
{price:1500,percent:15},
{price:4000,percent:20},
{price:15000,percent:30}
]
},
{
id:"yellowPollen",
name:"üíõ Yellow Pollen",
img:"pollen_upgrade.png",
stat:"yellowBonus",
description:"Improves efficiency of yellow pollen collection",
levels:[
{price:500,percent:10},
{price:1500,percent:15},
{price:4000,percent:20},
{price:15000,percent:30}
]
},
{
id:"purplePollen",
name:"üíú Purple Pollen",
img:"pollen_upgrade.png",
stat:"purpleBonus",
description:"Improves efficiency of purple pollen collection",
levels:[
{price:500,percent:10},
{price:1500,percent:15},
{price:4000,percent:20},
{price:15000,percent:30}
]
},
{
id:"maxSlots",
name:"üêù Buy Bee Slots",
img:"bee_basic.png",
stat:"maxSlots",
description:"Allows equipping more bees simultaneously",
levels:[
{price:10000,amount:1},
{price:20000,amount:1},
{price:35000,amount:1},
{price:50000,amount:1},
{price:75000,amount:1},
{price:100000,amount:1},
{price:150000,amount:1},
{price:200000,amount:1},
{price:300000,amount:1},
{price:500000,amount:1}
]
}
];
let upgradeLevels={pollen:0,convert:0,criticalChance:0,criticalPower:0,instantConversion:0,redPollen:0,whitePollen:0,bluePollen:0,yellowPollen:0,purplePollen:0,maxSlots:0};

/* ================= TILE UPGRADES ================= */
const TILE_UPGRADES = [
{
id:"gooTilePercent",
name:"üå∏ Goo Tile %",
img:"pollen_upgrade.png",
stat:"maxGooTiles",
description:"Increases the maximum amount of goo tiles that can appear",
levels:[
{price:1000,amount:1},
{price:3000,amount:1},
{price:7500,amount:1},
{price:20000,amount:1},
{price:50000,amount:1}
]
},
{
id:"growSpeed",
name:"üöÄ Grow Speed",
img:"pollen_upgrade.png",
stat:"tileRegenerationRange",
description:"Modifies tile regeneration speed range",
levels:[
{price:2000,regenerationRange:{min:400,max:1600}},
{price:5000,regenerationRange:{min:300,max:1300}},
{price:12000,regenerationRange:{min:200,max:1000}},
{price:30000,regenerationRange:{min:100,max:800}}
]
}
];
let tileUpgradeLevels={gooTilePercent:0,growSpeed:0};
let maxGooTiles = 0;
let tileRegenerationRange = {min:500,max:2000};

/* ================= SAVE / LOAD ================= */
function saveGame(){
  localStorage.setItem(SAVE_KEY,JSON.stringify({
    stats,upgradeLevels,currentField,fieldData,playTime,equippedTool,ownedTools,equippedToolId,ownedBees,equippedBees,discoveredBees,ownedSpecialBees,equippedSpecialBees,maxEquippedBeesEver,eggPrices,maxSlots,ownedStorages,equippedStorageId,fieldStats,claimedRewards,bouyanbeeStackCount,bouyanbeeMultiplier,bouyanbeeBlueCount,bouyanbeeLastBlueTime,bouyanbeeBaseCapacity,fuzzyDestructionCount,gooDestroyedCount,redPollenMultiplier,bluePollenMultiplier,whitePollenMultiplier,yellowPollenMultiplier,purplePollenMultiplier,tickets,ticketBeeAbilityTime,goldenBeeAbilityTime,tileTicketProbBonus,
    // Ability states
    fireBeeTilesActive,spicyTilesActive,gooTiles,fuzzyBuffActive,fuzzyBuffEndTime,fuzzyBuffCooldownEnd,demonTilesActive,activeLaserLines,lastFireBeeAbility,lastSpicyAbility,lastDemonAbility,lastLaserAbility,lastGooGeneration,gooColorCycle,energyTiles,lastTeslaBeeAbility,lastThunderBeeAbility,lastGooTileGeneration,activeGooTileIndices,lastPhotonAbility,lastDigitalRandomEffect,lastDigitalGlitch,glitchedTiles,lastMoonLaser,lastFourFormation,lastLionDestruction,
    // Tile upgrades
    tileUpgradeLevels,maxGooTiles,tileRegenerationRange
  }));
}
function loadGame(){
const s=JSON.parse(localStorage.getItem(SAVE_KEY));
if(!s)return;
Object.assign(stats,s.stats||{});
upgradeLevels=s.upgradeLevels||upgradeLevels;
currentField=s.currentField||currentField;

  // restore storages
  ownedStorages = s.ownedStorages || ownedStorages;
  equippedStorageId = s.equippedStorageId || equippedStorageId;
  fieldStats = s.fieldStats || fieldStats;

fieldData = {};
if (s.fieldData) {
  for (const fieldKey in s.fieldData) {
    fieldData[fieldKey] = s.fieldData[fieldKey].map(tile => {
      if (!tile || typeof tile !== 'object') return createTile(fieldKey);
      return {
        c: tile.c || "",
        ty: tile.ty !== undefined ? tile.ty : 0,
        transparent: tile.transparent === true
      };
    });
  }
}

playTime=s.playTime||0;
ownedTools=s.ownedTools||ownedTools;
equippedToolId=s.equippedToolId||"shovel";
ownedBees=s.ownedBees||ownedBees;
equippedBees=s.equippedBees||equippedBees;
discoveredBees=s.discoveredBees||discoveredBees;
ownedSpecialBees=s.ownedSpecialBees||ownedSpecialBees;
equippedSpecialBees=s.equippedSpecialBees||equippedSpecialBees;
claimedRewards=s.claimedRewards||claimedRewards;
maxEquippedBeesEver = s.maxEquippedBeesEver || maxEquippedBeesEver;
if(s.eggPrices) eggPrices = Object.assign(eggPrices || {}, s.eggPrices);
maxSlots = s.maxSlots || maxSlots;
bouyanbeeStackCount = s.bouyanbeeStackCount || 0;
bouyanbeeMultiplier = s.bouyanbeeMultiplier || 1.0;
bouyanbeeBlueCount = s.bouyanbeeBlueCount || 0;
bouyanbeeLastBlueTime = s.bouyanbeeLastBlueTime || 0;
bouyanbeeBaseCapacity = s.bouyanbeeBaseCapacity || bouyanbeeBaseCapacity;
fuzzyDestructionCount = s.fuzzyDestructionCount || 0;
gooDestroyedCount = s.gooDestroyedCount || 0;
redPollenMultiplier = s.redPollenMultiplier || 1.0;
bluePollenMultiplier = s.bluePollenMultiplier || 1.0;
whitePollenMultiplier = s.whitePollenMultiplier || 1.0;
yellowPollenMultiplier = s.yellowPollenMultiplier || 1.0;
purplePollenMultiplier = s.purplePollenMultiplier || 1.0;
// Restore ability states
fireBeeTilesActive = s.fireBeeTilesActive || {};
spicyTilesActive = s.spicyTilesActive || {};
gooTiles = s.gooTiles || {};
fuzzyBuffActive = s.fuzzyBuffActive || false;
fuzzyBuffEndTime = s.fuzzyBuffEndTime || 0;
fuzzyBuffCooldownEnd = s.fuzzyBuffCooldownEnd || 0;
demonTilesActive = s.demonTilesActive || {};
activeLaserLines = s.activeLaserLines || {};
lastLionDestruction = s.lastLionDestruction || 0;
lastFireBeeAbility = s.lastFireBeeAbility || 0;
lastSpicyAbility = s.lastSpicyAbility || 0;
lastDemonAbility = s.lastDemonAbility || 0;
lastDiamondCheck = s.lastDiamondCheck || 0;
lastLaserAbility = s.lastLaserAbility || 0;
lastGooGeneration = s.lastGooGeneration || 0;
gooColorCycle = s.gooColorCycle || 0;
energyTiles = s.energyTiles || {};
lastTeslaBeeAbility = s.lastTeslaBeeAbility || 0;
lastThunderBeeAbility = s.lastThunderBeeAbility || 0;
lastPhotonAbility = s.lastPhotonAbility || 0;
lastDigitalRandomEffect = s.lastDigitalRandomEffect || 0;
lastDigitalGlitch = s.lastDigitalGlitch || 0;
glitchedTiles = s.glitchedTiles || {};
lastMoonLaser = s.lastMoonLaser || 0;
lastFourFormation = s.lastFourFormation || 0;
lastGooTileGeneration = s.lastGooTileGeneration || 0;
activeGooTileIndices = s.activeGooTileIndices || [];
tickets = s.tickets || 0;
ticketBeeAbilityTime = s.ticketBeeAbilityTime || 0;
goldenBeeAbilityTime = s.goldenBeeAbilityTime || 0;
tileTicketProbBonus = s.tileTicketProbBonus || 0;
tileUpgradeLevels = s.tileUpgradeLevels || tileUpgradeLevels;
maxGooTiles = s.maxGooTiles || 0;
tileRegenerationRange = s.tileRegenerationRange || {min:500,max:2000};

const tool = TOOLS.find(t => t.id === equippedToolId);
if (tool) equippedTool = tool.name;

updateBeeAbilities();
}

/* ================= TIME ================= */
function formatTime(sec){
const h=Math.floor(sec/3600);
const m=Math.floor((sec%3600)/60);
const s=sec%60;
return `${h}h ${m}m ${s}s`;
}
setInterval(()=>{
playTime++;
updatePlayerStatsPanel();
saveGame();
},1000);

// call highlight on init
setTimeout(()=>{ try{ highlightShopTab('upgrades'); }catch(e){} },100);

/* ================= PROFILE EXPORT/IMPORT ================= */
const SAVES_KEY = "grassSaves";

function getSaves(){
  const saves = localStorage.getItem(SAVES_KEY);
  return saves ? JSON.parse(saves) : {};
}

function savesToLocalStorage(saves){
  localStorage.setItem(SAVES_KEY, JSON.stringify(saves));
}

function saveProfileToFolder(profileName){
  if(!profileName || profileName.trim() === ""){
    alert('Please enter a profile name');
    return;
  }
  
  const saves = getSaves();
  
  // Check if profile already exists
  if(saves[profileName]){
    if(!confirm(`Profile "${profileName}" already exists. Overwrite?`)) return;
  }
  
  const profileData = {
    version: "1.0",
    saveDate: new Date().toISOString(),
    profileName: profileName,
    stats,
    upgradeLevels,
    currentField,
    playTime,
    equippedTool,
    ownedTools,
    equippedToolId,
    ownedBees,
    equippedBees,
    maxEquippedBeesEver,
    eggPrices,
    maxSlots,
    ownedStorages,
    equippedStorageId,
    discoveredBees,
    ownedSpecialBees,
    equippedSpecialBees,
    fieldStats
  };
  
  saves[profileName] = profileData;
  savesToLocalStorage(saves);
  alert(`Profile "${profileName}" saved successfully in saves folder`);
  buildSavesManager();
}

function loadProfileFromFolder(profileName){
  const saves = getSaves();
  const profileData = saves[profileName];
  
  if(!profileData){
    alert(`Profile "${profileName}" does not exist`);
    return;
  }
  
  // Load data
  Object.assign(stats, profileData.stats || {});
  upgradeLevels = profileData.upgradeLevels || upgradeLevels;
  currentField = profileData.currentField || currentField;
  playTime = profileData.playTime || 0;
  equippedTool = profileData.equippedTool || equippedTool;
  ownedTools = profileData.ownedTools || ownedTools;
  equippedToolId = profileData.equippedToolId || equippedToolId;
  ownedBees = profileData.ownedBees || ownedBees;
  equippedBees = profileData.equippedBees || equippedBees;
  discoveredBees = profileData.discoveredBees || discoveredBees;
  ownedSpecialBees = profileData.ownedSpecialBees || ownedSpecialBees;
  equippedSpecialBees = profileData.equippedSpecialBees || equippedSpecialBees;
  claimedRewards = profileData.claimedRewards || claimedRewards;
  maxEquippedBeesEver = profileData.maxEquippedBeesEver || maxEquippedBeesEver;
  eggPrices = profileData.eggPrices || eggPrices;
  maxSlots = profileData.maxSlots || maxSlots;
  ownedStorages = profileData.ownedStorages || ownedStorages;
  equippedStorageId = profileData.equippedStorageId || equippedStorageId;
  fieldStats = profileData.fieldStats || fieldStats;
  
  // Rebuild grid and UI
  buildFieldList();
  buildGrid();
  buildUpgrades();
  buildTilesUpgrades();
  buildTools();
  updateBeeAbilities();
  updateUI();
  
  alert(`Profile "${profileName}" loaded successfully`);
  saveGame();
}

function deleteProfileFromFolder(profileName){
  if(!confirm(`Are you sure you want to delete profile "${profileName}"?`)) return;
  
  const saves = getSaves();
  delete saves[profileName];
  savesToLocalStorage(saves);
  alert(`Profile "${profileName}" deleted successfully`);
  buildSavesManager();
}

function buildSavesManager(){
  const modal = document.getElementById('savesModal');
  if(!modal) return;
  
  const saves = getSaves();
  const savesList = Object.keys(saves);
  
  let html = `
    <div style="position:relative;background:#1b1b1b;border-radius:0px;padding:16px;max-width:400px;box-shadow:0 10px 30px rgba(0,0,0,0.7)">
      <button onclick="closeSavesModal()" style="position:absolute;right:8px;top:8px;background:#333;border:none;color:#f1c40f;cursor:pointer;padding:4px 8px;border-radius:0px">‚úï</button>
      <h3 style="color:#f1c40f;margin:0 0 12px 0;text-align:center">üìÅ Saves Folder</h3>
      <div style="margin-bottom:12px">
        <input type="text" id="profileNameInput" placeholder="Profile Name" style="width:100%;padding:8px;background:#262626;border:1px solid #444;color:#fff;border-radius:0px;box-sizing:border-box;margin-bottom:8px">
        <button onclick="saveProfileToFolder(document.getElementById('profileNameInput').value)" class="small-btn" style="width:100%">üíæ Save Profile</button>
      </div>
      <div style="border-top:1px solid #444;padding-top:12px">
        <div style="font-size:12px;color:#ccc;margin-bottom:8px"><b>Saved Profiles (${savesList.length}):</b></div>
  `;
  
  if(savesList.length === 0){
    html += `<div style="color:#888;font-size:12px;text-align:center;padding:12px">No saved profiles</div>`;
  } else {
    savesList.forEach(name => {
      const save = saves[name];
      const date = new Date(save.saveDate).toLocaleString('es-ES');
      html += `
        <div style="background:#262626;padding:8px;border-radius:0px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center">
          <div style="flex:1">
            <div style="color:#f1c40f;font-size:12px;font-weight:bold">${name}</div>
            <div style="color:#888;font-size:10px">${date}</div>
            <div style="color:#bbb;font-size:10px">Miel: ${fmt(save.stats.totalHoney)}</div>
          </div>
          <div style="display:flex;gap:4px;flex-direction:column">
            <button onclick="loadProfileFromFolder('${name}')" class="small-btn" style="padding:4px 8px;font-size:10px;min-width:60px">üìÇ Load</button>
            <button onclick="deleteProfileFromFolder('${name}')" class="small-btn" style="padding:4px 8px;font-size:10px;min-width:60px;background:#c0392b;color:#fff">üóëÔ∏è Delete</button>
          </div>
        </div>
      `;
    });
  }
  
  html += `
      </div>
    </div>
  `;
  
  modal.innerHTML = html;
  modal.style.display = 'flex';
}

function openSavesManager(){
  let modal = document.getElementById('savesModal');
  if(!modal){
    modal = document.createElement('div');
    modal.id = 'savesModal';
    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:5000;';
    document.body.appendChild(modal);
  }
  buildSavesManager();
}

function closeSavesModal(){
  const modal = document.getElementById('savesModal');
  if(modal) modal.style.display = 'none';
}

/* ================= UPDATE UI ================= */
function calculateCapacity(){
  // Base capacity: 120 + storage bonuses (accumulated in stats.pollenCapacity from storage equips)
  const storage = STORAGE.find(s => s.id === equippedStorageId);
  let storageBonus = 0;
  if(storage && storage.bonuses && storage.bonuses.pollenCapacity){
    storageBonus = storage.bonuses.pollenCapacity;
  }
  
  const baseCapacity = 120 + storageBonus;
  
  // Apply Bouyan multiplier if any Bouyan Bee is equipped
  let bouyantMultiplier = 1.0;
  const bouyantBeeCount = equippedBees ? equippedBees.filter(id => id === 'bee7').length : 0;
  if(bouyantBeeCount > 0 && bouyanbeeStackCount > 0){
    // Each Bouyan Bee applies the multiplier independently
    bouyantMultiplier = Math.pow(bouyanbeeMultiplier, bouyantBeeCount);
  }
  
  return Math.floor(baseCapacity * bouyantMultiplier);
}

function updateUI(){
document.getElementById("pollen").textContent=fmt(stats.pollen);
document.getElementById("honey").textContent=fmt(stats.honey);
document.getElementById("tickets").textContent=tickets;
const capacity = calculateCapacity();
document.getElementById("capacity").textContent=fmt(capacity);
document.getElementById("pollenSec").textContent=fmt(pollenThisSec);
document.getElementById("honeySec").textContent=fmt(honeyThisSec);
updatePlayerStatsPanel();
updateAbilitiesGrid();

  // update current field title + requirement
  const fieldNameEl = document.getElementById('fieldName');
  const fieldReqEl = document.getElementById('fieldReq');
  if(fieldNameEl) fieldNameEl.textContent = fields[currentField] ? fields[currentField].name : currentField;
  if(fieldReqEl){
    const req = fieldRequirements[currentField] || 0;
    fieldReqEl.textContent = `Bees Field ¬∑ Requires: ${req}`;
  }

  // update fieldInfo (pollen collected, time spent, clicks)
  try{
    ensureFieldStats(currentField);
    const fi = document.getElementById('fieldInfo');
    if(fi){
      const data = fieldStats[currentField] || {pollenCollected:0,timeSpentSeconds:0,clicks:0};
      const extraSeconds = Math.floor((Date.now() - lastFieldEnter)/1000);
      const totalSeconds = (data.timeSpentSeconds || 0) + (currentField ? extraSeconds : 0);
      fi.innerHTML = `<div style="text-align:right"><b>${fmt(data.pollenCollected)} pollen</b></div><div style="color:#bbb">Time: ${formatTime(totalSeconds)}</div><div style="color:#bbb">Clicks: ${data.clicks}</div>`;
    }
  }catch(e){console.error(e)}
}

/* ================= STATS PANEL ================= */
function updatePlayerStatsPanel(){
const playerStatsPanelEl = document.getElementById("playerStatsPanel");
  // compute active synergies for display at top (detailed)
  const activeSynergies = SYNERGIES.filter(s => s.requirement.every(req => equippedBees.includes(req)));
  let synergiesHtml = '';
  if(activeSynergies.length > 0){
    synergiesHtml += `<div style="text-align:left;margin-bottom:6px;color:#AEF1C4;font-size:13px"><b>‚ö° Active Synergies:</b></div>`;
    activeSynergies.forEach(s => {
      const bonuses = Object.entries(s.bonus).map(([k,v])=>{
        const label = k.replace(/([A-Z])/g,' $1');
        const val = (String(k).toLowerCase().includes('chance') || String(k).toLowerCase().includes('power')) ? `${v}` : `${v}%`;
        return `<div style="font-size:12px;color:#CFF1D6;margin-left:6px">‚Ä¢ ${s.name}: ${label.trim()} ${val}</div>`;
      }).join('');
      synergiesHtml += bonuses;
    });
  } else {
    synergiesHtml = `<div style="text-align:center;margin-bottom:6px;color:#888;font-size:13px">‚ö° Synergies: None</div>`;
  }
  playerStatsPanelEl.innerHTML=`
<h3>üìä Stats</h3>
${synergiesHtml}
<b style="color:#f1c40f;font-size:12px">General</b>
<div class="player-stat"><span>üçØ Total Honey</span><span>${fmt(stats.totalHoney)}</span></div>
<div class="player-stat"><span>‚è±Ô∏è Playtime</span><span>${formatTime(playTime)}</span></div>
<div class="player-stat"><span>üîß Tool</span><span>${equippedTool}</span></div>
<div class="player-stat"><span>üì¶ Storage</span><span>${(() => { const st = STORAGE.find(st => st.id === equippedStorageId); return st ? st.name : 'None'; })()}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Bonuses</b>
<div class="player-stat"><span>üå∏ Pollen Bonus</span><span>+${stats.pollenBonus + stats.beePollenBonus}%</span></div>
<div class="player-stat"><span>üçØ Convert Rate</span><span>+${stats.convertBonus + stats.beeConvertBonus}%</span></div>
<div class="player-stat"><span>üì¶ Capacity</span><span>${fmt(stats.pollenCapacity)}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Combat</b>
<div class="player-stat"><span>‚ö° Crit Power</span><span>x${(stats.criticalPower + stats.beeCriticalPower).toFixed(2)}</span></div>
<div class="player-stat"><span>üí• Crit Chance</span><span>${stats.criticalChance + stats.beeCriticalChance}%</span></div>
<div class="player-stat"><span>üåü Super Critical</span><span>${stats.superCriticalChance}% (x10)</span></div>
<div class="player-stat"><span>‚öôÔ∏è Instant Conv</span><span>${stats.instantConversion + stats.beeInstantConversion}%</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Color Bonuses</b>
<div class="player-stat"><span>‚ö™ White</span><span>x${(whitePollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>üî¥ Red</span><span>x${(redPollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>üîµ Blue</span><span>x${(bluePollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>üíõ Yellow</span><span>x${(yellowPollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>üíú Purple</span><span>x${(purplePollenMultiplier).toFixed(2)}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Total Collected</b>
<div class="player-stat"><span>‚ö™ White Total</span><span>${fmt(stats.whiteTotal)}</span></div>
<div class="player-stat"><span>üî¥ Red Total</span><span>${fmt(stats.redTotal)}</span></div>
<div class="player-stat"><span>üîµ Blue Total</span><span>${fmt(stats.blueTotal)}</span></div>
<div class="player-stat"><span>üíõ Yellow Total</span><span>${fmt(stats.yellowTotal)}</span></div>
<div class="player-stat"><span>üíú Purple Total</span><span>${fmt(stats.purpleTotal)}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Multipliers</b>
<div class="player-stat"><span>üî• Fire</span><span>x${stats.fireMultiplier.toFixed(1)}</span></div>
<div class="player-stat"><span>üåë Dark Fire</span><span>x${stats.darkFireMultiplier.toFixed(1)}</span></div>
<div class="player-stat"><span>üíó Goo</span><span>x${stats.gooMultiplier.toFixed(2)}</span></div>
<div class="player-stat"><span>üíó Goo Pollen</span><span>${fmt(stats.gooPollenCollected)}</span></div>
${equippedBees.length > 0 ? `<hr style="opacity:.2">
<div class="player-stat"><span>üêù Equipped</span><span>${equippedBees.length}/${maxSlots}</span></div>
<div class="player-stat"><span>üêù Max Equipped Ever</span><span>${maxEquippedBeesEver}</span></div>
${stats.beePollenBonus > 0 ? `<div class="player-stat"><span>üå∏ Bee Pollen</span><span>+${stats.beePollenBonus}%</span></div>` : ''}
${stats.beeCriticalChance > 0 ? `<div class="player-stat"><span>üí• Bee Crit</span><span>+${stats.beeCriticalChance}%</span></div>` : ''}
${stats.beeInstantConversion > 0 ? `<div class="player-stat"><span>‚öôÔ∏è Bee Conv</span><span>+${stats.beeInstantConversion}%</span></div>` : ''}
${(() => {
  const synergies = SYNERGIES.filter(s => s.requirement.every(req => equippedBees.includes(req)));
  return synergies.length > 0 ? `<div class="player-stat"><span>‚ö° Synergies</span><span>${synergies.length}</span></div>` : '';
})()}` : ''}
<hr style="opacity:.2">
<div style="display:flex;gap:6px;margin-top:8px">
  <button class="small-btn" onclick="openSavesManager()" style="flex:1;font-size:11px;padding:6px 4px">üìÅ Saves</button>
</div>
`;
}

// Register ability execution to show it in the abilities grid for 10 seconds
function registerAbilityExecution(abilityName){
  if(!abilityName || !ABILITY_TYPES[abilityName]) return;
  
  // Get ability info from ABILITY_TYPES
  const abilityDef = ABILITY_TYPES[abilityName];
  
  // Add to active abilities
  activeAbilities.push({
    ability: abilityName,
    name: abilityDef.name,
    color: abilityDef.color,
    img: abilityDef.img,
    desc: abilityDef.desc,
    executeTime: Date.now(),
    maxCooldown: abilityDef.maxCooldown || 3
  });
}

// Update abilities grid with recently executed abilities

function updateAbilitiesGrid(){
  const gridEl = document.getElementById('abilitiesGrid');
  if(!gridEl) return;
  
  const now = Date.now();
  
  // Remove abilities older than 10 seconds
  activeAbilities = activeAbilities.filter(a => (now - a.executeTime) < 10000);
  
  // Render active abilities
  let html = '';
  activeAbilities.forEach((ability, idx) => {
    const elapsed = (now - ability.executeTime) / 1000;
    const remaining = Math.max(0, 10 - elapsed);
    const specialClass = ability.isSpecial ? 'special' : '';
    html += `
      <div class="ability-slot ${specialClass}" style="background-color:${ability.color};" onmousemove="showAbilityTooltip(event, '${ability.name}', '${ability.ability}', '${ability.desc}')" onmouseout="hideAbilityTooltip()">
        <img src="images/${ability.img}" style="opacity:0.7" alt="">
        <div class="ability-cooldown">${remaining.toFixed(1)}s</div>
      </div>
    `;
  });
  
  gridEl.innerHTML = html;
}

// Get cooldown info for a specific ability
function getCooldownInfo(abilityName){
  const now = Date.now();
  
  // Map abilities to their cooldown timers with max cooldown
  const cooldownMap = {
    'fireBeeAbility': { nextTime: lastFireBeeAbility + 3000, maxCooldown: 3 },
    'spicyAbility': { nextTime: lastSpicyAbility + 2000, maxCooldown: 2 },
    'demonBeeAbility': { nextTime: lastDemonAbility + 4000, maxCooldown: 4 },
    'laserBeeAbility': { nextTime: lastLaserAbility + 2000, maxCooldown: 2 },
    'gooAbility': { nextTime: lastGooGeneration + 2000, maxCooldown: 2 },
    'teslaBeeAbility': { nextTime: lastTeslaBeeAbility + 3000, maxCooldown: 3 },
    'thunderBeeAbility': { nextTime: lastThunderBeeAbility + 2000, maxCooldown: 2 },
    'photonAbility': { nextTime: lastPhotonAbility + 0.5 * 1000 + Math.random() * 1500, maxCooldown: 2 },
    'digitalRandomEffect': { nextTime: lastDigitalRandomEffect + 30000, maxCooldown: 30 },
    'digitalGlitch': { nextTime: lastDigitalGlitch + 60000 + Math.random() * 60000, maxCooldown: 120 },
    'moonBeeAbility': { nextTime: lastMoonLaser + 3000, maxCooldown: 3 },
    'lionBeeAutoDestruct': { nextTime: lastLionDestruction + 30000 + Math.random() * 30000, maxCooldown: 60 },
    'fourFormation': { nextTime: lastFourFormation + 2000, maxCooldown: 2 }
  };
  
  return cooldownMap[abilityName] || null;
}

// Show ability tooltip
function showAbilityTooltip(event, name, ability, desc){
  let html = `<b>${name}</b><br><i style="color:#f1c40f">${ability}</i><br><br>${desc}`;
  
  const tt = document.getElementById('abilityTooltip') || document.createElement('div');
  tt.id = 'abilityTooltip';
  tt.className = 'ability-tooltip';
  tt.innerHTML = html;
  tt.style.left = event.pageX + 10 + 'px';
  tt.style.top = event.pageY + 10 + 'px';
  document.body.appendChild(tt);
}

// Hide ability tooltip
function hideAbilityTooltip(){
  const tt = document.getElementById('abilityTooltip');
  if(tt) tt.remove();
}

function drawPattern(p){
  return p.map(r=>`
    <div class="row">
      ${r.map(c=>`<span class="${c?"on":"off"}"></span>`).join("")}
    </div>
  `).join("");
}

// Draw a 9x9 tool pattern as a DOM grid optimized for tool frames
function drawToolPatternDOM(pattern){
  const grid = document.createElement('div');
  grid.className = 'tool-grid';
  // ensure we always render 9x9
  const rows = 9;
  const cols = 9;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      const val = (pattern && pattern[y] && pattern[y][x]) ? pattern[y][x] : 0;
      if(val) cell.classList.add('on');
      grid.appendChild(cell);
    }
  }
  return grid;
}

function buildTools(){
  const toolsEl = document.getElementById("tools");
  toolsEl.innerHTML="";
  TOOLS.forEach(t=>{
    const owned = ownedTools.includes(t.id);
    const equipped = equippedToolId === t.id;

    const f = document.createElement('div');
    f.className = 'tool-frame';

    // top-left: name + desc
    const top = document.createElement('div');
    top.className = 'tool-top';
    const nameEl = document.createElement('div'); nameEl.className='tool-name'; nameEl.textContent = t.name;
    const descEl = document.createElement('div'); descEl.className='tool-desc'; descEl.textContent = t.desc;
    top.appendChild(nameEl); 
    top.appendChild(descEl);
    
    // Add stats info
    const tilesCount = (t.pattern || []).reduce((acc,row)=>acc + (row.reduce?row.reduce((a,b)=>a+b,0):0),0);
    const statsEl = document.createElement('div'); 
    statsEl.className='upgrade-desc'; 
    statsEl.style.color='#aef1c4';
    statsEl.style.marginTop='4px';
    statsEl.textContent = `${tilesCount} tiles ‚Ä¢ Pollen: +${t.pollenBonus}% ‚Ä¢ Cooldown: ${t.cooldown/1000}s`;
    top.appendChild(statsEl);
    
    f.appendChild(top);

    // Benefits list
    const benefitsEl = document.createElement('div');
    benefitsEl.style.fontSize = '12px';
    benefitsEl.style.marginTop = '6px';
    benefitsEl.style.padding = '4px';
    benefitsEl.style.background = 'rgba(0,0,0,0.3)';
    benefitsEl.style.borderRadius = '3px';
    let benefitsHTML = '<div style="color:#AEF1C4;font-weight:bold;margin-bottom:3px">Benefits:</div>';
    if(t.pollenBonus) benefitsHTML += `<div>‚Ä¢ Pollen: +${t.pollenBonus}%</div>`;
    if(t.cooldown) benefitsHTML += `<div>‚Ä¢ Cooldown: ${t.cooldown/1000}s</div>`;
    if(tilesCount) benefitsHTML += `<div>‚Ä¢ Tiles: ${tilesCount}</div>`;
    if(t.bonuses){
      Object.entries(t.bonuses).forEach(([k,v]) => {
        const label = k.replace(/([A-Z])/g,' $1').trim();
        benefitsHTML += `<div>‚Ä¢ ${label}: +${v}${(k.includes('bonus')||k.includes('rate'))?'%':''}</div>`;
      });
    }
    benefitsEl.innerHTML = benefitsHTML;
    f.appendChild(benefitsEl);

    // pattern area on center-right
    const patWrap = document.createElement('div'); patWrap.className='tool-pattern'; patWrap.appendChild(drawToolPatternDOM(t.pattern));
    f.appendChild(patWrap);

    // bottom row: button (left) and price (right)
    const btn = document.createElement('button'); btn.className='small-btn';
    btn.style.minWidth = '50px';
    const bottom = document.createElement('div'); bottom.className='tool-bottom';
    if(!owned){
      btn.textContent = 'BUY';
      btn.onclick = ()=>{
        if(stats.honey < t.price) return; stats.honey -= t.price; ownedTools.push(t.id); equipTool(t.id);
      };
    } else if(!equipped){
      btn.textContent = 'EQUIP'; btn.onclick = ()=>equipTool(t.id);
    } else { btn.textContent='EQUIPPED'; btn.disabled = true; }

    bottom.appendChild(btn);
    f.appendChild(bottom);
    const priceWrap = document.createElement('div');
    priceWrap.className = 'tool-price-wrap';
    const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = fmt(t.price) + ' üçØ';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);

    toolsEl.appendChild(f);
  });
}

function equipTool(id){
  // remove bonuses from previously equipped tool
  const prevTool = TOOLS.find(t=>t.id===equippedToolId);
  if(prevTool && prevTool.bonuses){
    for(const [k,v] of Object.entries(prevTool.bonuses)){
      stats[k] = (stats[k] || 0) - v;
    }
  }

  equippedToolId = id;
  const tool = TOOLS.find(t=>t.id===id);
  if(tool){
    equippedTool = tool.name;
    stats.cooldown = tool.cooldown;
    if(tool.bonuses){
      for(const [k,v] of Object.entries(tool.bonuses)){
        stats[k] = (stats[k] || 0) + v;
      }
    }
  }

  saveGame();
  buildTools();
  updateUI();
}

function equipBee(beeId, slot){
  if(slot === undefined) {
    if(equippedBees.length < maxSlots) {
      equippedBees.push(beeId);
      // actualizar m√°ximo hist√≥rico
      maxEquippedBeesEver = Math.max(maxEquippedBeesEver, equippedBees.length);
    } else {
      return;
    }
  } else {
    equippedBees[slot] = beeId;
    maxEquippedBeesEver = Math.max(maxEquippedBeesEver, equippedBees.filter(Boolean).length);
  }
  
  saveGame();
  buildBeeGrid();
  updateBeeAbilities();
  updateUI();
  // Update bee counter in real-time
  const counterDiv = document.getElementById('beeCounterDiv');
  if(counterDiv) updateBeeCounter(counterDiv);
}

function unequipBee(slot){
  equippedBees.splice(slot, 1);
  saveGame();
  buildBeeGrid();
  updateBeeAbilities();
  updateUI();
  // Update bee counter in real-time
  const counterDiv = document.getElementById('beeCounterDiv');
  if(counterDiv) updateBeeCounter(counterDiv);
}

function updateBeeAbilities(){
  const beeBonus = {pollenBonus:0,convertBonus:0,criticalChance:0,criticalPower:0,instantConversion:0,honeyBonus:0,capacityBonus:0};
  
  // Reset color multipliers
  redPollenMultiplier = 1.0;
  bluePollenMultiplier = 1.0;
  whitePollenMultiplier = 1.0;
  yellowPollenMultiplier = 1.0;
  purplePollenMultiplier = 1.0;
  
  equippedBees.forEach(beeId => {
    const bee = BEES.find(b => b.id === beeId);
    if(bee) {
      let abilityValue = bee.value;
      
      // Apply special bees multipliers if any are equipped
      if(equippedSpecialBees && equippedSpecialBees.length > 0){
        equippedSpecialBees.forEach(specialBeeId => {
          const specialBee = SPECIAL_BEES.find(sb => sb.id === specialBeeId);
          if(specialBee && specialBee.bonusMultipliers && specialBee.bonusMultipliers[bee.id]){
            abilityValue *= specialBee.bonusMultipliers[bee.id];
          }
        });
      }
      
      // Handle abilities that don't fit standard bonus system
      if(bee.id === 'bee11'){ // Tenacity Bee - x2 red pollen
        redPollenMultiplier = bee.value;
      } else if(bee.id === 'bee12'){ // Bubble Bee - x2 blue pollen
        bluePollenMultiplier = bee.value;
      } else if(bee.id === 'bee13'){ // Petal Bee - x2 white pollen
        whitePollenMultiplier = bee.value;
      } else if(bee.id === 'bee9'){ // Lazy Bee - instant conversion
        beeBonus.instantConversion = (beeBonus.instantConversion || 0) + bee.value;
      } else if(bee.id === 'bee10'){ // Commander Bee - crit bonuses
        beeBonus.criticalChance = (beeBonus.criticalChance || 0) + 2;
        beeBonus.criticalPower = (beeBonus.criticalPower || 0) + 0.05; // +5%
      } else if(bee.id === 'bee14'){ // Demon Bee - crit bonuses + ability
        beeBonus.criticalChance = (beeBonus.criticalChance || 0) + 3;
        beeBonus.criticalPower = (beeBonus.criticalPower || 0) + 0.15; // +15%
      } else if(bee.id === 'bee15'){ // Diamond Bee - convert rate buff
        beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 25;
      } else if(bee.id === 'bee16'){ // Laser Bee - pollen bonus + ability
        beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 10;
      } else if(bee.id === 'bee17'){ // Thunder Bee - blue pollen + goo + ability
        bluePollenMultiplier = (bluePollenMultiplier || 1) * 1.5;
        beeBonus.gooMultiplier = (beeBonus.gooMultiplier || 0) + 1; // +100% goo
      } else if(bee.ability !== 'none' && bee.ability !== 'fireBee' && bee.ability !== 'bouyanbee' && bee.ability !== 'spicyBee' && bee.ability !== 'fuzzyBuff' && bee.ability !== 'gummyBee' && bee.ability !== 'instantConvBoost' && bee.ability !== 'commanderBuff' && bee.ability !== 'demonBee' && bee.ability !== 'laserBee'){
        beeBonus[bee.ability] = (beeBonus[bee.ability] || 0) + abilityValue;
      }
    }
  });
  
  // Add special bees abilities if equipped
  if(equippedSpecialBees && equippedSpecialBees.length > 0){
    equippedSpecialBees.forEach(specialBeeId => {
      const specialBee = SPECIAL_BEES.find(b => b.id === specialBeeId);
      if(specialBee){
        if(specialBee.id === 'special_bee3'){ // Gummy Bee
          startGummyBeeSystem();
          gummyBeeTick();
        } else if(specialBee.id === 'special_bee4'){ // Tesla Bee
          beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 50;
          beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 30;
          bluePollenMultiplier = (bluePollenMultiplier || 1) * 2;
          console.log('‚ö° Tesla Bee ACTIVATED! +50% Convert, +30% Instant Conversion, x2 Blue Pollen');
        } else if(specialBee.id === 'special_bee1'){ // Golden Queen - 5 Basic Bees
          const basicBeeCount = equippedBees.filter(id => id === 'bee1').length;
          console.log(`üêù Golden Queen - Basic Bee count: ${basicBeeCount} (need 5)`);
          if(basicBeeCount >= 5){
            beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 10000;
            beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 100;
            console.log('üëë Golden Queen ACTIVATED! +1500% Convert Bonus, +50% Instant Conversion');
          }
        }
        // Royal Guard handled in doToolTick
        beeBonus[specialBee.ability] = (beeBonus[specialBee.ability] || 0) + specialBee.value;
      }
    });
  }
  
  // Check for special ability bees in equippedBees
  const hasFireBee = equippedBees.includes('bee6');
  const hasBouyanbee = equippedBees.includes('bee7');
  const hasSpicyBee = equippedBees.includes('bee8');
  const hasDemonBee = equippedBees.includes('bee14');
  const hasDiamondBee = equippedBees.includes('bee15');
  const hasLaserBee = equippedBees.includes('bee16');
  const hasThunderBee = equippedBees.includes('bee17');
  
  if(hasFireBee){
    fireBeeTick();
  }
  if(hasSpicyBee){
    spicyBeeTick();
  }
  if(hasDemonBee){
    demonBeeTick();
  }
  if(hasLaserBee){
    laserBeeTick();
  }
  if(hasThunderBee){
    thunderBeeTick();
  }
  
  // Check for Tesla Bee
  const hasTeslaBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee4');
  if(hasTeslaBee){
    teslaBeeAbility();
  }
  
  // Check for Ticket Bee and Golden Bee
  const hasTicketBee = equippedBees && equippedBees.includes('bee18');
  const hasGoldenBee = equippedBees && equippedBees.includes('bee19');
  if(hasTicketBee){
    ticketBeeAbility();
  }
  if(hasGoldenBee){
    goldenBeeAbility();
    // Golden Bee adds +5% tile ticket spawn chance
    tileTicketProbBonus = 0.05;
    // Apply Golden Bee buffs
    beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 5;
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 100;
    beeBonus.capacityBonus = (beeBonus.capacityBonus || 0) + 100000;
  } else {
    tileTicketProbBonus = 0;
  }
  
  // Ticket Bee adds instant conversion buff
  if(hasTicketBee){
    beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 5;
  }
  
  // Update energy tiles and spicy tiles
  updateEnergyTiles();
  
  // Stop abilities if neither special bees nor ability bees are equipped
  if((!equippedSpecialBees || equippedSpecialBees.length === 0) && !hasFireBee && !hasBouyanbee && !hasSpicyBee && !hasDemonBee && !hasDiamondBee && !hasLaserBee && !hasThunderBee){
    stopSpecialBeeAbilities();
  }
  
  updateSynergies(beeBonus);
  
  // rarity-based convert bonuses (per equipped bee)
  const rarityConvertMap = {common:20, rare:60, epic:150, legendary:300, mythic:500};
  let rarityConvertBonus = 0;
  equippedBees.forEach(beeId => {
    const bee = BEES.find(b => b.id === beeId);
    if(bee && bee.rarity){
      rarityConvertBonus += (rarityConvertMap[bee.rarity] || 0);
    }
  });

  // Check for Lion Bee
  const hasLionBee = equippedBees && equippedBees.includes('bee20');
  if(hasLionBee){
    lionBeeAbility();
    lionBeeAutoDestruct();
    // Lion Bee buffs
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 20;
    beeBonus.criticalPower = (beeBonus.criticalPower || 0) + 10;
    yellowPollenMultiplier = 2.0;
  }
  
  // Check for Rad Bee (already has convertBonus value, just needs to be applied)
  const hasRadBee = equippedBees && equippedBees.includes('bee21');
  if(hasRadBee){
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 5;
  }
  
  // Check for Silver Bee
  const hasSilverBee = equippedBees && equippedBees.includes('bee22');
  if(hasSilverBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 20;
    whitePollenMultiplier = 1.5;
  }
  
  // Check for Moon Bee
  const hasMoonBee = equippedBees && equippedBees.includes('bee23');
  if(hasMoonBee){
    moonBeeAbility();
    bluePollenMultiplier = 2.0;
    purplePollenMultiplier = 2.0;
  }
  
  // Check for Devil Bee
  const hasDevilBee = equippedBees && equippedBees.includes('bee24');
  if(hasDevilBee){
    // Fire pollen x2 is handled in applyToolPattern
    redPollenMultiplier = 1.5;
  }
  
  // Check for Four Bee
  const hasFourBee = equippedBees && equippedBees.includes('bee25');
  if(hasFourBee){
    fourBeeAbility();
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 44;
    stats.beeCriticalChance = (stats.beeCriticalChance || 0) + 4;
    stats.beeCriticalPower = (stats.beeCriticalPower || 0) + 44;
  }
  
  // Check for Spark Bee (bee26)
  const hasSparkBee = equippedBees && equippedBees.includes('bee26');
  if(hasSparkBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 3;
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 3;
  }
  
  // Check for Swift Bee (bee27)
  const hasSwiftBee = equippedBees && equippedBees.includes('bee27');
  if(hasSwiftBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 4;
    stats.beeCriticalChance = (stats.beeCriticalChance || 0) + 1;
  }
  
  // Check for Echo Bee (bee28)
  const hasEchoBee = equippedBees && equippedBees.includes('bee28');
  if(hasEchoBee){
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 4;
    beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 2;
  }
  
  // Check for Drift Bee (bee29)
  const hasDriftBee = equippedBees && equippedBees.includes('bee29');
  if(hasDriftBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 5;
  }
  
  // Check for Glow Bee (bee30)
  const hasGlowBee = equippedBees && equippedBees.includes('bee30');
  if(hasGlowBee){
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 5;
  }
  
  // Check for Shade Bee (bee31)
  const hasShadeBee = equippedBees && equippedBees.includes('bee31');
  if(hasShadeBee){
    stats.beeCriticalChance = (stats.beeCriticalChance || 0) + 2;
    stats.beeCriticalPower = (stats.beeCriticalPower || 0) + 2;
  }
  
  // Check for Aura Bee (bee32)
  const hasAuraBee = equippedBees && equippedBees.includes('bee32');
  if(hasAuraBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 3;
    beeBonus.capacityBonus = (beeBonus.capacityBonus || 0) + 5000;
  }
  
  // Check for Prism Bee (bee33)
  const hasPrismBee = equippedBees && equippedBees.includes('bee33');
  if(hasPrismBee){
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 6;
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 2;
  }
  
  // Check for Volt Bee (bee34)
  const hasVoltBee = equippedBees && equippedBees.includes('bee34');
  if(hasVoltBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 4;
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 4;
  }
  
  // Check for Ember Bee (bee35)
  const hasEmberBee = equippedBees && equippedBees.includes('bee35');
  if(hasEmberBee){
    redPollenMultiplier = redPollenMultiplier * 1.1;
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 2;
  }
  
  // Check for Inferno Bee (bee36)
  const hasInfernoBee = equippedBees && equippedBees.includes('bee36');
  if(hasInfernoBee){
    redPollenMultiplier = redPollenMultiplier * 1.2;
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 6;
  }
  
  // Check for Ocean Bee (bee37)
  const hasOceanBee = equippedBees && equippedBees.includes('bee37');
  if(hasOceanBee){
    bluePollenMultiplier = bluePollenMultiplier * 1.15;
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 8;
  }
  
  // Check for Nature Bee (bee38)
  const hasNatureBee = equippedBees && equippedBees.includes('bee38');
  if(hasNatureBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 8;
    beeBonus.capacityBonus = (beeBonus.capacityBonus || 0) + 8000;
  }
  
  // Check for Mystic Bee (bee39)
  const hasMysticBee = equippedBees && equippedBees.includes('bee39');
  if(hasMysticBee){
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 10;
    stats.beeCriticalChance = (stats.beeCriticalChance || 0) + 3;
  }
  
  // Check for Cosmic Bee (bee40)
  const hasCosmicBee = equippedBees && equippedBees.includes('bee40');
  if(hasCosmicBee){
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 10;
    beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 3;
  }
  
  // Check for Photon Bee
  const hasPhotonBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee5');
  if(hasPhotonBee){
    photonBeeAbility();
    // Photon Bee buffs
    beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 25;
    beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 200;
    yellowPollenMultiplier = 2.0;
  }
  
  // Check for Digital Bee
  const hasDigitalBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee6');
  if(hasDigitalBee){
    digitalBeeAbility();
    // Digital Bee buffs
    beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + 1000;
    stats.beeCriticalChance = (stats.beeCriticalChance || 0) + 30;
  }
  
  stats.beePollenBonus = beeBonus.pollenBonus;
  // combine ability-based convert bonus with rarity bonuses
  stats.beeConvertBonus = (beeBonus.convertBonus || 0) + rarityConvertBonus;
  
  // Apply Royal Guard temporary buff and cooldown system
  let royalGuardBonus = 0;
  if(equippedSpecialBees && equippedSpecialBees.includes('special_bee2')){
    const now = Date.now();
    
    // Check cooldown first
    if(royalGuardCooldownActive){
      const cooldownElapsedTime = now - royalGuardCooldownStartTime;
      if(cooldownElapsedTime < 5000){ // 5 second cooldown
        // Still in cooldown, don't count crits
      } else {
        royalGuardCooldownActive = false; // Cooldown expired
      }
    }
    
    // Check buff
    if(royalGuardBuffActive){
      const buffElapsedTime = now - royalGuardBuffStartTime;
      if(buffElapsedTime < 2000){ // 2 second buff duration
        royalGuardBonus = 1000; // +1000% critical chance
      } else {
        royalGuardBuffActive = false; // Buff expired
        royalGuardCooldownActive = true; // Start cooldown
        royalGuardCooldownStartTime = now;
        console.log('‚è≥ Royal Guard cooldown started (5s) - crits won\'t count');
      }
    }
  }
  
  stats.beeCriticalChance = beeBonus.criticalChance + royalGuardBonus;
  stats.beeCriticalPower = beeBonus.criticalPower;
  stats.beeInstantConversion = beeBonus.instantConversion;
  stats.beeHoneyBonus = beeBonus.honeyBonus;
  stats.beeCapacityBonus = beeBonus.capacityBonus;
  
  // Call ability ticks for Fire/Spicy/Gummy Bees
  fireBeeTick();
  spicyBeeTick();
  gummyBeeTick();
  gooTileSystemTick(); // Tile upgrade system - Goo Tile generation
}

function updateSynergies(beeBonus){
  SYNERGIES.forEach(synergy => {
    const hasAllRequired = synergy.requirement.every(req => equippedBees.includes(req));
    if(hasAllRequired) {
      for(const [stat, value] of Object.entries(synergy.bonus)) {
        beeBonus[stat] = (beeBonus[stat] || 0) + value;
      }
    }
  });
}

function fireBeeTick(){
  if(!equippedBees || !equippedBees.includes('bee6')) return;
  
  const now = Date.now();
  const nextAbility = lastFireBeeAbility + Math.random() * 72000 + 20000; // 20s - 1.2min
  if(now < nextAbility) return;
  
  lastFireBeeAbility = now;
  registerAbilityExecution('fireBeeAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const tilesToBurn = Math.floor(Math.random() * 5) + 1; // 1-5 casillas
  
  for(let i = 0; i < tilesToBurn; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    if(currentField && fieldData[currentField]){
      const tile = fieldData[currentField][idx];
      if(tile && tile.ty > 0){ // casilla no vac√≠a
        // Remove any existing buff (only 1 buff per tile)
        delete spicyTilesActive[idx];
        delete gooTiles[idx];
        delete energyTiles[idx];
        
        // Mark tile with fire overlay (10 second duration)
        fireBeeTilesActive[idx] = {
          createdAt: now,
          durationMs: 10000,
          basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
          tileColor: tile.c || ''
        };
        
        // Visual effect: add border and particles
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          // Add fire effect class
          tileEl.classList.add("fire-effect");
          
          const r = tileEl.getBoundingClientRect();
          
          // Fire particles (8 total, 3px, upward motion)
          for(let p = 0; p < 8; p++){
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.left = r.left + r.width/2 + 'px';
            particle.style.top = r.top + r.height/2 + 'px';
            particle.style.width = '3px';
            particle.style.height = '3px';
            particle.style.borderRadius = '50%';
            particle.style.background = ['#FF4500', '#FF6347', '#FFD700'][Math.floor(Math.random()*3)];
            particle.style.pointerEvents = 'none';
            particle.style.zIndex = '9999';
            particle.style.boxShadow = '0 0 4px ' + particle.style.background;
            document.body.appendChild(particle);
            
            const startTime = Date.now();
            let px = r.left + r.width/2;
            let py = r.top + r.height/2;
            
            const particleAnim = setInterval(()=>{
              const elapsed = Date.now() - startTime;
              py -= 30 * 0.016; // Slow upward motion
              particle.style.left = px + 'px';
              particle.style.top = py + 'px';
              particle.style.opacity = Math.max(0, 1 - elapsed / 500);
              if(elapsed > 500){
                clearInterval(particleAnim);
                particle.remove();
              }
            }, 16);
          }
        }
      }
    }
  }
}

function spicyBeeTick(){
  if(!equippedBees || !equippedBees.includes('bee8')) return;
  const now = Date.now();
  if(now < nextSpicyAbilityTime) return;
  lastSpicyAbility = now;
  registerAbilityExecution('spicyAbility');
  nextSpicyAbilityTime = now + (Math.random() * 90000 + 30000); // 30-120s (0.5-2 min)
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Seleccionar 1-5 casillas aleatorias (sin patr√≥n)
  const tileCount = Math.floor(Math.random() * 5) + 1;
  const burnedTiles = [];
  
  for(let i = 0; i < tileCount; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    if(!burnedTiles.includes(idx)) burnedTiles.push(idx);
  }
  
  // Mark tiles with dark fire overlay (10 second duration, destroyed on click = x7 pollen)
  burnedTiles.forEach(idx => {
    if(!currentField || !fieldData[currentField]) return;
    const tile = fieldData[currentField][idx];
    if(!tile || !tile.ty) return;
    // Remove any existing buff (only 1 buff per tile)
    delete fireBeeTilesActive[idx];
    delete gooTiles[idx];
    delete energyTiles[idx];
    spicyTilesActive[idx] = {
      createdAt: now,
      durationMs: 20000,
      basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
      tileColor: tile.c || ''
    };
    // Visual effect: dark fire border con gradient rojo-naranja-amarillo y particles
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if(tileEl){
      tileEl.classList.add("dark-fire-effect");
      
      // Dark fire particles
      const r = tileEl.getBoundingClientRect();
      for(let p = 0; p < 8; p++){
        const particle = document.createElement('div');
        particle.style.position = 'fixed';
        particle.style.left = r.left + r.width/2 + 'px';
        particle.style.top = r.top + r.height/2 + 'px';
        particle.style.width = '4px';
        particle.style.height = '4px';
        particle.style.borderRadius = '50%';
        particle.style.background = p < 4 ? '#DC143C' : '#FFD700';
        particle.style.pointerEvents = 'none';
        particle.style.zIndex = '9999';
        particle.style.boxShadow = '0 0 6px ' + particle.style.background;
        document.body.appendChild(particle);
        const startTime = Date.now();
        let px = r.left + r.width/2;
        let py = r.top + r.height/2;
        const particleAnim = setInterval(()=>{
          const elapsed = Date.now() - startTime;
          py -= 40 * 0.016;
          particle.style.left = px + 'px';
          particle.style.top = py + 'px';
          particle.style.opacity = Math.max(0, 1 - elapsed / 600);
          if(elapsed > 600){
            clearInterval(particleAnim);
            particle.remove();
          }
        }, 16);
      }
    }
  });
}

function demonBeeTick(){
  if(!equippedBees || !equippedBees.includes('bee14')) return;
  
  const now = Date.now();
  const nextAbility = lastDemonAbility + Math.random() * 70000 + 40000; // 40s-110s (1.1 min)
  if(now < nextAbility) return;
  
  lastDemonAbility = now;
  registerAbilityExecution('demonBeeAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Seleccionar 1-3 casillas aleatorias
  const tileCount = Math.floor(Math.random() * 3) + 1;
  const burnedTiles = [];
  
  for(let i = 0; i < tileCount; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    if(!burnedTiles.includes(idx)) burnedTiles.push(idx);
  }
  
  // Mark tiles (80% fire, 20% dark fire)
  burnedTiles.forEach(idx => {
    if(!currentField || !fieldData[currentField]) return;
    const tile = fieldData[currentField][idx];
    if(!tile || !tile.ty) return;
    
    const isFireTile = Math.random() * 100 < 80;
    
    if(isFireTile){
      // Fire tile
      fireBeeTilesActive[idx] = {
        createdAt: now,
        durationMs: 10000,
        basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
        tileColor: tile.c || ''
      };

      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.add("fire-effect");
      }
    } else {
      // Dark fire tile
      spicyTilesActive[idx] = {
        createdAt: now,
        durationMs: 20000,
        basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
        tileColor: tile.c || ''
      };

      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.add("dark-fire-effect");
      }
    }
  });
}

function laserBeeTick(){
  if(!equippedBees || !currentField || !fieldData[currentField]) return;
  
  // Count how many Laser Bees are equipped
  const laserBeeCount = (equippedBees || []).filter(bee => bee === 'bee16').length;
  if(laserBeeCount === 0) return;
  
  const now = Date.now();
  const nextAbility = lastLaserAbility + 60000; // Every 60 seconds
  if(now < nextAbility) return;
  
  lastLaserAbility = now;
  registerAbilityExecution('laserBeeAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const tileSize = 24;
  const gap = 4;
  const cellSize = tileSize + gap;
  
  // Create a laser for each equipped Laser Bee
  for(let beeIdx = 0; beeIdx < laserBeeCount; beeIdx++){
    // Seleccionar direcci√≥n aleatoria para este laser
    const isVertical = Math.random() < 0.5;
    let laserTiles = [];
    let lineIdx;
    
    if(isVertical){
      // Vertical laser: usa fila 7 como referencia, selecciona columna aleatoria
      lineIdx = Math.floor(Math.random() * GRID_W);
      for(let y = 0; y < GRID_H; y++){
        const idx = y * GRID_W + lineIdx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx, isCritical: false, isSuperCritical: false});
        }
      }
    } else {
      // Horizontal laser: usa columna 7 como referencia, selecciona fila aleatoria
      lineIdx = Math.floor(Math.random() * GRID_H);
      for(let x = 0; x < GRID_W; x++){
        const idx = lineIdx * GRID_W + x;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx, isCritical: false, isSuperCritical: false});
        }
      }
    }
    
    // Store laser line
    const laserId = 'laser_' + Math.random();
    activeLaserLines[laserId] = {
      direction: isVertical ? 'vertical' : 'horizontal',
      lineIdx: lineIdx,
      tiles: laserTiles,
      startTime: now,
      destroyed: []
    };

    
    // Mostrar laser visualmente
    const gridEl = document.getElementById("grid");
    const laserEl = document.createElement('div');
    laserEl.id = laserId;
    laserEl.style.position = 'absolute';
    laserEl.style.pointerEvents = 'none';
    laserEl.style.zIndex = '100';
    
    // Calcular posici√≥n exacta centrada en las tiles
    const gridPadding = 6;
    const startPos = gridPadding;
    
    // Posicionar laser seg√∫n direcci√≥n
    if(isVertical){
      // Vertical laser - ajustado para centrar mejor en tiles
      laserEl.style.left = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.top = startPos + 'px';
      laserEl.style.width = '4px';
      laserEl.style.height = (GRID_H * cellSize) + 'px';
      laserEl.style.background = 'linear-gradient(180deg, rgba(255,0,0,0.9), rgba(255,69,0,0.9), rgba(255,0,0,0.9))';
    } else {
      // Horizontal laser - ajustado para centrar mejor en tiles
      laserEl.style.left = startPos + 'px';
      laserEl.style.top = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.width = (GRID_W * cellSize) + 'px';
      laserEl.style.height = '4px';
      laserEl.style.background = 'linear-gradient(90deg, rgba(255,0,0,0.9), rgba(255,69,0,0.9), rgba(255,0,0,0.9))';
    }
  
    laserEl.style.boxShadow = '0 0 20px rgba(255,0,0,0.9), 0 0 10px rgba(255,69,0,0.6)';
    laserEl.style.borderRadius = '2px';
    laserEl.style.animation = 'pulse 0.5s ease-in-out infinite';
    
    gridEl.appendChild(laserEl);
    
    // Destroy tiles after 1 second
    setTimeout(() => {
      laserTiles.forEach(tileInfo => {
        const idx = tileInfo.idx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          // Calculate pollen (x2 for laser bonus)
          const pollenRange = flowerTypes[tile.ty].pollen;
          const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          
          // Check for critical hits
          const totalCritChance = stats.criticalChance + stats.beeCriticalChance;
          let isCritical = Math.random() * 100 < totalCritChance;
          let isSuperCritical = false;
          
          if(isCritical && Math.random() * 100 < stats.superCriticalChance){
            isSuperCritical = true;
            isCritical = false;
          }
          
          const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
          const critMultiplier = isSuperCritical ? 10 : (isCritical ? totalCritPower : 1);
          const finalPollenValue = pollenValue * critMultiplier;
          
          let gain = finalPollenValue * 2; // x2 pollen from laser
          
          // Check if this tile has Goo
          let hasGoo = false;
          if(gooTiles[idx]){
            const gooMultiplier = 2.5 * 1.5; // x3.75 total
            gain *= gooMultiplier;
            hasGoo = true;
          }
          
          // Apply color multipliers (x2 for red pollen from Laser Bee)
          if(tile.c === 'red'){
            gain *= redPollenMultiplier * 2; // x2 red pollen bonus
            stats.redTotal += gain;
          } else if(tile.c === 'blue'){
            gain *= bluePollenMultiplier;
            stats.blueTotal += gain;
          } else if(tile.c === 'white'){
            gain *= whitePollenMultiplier;
            stats.whiteTotal += gain;
          } else if(tile.c === 'yellow'){
            gain *= yellowPollenMultiplier;
            stats.yellowTotal = (stats.yellowTotal || 0) + gain;
          } else if(tile.c === 'purple'){
            gain *= purplePollenMultiplier;
            stats.purpleTotal = (stats.purpleTotal || 0) + gain;
          }
          
          // 10% probability to apply fire effect to destroyed tile
          let appliedFire = false;
          if(Math.random() * 100 < 10){
            fireBeeTilesActive[idx] = {
              createdAt: Date.now(),
              durationMs: 10000,
              basePollenValue: pollenValue,
              tileColor: tile.c || ''
            };
            appliedFire = true;
            // Re-render tile to show fire effect
            const gridEl = document.getElementById("grid");
            const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tileEl){
              tileEl.classList.add("fire-effect");
            }
          }
          
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          // Show floating number (con efecto cr√≠tico si aplica)
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            const r = tileEl.getBoundingClientRect();
            floating(r.left + r.width / 2, r.top, gain, isCritical || isSuperCritical, hasGoo, false, true);
            
            // Only destroy tile visually if fire was NOT applied
            if(!appliedFire){
              tileEl.style.transition = "opacity 0.3s ease-out";
              tileEl.style.opacity = "0";
            }
          }
          
          // Clean goo if present
          if(hasGoo){
            delete gooTiles[idx];
            const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tileEl){
              tileEl.style.filter = 'none';
            }
          }
          
          // Only reset tile if fire was NOT applied
          if(!appliedFire){
            fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
            activeLaserLines[laserId].destroyed.push(idx);
          } else {
            // If fire was applied, tile will be destroyed when fire expires
            activeLaserLines[laserId].destroyed.push(idx);
          }
          
          // Apply regeneration timer (random 0.5s to 2.5s)
          const capturedIdx = idx;
          const capturedFieldKey = currentField;
          const regenerationTime = appliedFire ? 10500 : (500 + Math.random() * 2000); // Wait for fire to expire if applied
          const regenerationTimer = setTimeout(() => {
            if(fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]){
              // Clear fire effect if still active
              delete fireBeeTilesActive[capturedIdx];
              fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
              if(currentField === capturedFieldKey){
                const gridEl = document.getElementById("grid");
                const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
                if(tileEl){
                  renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
                  // Fade in animation
                  tileEl.style.transition = "opacity 0.8s ease-in";
                  tileEl.style.opacity = "0";
                  void tileEl.offsetWidth;
                  tileEl.style.opacity = "1";
                }
              }
              saveGame();
            }
          }, regenerationTime);
        }
      });
      
      // Fade out laser
      laserEl.style.transition = 'all 0.4s ease-out';
      laserEl.style.opacity = '0';
      laserEl.style.boxShadow = '0 0 40px rgba(255,0,0,0.5)';
      
      setTimeout(() => {
        laserEl.remove();
        delete activeLaserLines[laserId];
      }, 400);
    }, 1000);
  }
}

function teslaBeeAbility(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee4')) return;
  if(!currentField || !fieldData[currentField]) return;
  
  const now = Date.now();
  const minInterval = 30000; // 30 seconds
  const maxInterval = 120000; // 2 minutes
  const nextAbility = lastTeslaBeeAbility + minInterval + Math.random() * (maxInterval - minInterval);
  if(now < nextAbility) return;
  
  lastTeslaBeeAbility = now;
  registerAbilityExecution('teslaBeeAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const tileSize = 24;
  const gap = 4;
  const cellSize = tileSize + gap;
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Generate 5 lasers
  for(let laserIdx = 0; laserIdx < 5; laserIdx++){
    // Random direction
    const isVertical = Math.random() < 0.5;
    let laserTiles = [];
    let lineIdx;
    
    if(isVertical){
      // Vertical laser: columna aleatoria
      lineIdx = Math.floor(Math.random() * GRID_W);
      for(let y = 0; y < GRID_H; y++){
        const idx = y * GRID_W + lineIdx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx});
        }
      }
    } else {
      // Horizontal laser: fila aleatoria
      lineIdx = Math.floor(Math.random() * GRID_H);
      for(let x = 0; x < GRID_W; x++){
        const idx = lineIdx * GRID_W + x;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx});
        }
      }
    }
    
    // Create visual laser (blue/purple)
    const laserId = 'tesla_laser_' + Math.random();
    const laserEl = document.createElement('div');
    laserEl.id = laserId;
    laserEl.style.position = 'absolute';
    laserEl.style.pointerEvents = 'none';
    laserEl.style.zIndex = '100';
    
    const gridPadding = 6;
    const startPos = gridPadding;
    
    if(isVertical){
      laserEl.style.left = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.top = startPos + 'px';
      laserEl.style.width = '4px';
      laserEl.style.height = (GRID_H * cellSize) + 'px';
      laserEl.style.background = 'linear-gradient(180deg, rgba(65,105,225,0.9), rgba(75,0,130,0.9), rgba(65,105,225,0.9))';
    } else {
      laserEl.style.left = startPos + 'px';
      laserEl.style.top = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.width = (GRID_W * cellSize) + 'px';
      laserEl.style.height = '4px';
      laserEl.style.background = 'linear-gradient(90deg, rgba(65,105,225,0.9), rgba(75,0,130,0.9), rgba(65,105,225,0.9))';
    }
    
    laserEl.style.boxShadow = '0 0 20px rgba(65,105,225,0.9), 0 0 10px rgba(75,0,130,0.6)';
    laserEl.style.borderRadius = '2px';
    laserEl.style.animation = 'pulse 0.5s ease-in-out infinite';
    gridEl.appendChild(laserEl);
    
    // Destroy tiles after 0.5s
    setTimeout(() => {
      laserTiles.forEach(tileInfo => {
        const idx = tileInfo.idx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          // Remove any existing buff on this tile
          delete fireBeeTilesActive[idx];
          delete spicyTilesActive[idx];
          delete gooTiles[idx];
          
          // Calculate pollen
          const pollenRange = flowerTypes[tile.ty].pollen;
          const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          
          // Check for crits
          const totalCritChance = stats.criticalChance + stats.beeCriticalChance;
          let isCritical = Math.random() * 100 < totalCritChance;
          let isSuperCritical = false;
          if(isCritical && Math.random() * 100 < stats.superCriticalChance){
            isSuperCritical = true;
            isCritical = false;
          }
          
          const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
          const critMultiplier = isSuperCritical ? 10 : (isCritical ? totalCritPower : 1);
          const finalPollenValue = pollenValue * critMultiplier;
          let gain = finalPollenValue * 2; // x2 from tesla/laser
          
          // Apply color multipliers
          if(tile.c === 'red'){
            gain *= redPollenMultiplier;
            stats.redTotal += gain;
          } else if(tile.c === 'blue'){
            gain *= bluePollenMultiplier * 5; // x5 blue pollen for energy buff
            stats.blueTotal += gain;
          } else if(tile.c === 'white'){
            gain *= whitePollenMultiplier;
            stats.whiteTotal += gain;
          } else if(tile.c === 'yellow'){
            gain *= yellowPollenMultiplier;
            stats.yellowTotal = (stats.yellowTotal || 0) + gain;
          } else if(tile.c === 'purple'){
            gain *= purplePollenMultiplier;
            stats.purpleTotal = (stats.purpleTotal || 0) + gain;
          }
          
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          // 100% instant conversion from energy buff
          const honeyAmount = gain * 0.5;
          stats.honey += honeyAmount;
          stats.totalHoney += honeyAmount;
          
          // Show floating number
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            const r = tileEl.getBoundingClientRect();
            floating(r.left + r.width / 2, r.top, gain, isCritical || isSuperCritical, false, true);
            tileEl.style.transition = "opacity 0.3s ease-out";
            tileEl.style.opacity = "0";
          }
          
          // Apply energy buff to this tile AFTER destroying it
          energyTiles[idx] = {createdAt: Date.now(), fieldKey: currentField};
          
          // Reset tile to empty
          fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
          
          // Apply regeneration timer using tileRegenerationRange
          const capturedIdx = idx;
          const capturedFieldKey = currentField;
          const regenerationTime = tileRegenerationRange.min + Math.random() * (tileRegenerationRange.max - tileRegenerationRange.min);
          const regenerationTimer = setTimeout(() => {
            if(fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]){
              fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
              if(currentField === capturedFieldKey){
                const gridEl = document.getElementById("grid");
                const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
                if(tileEl){
  renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
  
  // Aplica el efecto visual de energy si la tile tiene energy
  if(energyTiles[capturedIdx]){
    tileEl.style.border = "2px solid #00FFFF";
    tileEl.style.boxShadow = "0 0 12px #00FFFF, inset 0 0 8px rgba(0,255,255,0.3)";
  }

  // Fade in animation
  tileEl.style.transition = "opacity 0.8s ease-in";
  tileEl.style.opacity = "0";
  void tileEl.offsetWidth;
  tileEl.style.opacity = "1";
}
              }
              saveGame();
            }
          }, regenerationTime);
        }
      });
      
      // Remove laser visual
      laserEl.style.transition = 'all 0.4s ease-out';
      laserEl.style.opacity = '0';
      setTimeout(() => {
        laserEl.remove();
      }, 400);
    }, 500);
  }
}

function ticketBeeAbility(){
  if(!equippedBees || !equippedBees.includes('bee18')) return;
  
  const now = Date.now();
  const abilityInterval = 60000; // 1 minute
  
  if(!ticketBeeAbilityTime) ticketBeeAbilityTime = 0;
  if(now - ticketBeeAbilityTime < abilityInterval) return;
  
  ticketBeeAbilityTime = now;
  
  // 5% chance to get +1 ticket
  if(Math.random() < 0.05){
    tickets += 1;
    showFloatingText(window.innerWidth / 2, 100, 'üé´ +1 Ticket', '#9370DB');
  }
}

function goldenBeeAbility(){
  if(!equippedBees || !equippedBees.includes('bee19')) return;
  
  const now = Date.now();
  const abilityInterval = 60000; // 1 minute
  
  if(!goldenBeeAbilityTime) goldenBeeAbilityTime = 0;
  if(now - goldenBeeAbilityTime < abilityInterval) return;
  
  goldenBeeAbilityTime = now;
  
  // 20% chance to get +2 tickets
  if(Math.random() < 0.20){
    tickets += 2;
    showFloatingText(window.innerWidth / 2, 100, 'üé´ +2 Tickets', '#FFD700');
  }
}

function thunderBeeTick(){
  if(!equippedBees || !equippedBees.includes('bee17')) return;
  if(!currentField || !fieldData[currentField]) return;
  
  const now = Date.now();
  const nextAbility = lastThunderBeeAbility + Math.random() * 52000 + 20000; // 20s-1.2min
  if(now < nextAbility) return;
  
  lastThunderBeeAbility = now;
  registerAbilityExecution('thunderBeeAbility');
  
  // Generate 1-5 energy tiles randomly
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const tileCount = Math.floor(Math.random() * 5) + 1; // 1-5 tiles
  
  const selectedTiles = [];
  for(let i = 0; i < tileCount; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    if(!selectedTiles.includes(idx) && fieldData[currentField][idx] && fieldData[currentField][idx].ty > 0){
      selectedTiles.push(idx);
    }
  }
  
  selectedTiles.forEach(randomIdx => {
    // Remove any existing buff
    delete fireBeeTilesActive[randomIdx];
    delete spicyTilesActive[randomIdx];
    delete gooTiles[randomIdx];
    
    // Apply energy buff
    energyTiles[randomIdx] = {createdAt: Date.now(), fieldKey: currentField};
    
    // Visual update
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${randomIdx}"]`);
    if(tileEl){
      tileEl.classList.add("energy-effect");
    }
    
    console.log('‚ö° Thunder Bee created energy tile at index', randomIdx);
  });
}

function updateEnergyTiles(){
  // Remove expired energy buffs (after 10 seconds)
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  // Limpiar visualmente todas las tiles que ya no tengan energy
  if(gridEl) {
    for(let i=0; i<225; i++) {
      if(!energyTiles[i]) {
        const tileEl = gridEl.querySelector(`[data-idx="${i}"]`);
        if(tileEl) {
          // Solo limpiar si ten√≠a estilo de energy
          if(tileEl.style.borderImage || tileEl.style.boxShadow?.includes('225')) {
            tileEl.style.border = 'none';
            tileEl.style.borderImage = 'none';
            tileEl.style.boxShadow = 'none';
          }
        }
      }
    }
  }
  Object.keys(energyTiles).forEach(idxStr => {
    const idx = parseInt(idxStr);
    if(now - energyTiles[idx].createdAt > 10000){
      if(gridEl){
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.style.border = 'none';
          tileEl.style.borderImage = 'none';
          tileEl.style.boxShadow = 'none';
        }
      }
      delete energyTiles[idx];
    }
  });
}


function updateGooColors(){
  // Actualizar color del Goo en tiempo real con animaci√≥n fluida
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  Object.keys(gooTiles).forEach(idxStr => {
    const idx = parseInt(idxStr);
    if(!gooTiles[idx]) return;
    
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if(!tileEl) return;
    
    // Interpolaci√≥n suave entre colores
    const cycleProgress = (gooColorCycle % (gooColorList.length * 100)) / (gooColorList.length * 100);
    const colorSegments = gooColorList.length;
    const currentSegment = Math.floor(cycleProgress * colorSegments);
    const nextSegment = (currentSegment + 1) % colorSegments;
    const segmentProgress = (cycleProgress * colorSegments) % 1;
    
    const color1 = gooColorList[currentSegment];
    const color2 = gooColorList[nextSegment];
    const blendedColor = blendColors(color1, color2, segmentProgress);
    
    gooTiles[idx].gooColor = blendedColor;
    tileEl.style.filter = `drop-shadow(0 0 12px ${blendedColor})`;
  });
}

function blendColors(color1, color2, progress) {
  // Convertir colores hex a RGB
  const hex2rgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
  };
  
  const rgb2hex = (r, g, b) => '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');
  
  const [r1, g1, b1] = hex2rgb(color1);
  const [r2, g2, b2] = hex2rgb(color2);
  
  const r = r1 + (r2 - r1) * progress;
  const g = g1 + (g2 - g1) * progress;
  const b = b1 + (b2 - b1) * progress;
  
  return rgb2hex(r, g, b);
}

function startGummyBeeSystem(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee3')) return;
  
  // Initialize timing on first call
  if(lastGooGeneration === 0){
    lastGooGeneration = Date.now();
  }
}

function gummyBeeTick(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee3')) return;
  if(!currentField) return;
  
  const now = Date.now();
  const nextSpawn = lastGooGeneration + Math.random() * 20000 + 20000; // 20s - 40s minimum
  if(now < nextSpawn) return;
  
  lastGooGeneration = now;
  registerAbilityExecution('gooAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const gooCount = Math.floor(Math.random() * 5) + 1; // 1-5 goos por ciclo
  
  for(let i = 0; i < gooCount; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    // No generar Goo si ya hay en esta casilla
    if(gooTiles[idx]) continue;
    
    // Remove any existing buff (only 1 buff per tile)
    delete fireBeeTilesActive[idx];
    delete spicyTilesActive[idx];
    delete energyTiles[idx];
    
    const color = gooColorList[Math.floor(Math.random() * gooColorList.length)];
    gooTiles[idx] = {gooColor: color, createdAt: Date.now(), active: true, fieldKey: currentField};
    
    // Visual indicator with gradient border using all goo colors
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if(tileEl){
      tileEl.classList.add("goo-effect");
    }
    
    // Desaparecer despu√©s de 15-30s
    const duration = Math.random() * 15000 + 15000; // 15-30s
    setTimeout(()=>{
      if(gooTiles[idx]){
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("goo-effect");
        }
        delete gooTiles[idx];
      }
    }, duration);
  }
}

// Tile Upgrade System - Goo Tile Generation
function gooTileSystemTick(){
  if(maxGooTiles <= 0) return;
  if(!currentField) return;
  
  const now = Date.now();
  const minInterval = 30000; // 30 seconds
  const maxInterval = 60000; // 1 minute
  const nextSpawn = lastGooTileGeneration + minInterval + Math.random() * (maxInterval - minInterval);
  if(now < nextSpawn) return;
  
  lastGooTileGeneration = now;
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Limit the number of active goo tiles from upgrade
  if(activeGooTileIndices.length >= maxGooTiles) return;
  
  // Generate 1 goo tile
  let idx;
  let attempts = 0;
  do {
    idx = Math.floor(Math.random() * totalTiles);
    attempts++;
  } while((gooTiles[idx] || fireBeeTilesActive[idx] || spicyTilesActive[idx] || activeGooTileIndices.includes(idx)) && attempts < 10);
  
  if(attempts >= 10) return; // Couldn't find a valid tile
  
  // Add to our tracking
  activeGooTileIndices.push(idx);
  
  // Remove any existing buff (only 1 buff per tile)
  delete fireBeeTilesActive[idx];
  delete spicyTilesActive[idx];
  delete energyTiles[idx];
  
  const color = gooColorList[Math.floor(Math.random() * gooColorList.length)];
  gooTiles[idx] = {gooColor: color, createdAt: Date.now(), active: true, fieldKey: currentField};
  
  // Visual indicator
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
  if(tileEl){
    tileEl.classList.add("goo-effect");
  }
  
  // Desaparecer despu√©s de 20s
  const duration = 20000; // 20 seconds
  setTimeout(()=>{
    if(gooTiles[idx]){
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("goo-effect");
      }
      delete gooTiles[idx];
    }
    // Remove from tracking
    const index = activeGooTileIndices.indexOf(idx);
    if(index > -1){
      activeGooTileIndices.splice(index, 1);
    }
  }, duration);
}

function stopSpecialBeeAbilities(){
  // Parar Fire Bee
  lastFireBeeAbility = 0;
  fireBeeTilesActive = {};
  
  // Parar Spicy Bee
  lastSpicyAbility = 0;
  spicyTilesActive = {};
  
  // Parar Gummy Bee
  gooTiles = {};
  lastGooGeneration = 0;
  gooDestroyedCount = 0;
  
  // Parar Goo Tile System (upgrade)
  lastGooTileGeneration = 0;
  activeGooTileIndices = [];
  
  // Parar Demon Bee
  lastDemonAbility = 0;
  demonTilesActive = {};
  
  // Parar Laser Bee
  lastLaserAbility = 0;
  activeLaserLines = {};
  const gridEl = document.getElementById("grid");
  if(gridEl){
    Object.keys(activeLaserLines).forEach(laserId => {
      const laserEl = gridEl.querySelector('#' + laserId);
      if(laserEl) laserEl.remove();
    });
  }
}

/* ================= LION BEE ABILITY ================= */
function lionBeeAbility(){
  const now = Date.now();
  const cooldown = 30000; // 30 seconds between activations
  
  if(now - lastLionAbility < cooldown) return;
  
  const lionBeeCount = (equippedBees || []).filter(id => id === 'bee20').length;
  if(lionBeeCount === 0) return;
  
  lastLionAbility = now;
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Destroy 3 random tiles
  for(let i = 0; i < 3; i++){
    const randomIdx = Math.floor(Math.random() * totalTiles);
    const tile = fieldData[currentField]?.[randomIdx];
    
    if(!tile || tile.ty === 0) continue; // Skip empty tiles
    
    // Get tile element
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl?.querySelector(`[data-idx="${randomIdx}"]`);
    if(!tileEl) continue;
    
    // Get pollen value
    const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
    let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
    pollenValue *= 2; // +100% pollen bonus
    
    // Guaranteed critical
    let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
    
    // Add to stats
    stats.pollen += gain;
    stats.totalHoney = (stats.totalHoney || 0) + 0;
    pollenThisSec += gain;
    
    const r = tileEl.getBoundingClientRect();
    floating(r.left + r.width / 2, r.top, gain, true, false); // true = guaranteed crit
    
    // Destroy tile
    fieldData[currentField][randomIdx] = {c: "", ty: 0, transparent: true};
    renderTile(tileEl, fieldData[currentField][randomIdx]);
    tileEl.style.transition = "opacity 0.3s";
    tileEl.style.opacity = "0";
    
    // Regenerate
    setTimeout(() => {
      fieldData[currentField][randomIdx] = createTile(currentField);
      renderTile(tileEl, fieldData[currentField][randomIdx]);
      tileEl.style.opacity = "1";
    }, 1500);
  }
}

/* ================= PHOTON BEE ABILITY ================= */
function photonBeeAbility(){
  const now = Date.now();
  const minCooldown = 60000; // 1 minute
  const maxCooldown = 120000; // 2 minutes
  const cooldown = minCooldown + Math.random() * (maxCooldown - minCooldown);
  
  if(now - lastPhotonAbility < cooldown) return;
  
  const hasPhotonBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee5');
  if(!hasPhotonBee) return;
  
  lastPhotonAbility = now;
  registerAbilityExecution('photonAbility');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const gridEl = document.getElementById("grid");
  
  // Mark 20 random tiles for destruction with golden laser effect
  const tilesToDestroy = [];
  const selectedIndices = new Set();
  
  while(tilesToDestroy.length < 20){
    const idx = Math.floor(Math.random() * totalTiles);
    if(!selectedIndices.has(idx)){
      selectedIndices.add(idx);
      const tile = fieldData[currentField]?.[idx];
      if(tile && tile.ty > 0){
        tilesToDestroy.push(idx);
      }
    }
  }
  
  // Add visual effects to tiles
  tilesToDestroy.forEach(idx => {
    const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
    if(tileEl){
      tileEl.classList.add("photon-marked");
      tileEl.style.borderRadius = "0px";
      tileEl.style.boxShadow = "0 0 12px #FFD700, inset 0 0 8px #FFD700";
      tileEl.style.animation = "photonGlow 0.6s ease-in-out infinite";
    }
    
    // Create laser beam effect
    const laser = document.createElement('div');
    laser.style.position = 'fixed';
    const rect = tileEl.getBoundingClientRect();
    laser.style.left = rect.left + 'px';
    laser.style.top = (rect.top - 80) + 'px';
    laser.style.width = rect.width + 'px';
    laser.style.height = '100px';
    laser.style.background = 'linear-gradient(180deg, rgba(255,215,0,0.8), rgba(255,215,0,0))';
    laser.style.pointerEvents = 'none';
    laser.style.zIndex = '9998';
    laser.style.opacity = '0';
    laser.style.transition = 'opacity 0.3s';
    laser.style.boxShadow = '0 0 20px #FFD700';
    laser.id = 'photon-laser-' + idx;
    document.body.appendChild(laser);
    
    // Fade in laser
    setTimeout(() => {
      laser.style.opacity = '0.7';
    }, 50);
  });
  
  // Destroy tiles with random delays between 0.5s-1s
  tilesToDestroy.forEach((idx, order) => {
    const delay = 500 + Math.random() * 500;
    setTimeout(() => {
      const tile = fieldData[currentField]?.[idx];
      if(!tile) return;
      
      const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
      if(!tileEl) return;
      
      // Get pollen value
      const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
      let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
      
      // x3 pollen, x5 for yellow
      let multiplier = 3;
      if(tile.c === 'yellow') multiplier = 5;
      pollenValue *= multiplier;
      
      let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
      
      // Respetar capacidad del jugador
      const currentCapacity = calculateCapacity();
      const added = Math.min(currentCapacity - stats.pollen, gain);
      stats.pollen += added;
      pollenThisSec += added;
      
      // 100% instant conversion for Photon Bee
      const honeyAmount = added * 0.5;
      stats.honey += honeyAmount;
      stats.totalHoney += honeyAmount;
      
      const r = tileEl.getBoundingClientRect();
      floating(r.left + r.width / 2, r.top, added, false, false, false, false, true); // isPhoton = true
      
      // Remove laser
      const laser = document.getElementById('photon-laser-' + idx);
      if(laser){
        laser.style.opacity = '0';
        setTimeout(() => laser.remove(), 300);
      }
      
      // Destroy tile
      fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
      renderTile(tileEl, fieldData[currentField][idx]);
      tileEl.style.animation = 'none';
      tileEl.style.boxShadow = 'none';
      tileEl.classList.remove("photon-marked");
      tileEl.style.transition = "opacity 0.2s";
      tileEl.style.opacity = "0";
      
      // Regenerate
      setTimeout(() => {
        fieldData[currentField][idx] = createTile(currentField);
        renderTile(tileEl, fieldData[currentField][idx]);
        tileEl.style.opacity = "1";
      }, 1000);
    }, delay * order);
  });
}

function digitalBeeAbility(){
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Check for random effects every 30s
  const randomEffectCooldown = 30000;
  if(now - lastDigitalRandomEffect >= randomEffectCooldown){
    lastDigitalRandomEffect = now;
    registerAbilityExecution('digitalRandomEffect');
    
    // Generate random effect on 5 tiles
    const effectTypes = ['fire', 'darkfire', 'energy', 'goo'];
    const selectedEffect = effectTypes[Math.floor(Math.random() * effectTypes.length)];
    
    const selectedIndices = new Set();
    while(selectedIndices.size < 5){
      const idx = Math.floor(Math.random() * totalTiles);
      const tile = fieldData[currentField]?.[idx];
      if(!selectedIndices.has(idx) && tile && tile.ty > 0){
        selectedIndices.add(idx);
        
        // Apply the selected effect
        switch(selectedEffect){
          case 'fire':
            fireBeeTilesActive[idx] = { createdAt: Date.now(), durationMs: 10000, basePollenValue: 10, tileColor: 'red' };
            break;
          case 'darkfire':
            spicyTilesActive[idx] = { createdAt: Date.now(), durationMs: 10000 };
            break;
          case 'energy':
            energyTiles[idx] = { createdAt: Date.now(), fieldKey: currentField };
            // Clean up energy tile after 10s
            setTimeout(() => {
              delete energyTiles[idx];
            }, 10000);
            break;
          case 'goo':
            gooTiles[idx] = { gooColor: gooColorList[Math.floor(Math.random() * gooColorList.length)], createdAt: Date.now(), active: true };
            // Clean up goo tile after 15s
            setTimeout(() => {
              delete gooTiles[idx];
            }, 15000);
            break;
        }
      }
    }
  }
  
  // Check for glitch effect every 60-120s
  const glitchMinCooldown = 60000;
  const glitchMaxCooldown = 120000;
  const glitchCooldown = glitchMinCooldown + Math.random() * (glitchMaxCooldown - glitchMinCooldown);
  
  if(now - lastDigitalGlitch >= glitchCooldown){
    lastDigitalGlitch = now;
    registerAbilityExecution('digitalGlitch');
    
    // Apply glitch to 2-4 random tiles
    const glitchCount = 2 + Math.floor(Math.random() * 3);
    const selectedIndices = new Set();
    
    while(selectedIndices.size < glitchCount){
      const idx = Math.floor(Math.random() * totalTiles);
      const tile = fieldData[currentField]?.[idx];
      if(!selectedIndices.has(idx) && tile && tile.ty > 0){
        selectedIndices.add(idx);
        
        // Apply glitch effect
        glitchedTiles[idx] = { createdAt: now, durationMs: 5000 };
        const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
        
        if(tileEl){
          // Create gradient border animation
          const glitchStyles = `
            <style id="glitch-style-${idx}">
              @keyframes glitchBorder-${idx} {
                0% { border-color: #FF0000; box-shadow: 0 0 15px #FF0000; }
                33% { border-color: #00FF00; box-shadow: 0 0 15px #00FF00; }
                66% { border-color: #000000; box-shadow: 0 0 15px #000000; }
                100% { border-color: #FF0000; box-shadow: 0 0 15px #FF0000; }
              }
            </style>
          `;
          if(!document.getElementById(`glitch-style-${idx}`)){
            document.body.insertAdjacentHTML('beforeend', glitchStyles);
          }
          
          tileEl.style.borderWidth = '3px';
          tileEl.style.animation = `glitchBorder-${idx} 0.4s linear infinite`;
          tileEl.classList.add('glitch-tile');
          
          // Create floating squares
          for(let i = 0; i < 8; i++){
            const square = document.createElement('div');
            square.style.position = 'fixed';
            const rect = tileEl.getBoundingClientRect();
            square.style.left = (rect.left + Math.random() * rect.width) + 'px';
            square.style.top = (rect.top - 30 - Math.random() * 30) + 'px';
            square.style.width = '8px';
            square.style.height = '8px';
            const colors = ['#FF0000', '#00FF00', '#000000'];
            square.style.background = colors[Math.floor(Math.random() * colors.length)];
            square.style.pointerEvents = 'none';
            square.style.zIndex = '9999';
            square.style.boxShadow = `0 0 8px ${square.style.background}`;
            square.style.animation = 'float 0.3s ease-out forwards';
            document.body.appendChild(square);
            
            setTimeout(() => square.remove(), 200);
          }
        }
        
        // Destroy the tile after 5 seconds and award pollen
        setTimeout(() => {
          const tile = fieldData[currentField]?.[idx];
          if(!tile) return;
          
          const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
          if(!tileEl) return;
          
          // Get pollen value with +3000% multiplier
          const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
          let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          pollenValue *= 30; // +3000% = x30
          
          let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
          
          // Respetar capacidad
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          const r = tileEl.getBoundingClientRect();
          floating(r.left + r.width / 2, r.top, added, false, false, false, false, true); // Amarillo neon glow
          
          // Destroy tile
          fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
          renderTile(tileEl, fieldData[currentField][idx]);
          tileEl.style.animation = 'none';
          tileEl.style.boxShadow = 'none';
          tileEl.style.borderWidth = '1px';
          tileEl.classList.remove("glitch-tile");
          const glitchStyle = document.getElementById(`glitch-style-${idx}`);
          if(glitchStyle) glitchStyle.remove();
          tileEl.style.transition = "opacity 0.2s";
          tileEl.style.opacity = "0";
          
          // Regenerate
          setTimeout(() => {
            fieldData[currentField][idx] = createTile(currentField);
            renderTile(tileEl, fieldData[currentField][idx]);
            tileEl.style.opacity = "1";
          }, 1000);
          
          delete glitchedTiles[idx];
        }, 5000);
      }
    }
  }
}

function moonBeeAbility(){
  const now = Date.now();
  const cooldown = 60000; // 1 minute
  
  if(now - lastMoonLaser < cooldown) return;
  
  const hasMoonBee = equippedBees && equippedBees.includes('bee23');
  if(!hasMoonBee) return;
  
  lastMoonLaser = now;
  registerAbilityExecution('moonBeeAbility');
  
  if(!currentField || !fieldData[currentField]) return;
  
  const GRID_W = 15;
  const GRID_H = 15;
  const tileSize = 24;
  const gap = 4;
  const cellSize = tileSize + gap;
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Random direction (horizontal or vertical)
  const isVertical = Math.random() > 0.5;
  let lineIdx;
  const laserTiles = [];
  
  if(isVertical){
    // Vertical laser down a random column
    lineIdx = Math.floor(Math.random() * GRID_W);
    for(let y = 0; y < GRID_H; y++){
      const idx = y * GRID_W + lineIdx;
      const tile = fieldData[currentField][idx];
      if(tile && tile.ty > 0){
        laserTiles.push({idx: idx, isCritical: false, isSuperCritical: false});
      }
    }
  } else {
    // Horizontal laser across a random row
    lineIdx = Math.floor(Math.random() * GRID_H);
    for(let x = 0; x < GRID_W; x++){
      const idx = lineIdx * GRID_W + x;
      const tile = fieldData[currentField][idx];
      if(tile && tile.ty > 0){
        laserTiles.push({idx: idx, isCritical: false, isSuperCritical: false});
      }
    }
  }
  
  // Store laser line
  const laserId = 'moon_laser_' + Math.random();
  activeLaserLines[laserId] = {
    direction: isVertical ? 'vertical' : 'horizontal',
    lineIdx: lineIdx,
    tiles: laserTiles,
    startTime: now,
    destroyed: []
  };
  
  // Mostrar laser visualmente (purple/blue color for Moon Bee)
  const laserEl = document.createElement('div');
  laserEl.id = laserId;
  laserEl.style.position = 'absolute';
  laserEl.style.pointerEvents = 'none';
  laserEl.style.zIndex = '100';
  
  // Calcular posici√≥n exacta centrada en las tiles
  const gridPadding = 6;
  const startPos = gridPadding;
  
  // Posicionar laser seg√∫n direcci√≥n
  if(isVertical){
    // Vertical laser - ajustado para centrar mejor en tiles
    laserEl.style.left = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
    laserEl.style.top = startPos + 'px';
    laserEl.style.width = '4px';
    laserEl.style.height = (GRID_H * cellSize) + 'px';
    laserEl.style.background = 'linear-gradient(180deg, rgba(78,0,130,0.9), rgba(75,0,130,0.9), rgba(138,43,226,0.9))';
  } else {
    // Horizontal laser - ajustado para centrar mejor en tiles
    laserEl.style.left = startPos + 'px';
    laserEl.style.top = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
    laserEl.style.width = (GRID_W * cellSize) + 'px';
    laserEl.style.height = '4px';
    laserEl.style.background = 'linear-gradient(90deg, rgba(78,0,130,0.9), rgba(75,0,130,0.9), rgba(138,43,226,0.9))';
  }
  
  laserEl.style.boxShadow = '0 0 20px rgba(138,43,226,0.9), 0 0 10px rgba(75,0,130,0.6)';
  laserEl.style.borderRadius = '2px';
  laserEl.style.animation = 'pulse 0.5s ease-in-out infinite';
  
  gridEl.appendChild(laserEl);
  
  // Destroy tiles after 1 second and apply energy buff
  setTimeout(() => {
    laserTiles.forEach(tileInfo => {
      const idx = tileInfo.idx;
      const tile = fieldData[currentField][idx];
      if(tile && tile.ty > 0){
        // Calculate pollen for energy tiles
        const pollenRange = flowerTypes[tile.ty].pollen;
        const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
        
        // Energy tiles give x5 blue / x2 other colors, 100% instant conversion
        let gain = pollenValue * 2; // base x2
        
        if(tile.c === 'blue'){
          gain *= bluePollenMultiplier * 5;
          stats.blueTotal += gain;
        } else if(tile.c === 'red'){
          gain *= redPollenMultiplier;
          stats.redTotal += gain;
        } else if(tile.c === 'white'){
          gain *= whitePollenMultiplier;
          stats.whiteTotal += gain;
        } else if(tile.c === 'yellow'){
          gain *= yellowPollenMultiplier;
          stats.yellowTotal = (stats.yellowTotal || 0) + gain;
        } else if(tile.c === 'purple'){
          gain *= purplePollenMultiplier;
          stats.purpleTotal = (stats.purpleTotal || 0) + gain;
        }
        
        // Apply energy tile bonus
        energyTiles[idx] = { createdAt: Date.now(), fieldKey: currentField };
        
        // 20% chance to apply dark fire
        let appliedDarkFire = false;
        if(Math.random() * 100 < 20){
          spicyTilesActive[idx] = {
            createdAt: Date.now(),
            durationMs: 10000,
            basePollenValue: pollenValue,
            tileColor: tile.c || ''
          };
          appliedDarkFire = true;
          // Re-render tile to show dark fire effect
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            tileEl.classList.add("dark-fire-effect");
          }
        }
        
        const currentCapacity = calculateCapacity();
        const added = Math.min(currentCapacity - stats.pollen, gain);
        stats.pollen += added;
        stats.honey += added * 0.5; // 100% instant conversion for energy tiles
        stats.totalHoney += added * 0.5;
        pollenThisSec += added;
        
        // Show floating number
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          const r = tileEl.getBoundingClientRect();
          floating(r.left + r.width / 2, r.top, gain, false, false, false, false);
          
          // Destroy tile visually
          tileEl.style.transition = "opacity 0.3s ease-out";
          tileEl.style.opacity = "0";
        }
        
        // Reset tile
        fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
        activeLaserLines[laserId].destroyed.push(idx);
        
        // Regenerate tile after 0.5-2.5s (or longer if dark fire was applied)
        const capturedIdx = idx;
        const capturedFieldKey = currentField;
        const regenerationTime = appliedDarkFire ? 10500 : (500 + Math.random() * 2000);
        const regenerationTimer = setTimeout(() => {
          if(fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]){
            // Clean energy and dark fire effects
            delete energyTiles[capturedIdx];
            delete spicyTilesActive[capturedIdx];
            fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
            if(currentField === capturedFieldKey){
              const gridEl = document.getElementById("grid");
              const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
              if(tileEl){
                renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
                // Fade in animation
                tileEl.style.transition = "opacity 0.8s ease-in";
                tileEl.style.opacity = "0";
                void tileEl.offsetWidth;
                tileEl.style.opacity = "1";
              }
            }
            saveGame();
          }
        }, regenerationTime);
      }
    });
    
    // Fade out laser
    laserEl.style.transition = 'all 0.4s ease-out';
    laserEl.style.opacity = '0';
    laserEl.style.boxShadow = '0 0 40px rgba(138,43,226,0.5)';
    
    setTimeout(() => {
      laserEl.remove();
      delete activeLaserLines[laserId];
    }, 400);
  }, 1000);
}

function lionBeeAutoDestruct(){
  const now = Date.now();
  const minCooldown = 30000; // 30s
  const maxCooldown = 60000; // 1min
  const nextAbility = lastLionDestruction + minCooldown + Math.random() * (maxCooldown - minCooldown);
  
  if(now < nextAbility) return;
  
  const hasLionBee = equippedBees && equippedBees.includes('bee20');
  if(!hasLionBee) return;
  
  if(!currentField || !fieldData[currentField]) return;
  
  lastLionDestruction = now;
  registerAbilityExecution('lionBeeAutoDestruct');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Destroy 3 random tiles with +100% pollen and guaranteed crit
  const tilesToDestroy = [];
  let attempts = 0;
  while(tilesToDestroy.length < 3 && attempts < 20){
    const idx = Math.floor(Math.random() * totalTiles);
    const tile = fieldData[currentField][idx];
    if(tile && tile.ty > 0 && !tilesToDestroy.includes(idx)){
      tilesToDestroy.push(idx);
    }
    attempts++;
  }
  
  // Destroy each tile with staggered timing
  tilesToDestroy.forEach((idx, order) => {
    setTimeout(() => {
      const tile = fieldData[currentField][idx];
      if(!tile) return;
      
      const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
      if(!tileEl) return;
      
      // Get pollen value
      const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
      const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
      
      // +100% pollen bonus from Lion Bee
      let gain = pollenValue * 2; // x2 from +100%
      
      // Apply color multipliers
      if(tile.c === 'red'){
        gain *= redPollenMultiplier;
        stats.redTotal += gain;
      } else if(tile.c === 'blue'){
        gain *= bluePollenMultiplier;
        stats.blueTotal += gain;
      } else if(tile.c === 'white'){
        gain *= whitePollenMultiplier;
        stats.whiteTotal += gain;
      } else if(tile.c === 'yellow'){
        gain *= yellowPollenMultiplier;
        stats.yellowTotal = (stats.yellowTotal || 0) + gain;
      } else if(tile.c === 'purple'){
        gain *= purplePollenMultiplier;
        stats.purpleTotal = (stats.purpleTotal || 0) + gain;
      }
      
      // Respeta capacidad
      const currentCapacity = calculateCapacity();
      const added = Math.min(currentCapacity - stats.pollen, gain);
      stats.pollen += added;
      pollenThisSec += added;
      
      // Guaranteed critical hit
      const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
      const finalGain = added * totalCritPower;
      
      const r = tileEl.getBoundingClientRect();
      floating(r.left + r.width / 2, r.top, finalGain, true, false, false, false); // true = is critical
      
      // Destroy tile visually
      tileEl.style.transition = "opacity 0.3s ease-out";
      tileEl.style.opacity = "0";
      
      // Reset tile
      fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
      
      // Regenerate tile after 0.5-2.5s
      const regenerationTime = 500 + Math.random() * 2000;
      const regenerationTimer = setTimeout(() => {
        if(fieldData[currentField] && fieldData[currentField][idx]){
          fieldData[currentField][idx] = createTile(currentField);
          if(currentField === currentField){
            const gridEl = document.getElementById("grid");
            const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tileEl){
              renderTile(tileEl, fieldData[currentField][idx]);
              // Fade in animation
              tileEl.style.transition = "opacity 0.8s ease-in";
              tileEl.style.opacity = "0";
              void tileEl.offsetWidth;
              tileEl.style.opacity = "1";
            }
          }
          saveGame();
        }
      }, regenerationTime);
    }, order * 100);
  });
}

function fourBeeAbility(){
  const now = Date.now();
  const cooldown = 5 * 60 * 1000; // 5 minutes
  
  if(now - lastFourFormation < cooldown) return;
  
  const hasFourBee = equippedBees && equippedBees.includes('bee25');
  if(!hasFourBee) return;
  
  lastFourFormation = now;
  registerAbilityExecution('fourFormation');
  
  const GRID_W = 15;
  const GRID_H = 15;
  const gridEl = document.getElementById("grid");
  
  // Find a random position to draw "4" shape
  // 4 shape is roughly:
  // X . .
  // X . .
  // X X X
  // . . X
  // . . X
  
  // Pick random top-left corner for the pattern
  let startRow, startCol;
  do {
    startRow = Math.floor(Math.random() * (GRID_H - 4));
    startCol = Math.floor(Math.random() * (GRID_W - 2));
  } while(startRow < 0 || startCol < 0);
  
  // Define the "4" pattern (relative positions)
  const fourPattern = [
    [0, 0], [1, 0], [2, 0], // Left vertical line
    [2, 1], [2, 2],         // Horizontal line
    [1, 2], [0, 2]          // Right vertical line (down)
  ];
  
  const tilesToDestroy = [];
  fourPattern.forEach(([row, col]) => {
    const idx = (startRow + row) * GRID_W + (startCol + col);
    const tile = fieldData[currentField]?.[idx];
    if(tile && tile.ty > 0){
      tilesToDestroy.push(idx);
    }
  });
  
  // Destroy the tiles with x1.4 pollen multiplier
  tilesToDestroy.forEach((idx, order) => {
    setTimeout(() => {
      const tile = fieldData[currentField]?.[idx];
      if(!tile) return;
      
      const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
      if(!tileEl) return;
      
      // Get pollen value with x1.4 multiplier
      const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
      let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
      pollenValue *= 1.4; // x1.4 multiplier
      
      let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
      
      // Respeta capacidad
      const currentCapacity = calculateCapacity();
      const added = Math.min(currentCapacity - stats.pollen, gain);
      stats.pollen += added;
      pollenThisSec += added;
      
      const r = tileEl.getBoundingClientRect();
      floating(r.left + r.width / 2, r.top, added, false, false, false, false);
      
      // Destroy tile
      fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
      renderTile(tileEl, fieldData[currentField][idx]);
      tileEl.style.transition = "opacity 0.2s";
      tileEl.style.opacity = "0";
      
      // Regenerate
      setTimeout(() => {
        fieldData[currentField][idx] = createTile(currentField);
        renderTile(tileEl, fieldData[currentField][idx]);
        tileEl.style.opacity = "1";
      }, 1000);
    }, order * 100);
  });
}

function buildBeeGrid(){
  const beeGridEl = document.getElementById("beeGrid");
  beeGridEl.innerHTML = "";
  
  // Mostrar special bees equipadas (hasta 3 slots especiales al inicio)
  for(let i = 0; i < 3; i++){
    if(i < equippedSpecialBees.length && equippedSpecialBees[i]){
      const specialBee = SPECIAL_BEES.find(b => b.id === equippedSpecialBees[i]);
      if(specialBee){
        const specialSlot = document.createElement("div");
        specialSlot.className = "bee-slot special-bee";
        specialSlot.style.background = `linear-gradient(90deg, rgba(76,175,80,0.4), ${specialBee.color}, rgba(76,175,80,0.4))`;
        specialSlot.style.border = "3px solid #4CAF50";
        specialSlot.innerHTML = `<img src="images/${specialBee.img}" style="width:100%;height:100%;object-fit:cover;"><div style="position:absolute;top:2px;left:2px;background:#4CAF50;color:#000;border-radius:0px;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;">${i+1}</div>`;
        specialSlot.title = specialBee.name + ' (SPECIAL)';
        specialSlot.style.cursor = "pointer";
        const slotIndex = i; // Capturar √≠ndice
        specialSlot.onmouseenter = (ev) => {
          const tt = document.createElement('div'); tt.className='bee-tooltip';
          tt.id = 'beeTooltip';
          tt.innerHTML = `<b>${specialBee.name}</b><div style="color:#4CAF50">SPECIAL (Slot ${slotIndex+1}/3)</div><div style="margin-top:6px;color:#ddd">${specialBee.desc || ''}</div><div style="margin-top:6px;color:#CFF1D6">Ability: ${specialBee.ability} ${specialBee.value}</div>`;
          document.body.appendChild(tt);
          try{ const bold = document.getElementById('beeTooltip').querySelector('b'); if(bold) bold.style.color = '#4CAF50'; }catch(e){}
          const move = (e)=>{ const el = document.getElementById('beeTooltip'); if(!el) return; el.style.left = (e.clientX + 12) + 'px'; el.style.top = (e.clientY + 12) + 'px'; };
          move(ev);
          specialSlot.addEventListener('mousemove', move);
          specialSlot._moveHandler = move;
        };
        specialSlot.onmouseleave = ()=>{ const el = document.getElementById('beeTooltip'); if(el) el.remove(); if(specialSlot._moveHandler) specialSlot.removeEventListener('mousemove', specialSlot._moveHandler); };
        specialSlot.onclick = () => {
          const tt = document.getElementById('beeTooltip'); if(tt) tt.remove();
          if(!confirm('Esta abeja es SPECIAL. ¬øSeguro que quieres borrarla de este slot?')) return;
          equippedSpecialBees.splice(slotIndex, 1);
          saveGame();
          buildBeeGrid();
          updateBeeAbilities();
          updateUI();
        };
        beeGridEl.appendChild(specialSlot);
      }
    }
  }
  
  for(let i = 0; i < 50; i++){
    const slot = document.createElement("div");
    slot.className = "bee-slot";
    slot.setAttribute("data-slot", i);
    
    if(i < maxSlots){
      // unlocked slot
      if(equippedBees[i]) {
        const bee = BEES.find(b => b.id === equippedBees[i]);
        if(bee) {
          slot.style.background = bee.color;
          slot.innerHTML = `<img src="images/${bee.img}" style="width:100%;height:100%;object-fit:cover;">`;
          slot.title = bee.name + ' (' + bee.rarity + ')';
          slot.style.cursor = "pointer";
          // add particle visual for legendary/mythic bees and mythic glow class
          if(bee.rarity === 'legendary' || bee.rarity === 'mythic'){
            try{ createParticles(slot, bee.rarity === 'mythic' ? '#9b59b6' : '#ffd166', 6); }catch(e){}
          }
          if(bee.rarity === 'mythic'){
            slot.classList.add('mythic-bee');
          }
          // tooltip on hover showing ability and stats
          slot.onmouseenter = (ev) => {
            const tt = document.createElement('div'); tt.className='bee-tooltip';
            tt.id = 'beeTooltip';
            const abilityLabel = bee.ability || 'N/A';
            const rarityColors = {common:'#FFD700',uncommon:'#00FF00',rare:'#00BFFF',epic:'#9370DB',legendary:'#FFD700',mythic:'#9b59b6',special:'#4CAF50'};
            const rarityColor = rarityColors[bee.rarity] || '#ccc';
            const rarityUpper = bee.rarity.toUpperCase();
            tt.innerHTML = `<b>${bee.name}</b><div style="color:${rarityColor}">${rarityUpper}</div><div style="margin-top:6px;color:#ddd">${bee.desc || ''}</div><div style="margin-top:6px;color:#CFF1D6">Ability: ${abilityLabel} ${bee.value}</div>`;
            document.body.appendChild(tt);
            // color the name according to bee color / rarity
            try{ const bold = document.getElementById('beeTooltip').querySelector('b'); if(bold) bold.style.color = bee.color || (bee.rarity === 'mythic' ? '#9b59b6' : '#f1c40f'); }catch(e){}
            const move = (e)=>{ const el = document.getElementById('beeTooltip'); if(!el) return; el.style.left = (e.clientX + 12) + 'px'; el.style.top = (e.clientY + 12) + 'px'; };
            move(ev);
            slot.addEventListener('mousemove', move);
            slot._moveHandler = move;
          };
          slot.onmouseleave = ()=>{ const el = document.getElementById('beeTooltip'); if(el) el.remove(); if(slot._moveHandler) slot.removeEventListener('mousemove', slot._moveHandler); };
          slot.onclick = () => {
            // ensure tooltip is removed when deleting
            const tt = document.getElementById('beeTooltip'); if(tt) tt.remove();
            // delete equipped bee permanently (with confirmation for mythic)
            if(bee.rarity === 'mythic'){
              if(!confirm('Esta abeja es Mythic. ¬øSeguro que quieres borrarla?')) return;
            }
            // remove from ownedBees (first occurrence) and from equipped
            const idxOwned = ownedBees.indexOf(bee.id);
            if(idxOwned >= 0) ownedBees.splice(idxOwned,1);
            equippedBees.splice(i,1);
            saveGame();
            buildBeeGrid();
            buildEggs();
            updateBeeAbilities();
            updateUI();
          };
        }
      }
    } else {
      // locked slot
      slot.style.opacity = '0.35';
      slot.title = 'Locked slot - purchasable in shop';
    }
    
    beeGridEl.appendChild(slot);
  }
}

/* ================= FIELD ================= */
function weightedPick(o){
let t=Object.values(o).reduce((a,b)=>a+b,0);
let r=Math.random()*t;
for(const k in o){r-=o[k];if(r<=0)return k;}
}
function createTile(f){
const F=fields[f];
const c=weightedPick(Object.fromEntries(Object.entries(F.colors).map(([k,v])=>[k,v.chance])));
const ty=Number(weightedPick(F.colors[c].flowers));
return{c,ty,transparent:false};
}
function buildFieldList(){
const fieldListEl = document.getElementById("fieldList");
fieldListEl.innerHTML="";
for(const k in fields){
  const req = fieldRequirements[k] || 0;
  const unlocked = (maxEquippedBeesEver >= req) || req === 0;

  const d = document.createElement("div");
  d.className = "field-item" + (k === currentField ? " active" : "") + (unlocked ? "" : " locked");

  const left = document.createElement("div");
  left.className = "left";
  const img = document.createElement("img");
  img.src = `images/field_${k}.png`;
  img.alt = fields[k].name;
  const name = document.createElement("div");
  name.className = "name";
  name.textContent = fields[k].name;
  left.appendChild(img);
  left.appendChild(name);

  const reqSpan = document.createElement("div");
  reqSpan.className = "req-bees";
  reqSpan.textContent = `Bees ${req}`;

  if(unlocked){
    d.onclick = () => {
      if(k === currentField) return;
      // update time for previous field
      try{
        const now = Date.now();
        const delta = Math.floor((now - lastFieldEnter)/1000);
        ensureFieldStats(currentField);
        fieldStats[currentField].timeSpentSeconds = (fieldStats[currentField].timeSpentSeconds||0) + delta;
        lastFieldEnter = now;
      }catch(e){}
      currentField = k; buildFieldList(); buildGrid(); saveGame();
    };
  } else {
    d.title = `Requiere ${req} bees para desbloquear`;
  }

  d.appendChild(left);
  d.appendChild(reqSpan);
  fieldListEl.appendChild(d);
}
}
function buildGrid(){
const gridEl = document.getElementById("grid");
gridEl.innerHTML="";
if(!fieldData[currentField]){
  const GRID_W = 15;
  const GRID_H = 15;
  fieldData[currentField]=Array.from({length:GRID_W*GRID_H},()=>createTile(currentField));
}
fieldData[currentField].forEach((d,i)=>{
const t=document.createElement("div");
t.className="tile";
t.setAttribute("data-idx", i);
renderTile(t,d);
// IMPORTANT: Don't rely on d parameter, always get fresh data from fieldData
t.onclick=()=>clickTile(t, fieldData[currentField][i], currentField, i);
gridEl.appendChild(t);
});
}
function renderTile(t,d){
t.innerHTML="";
t.classList.toggle("transparent", d.transparent || d.ty === 0);
// Remove all effect classes first
t.classList.remove("fire-effect", "dark-fire-effect", "goo-effect", "energy-effect");
if(d.transparent || d.ty === 0)return;
const img=document.createElement("img");
img.src=`images/flower_${d.c}_${d.ty}.png`;
t.appendChild(img);

// Check if this tile has fire or dark fire effects
const tileIdx = parseInt(t.getAttribute("data-idx"));
if(fireBeeTilesActive[tileIdx]){
  t.classList.add("fire-effect");
}
if(spicyTilesActive[tileIdx]){
  t.classList.add("dark-fire-effect");
}
if(gooTiles[tileIdx]){
  t.classList.add("goo-effect");
}
if(energyTiles[tileIdx]){
  t.classList.add("energy-effect");
}
}

/* ================= FLOATING ================= */
function calculateFloatingNumberMinimum(){
  // Calculate the minimum value for floating numbers based on player stats
  // Formula: Base pollen * multipliers from various sources
  
  const beePollencontent = stats.beePollenBonus / 100; // e.g., 0.15 for 15% bonus
  const toolBonus = TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0;
  
  // Total multiplier from all bonuses
  let totalMultiplier = 1 + (stats.pollenBonus + stats.beePollenBonus) / 100;
  totalMultiplier += toolBonus / 100;
  
  // Add color bonuses (average of active ones)
  const colorMultipliers = [redPollenMultiplier, bluePollenMultiplier, whitePollenMultiplier];
  const avgColorBonus = colorMultipliers.reduce((a, b) => a + b, 0) / colorMultipliers.length;
  totalMultiplier *= avgColorBonus;
  
  // Add critical hit potential (average chance weighted by power)
  const critChance = Math.min(100, stats.criticalChance + stats.beeCriticalChance) / 100;
  const critPower = stats.criticalPower + stats.beeCriticalPower;
  const critMultiplier = 1 + (critChance * (critPower - 1));
  totalMultiplier *= critMultiplier;
  
  // Base minimum: account for number of bees (more bees = more consistent drops)
  const beeFactor = Math.max(1, equippedBees.length / 10);
  
  // Final minimum threshold
  // Avoid showing numbers smaller than 1% of calculated potential
  const minThreshold = Math.floor(Math.max(1, totalMultiplier * beeFactor * 0.1));
  
  return Math.max(1, minThreshold);
}

function floating(x,y,val, isCritical = false, isGoo = false, isInstantConversion = false, isLaser = false, isPhoton = false){
const minValue = calculateFloatingNumberMinimum();

// Don't show numbers below minimum threshold (except for critical/goo/instant/laser/photon which always show)
if(!isCritical && !isGoo && !isInstantConversion && !isLaser && !isPhoton && val < minValue) return;

const f=document.createElement("div");
f.className="floating";
f.textContent="+"+fmt(val);
f.style.left=x+"px";
f.style.top=y+"px";

if(isLaser){
  // Estilo especial para n√∫meros del Laser - grande y con animaci√≥n rojo-amarillo
  f.style.fontSize="22px";
  f.style.fontWeight="bold";
  f.style.setProperty("--x",(Math.random()*40-20)+"px");
  f.style.setProperty("--r",(Math.random()*40-20)+"deg");
  f.style.animation="float 3s ease-out forwards";
  f.style.color = "#FF4500";
  f.style.textShadow = "0 0 10px #FF4500";
  
  // Animaci√≥n de color rojo a amarillo en bucle
  let colorPhase = 0;
  const colorInterval = setInterval(()=>{
    colorPhase += 0.05;
    // Interpolaci√≥n entre rojo (#FF0000) y amarillo (#FFFF00)
    const progress = (Math.sin(colorPhase) + 1) / 2; // 0 a 1
    const r = Math.floor(255);
    const g = Math.floor(0 + (255 * progress)); // 0 a 255
    const b = 0;
    const color = `rgb(${r},${g},${b})`;
    f.style.color = color;
    f.style.textShadow = `0 0 12px ${color}`;
  }, 30);
  
  setTimeout(()=>{ clearInterval(colorInterval); f.remove(); }, 3000);
}
else if(isGoo){
  // Estilo especial para n√∫meros de Goo
  const gooColors = ['#FF69B4', '#39FF14', '#9D4EDD'];
  let colorIndex = 0;
  f.style.fontSize="18px";
  f.style.fontWeight="bold";
  f.style.setProperty("--x",(Math.random()*50-25)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 4s ease-out forwards"; // M√°s tiempo
  f.style.textShadow="0 0 12px " + gooColors[0];
  
  // Cambiar color cada 400ms
  const colorInterval = setInterval(()=>{
    colorIndex = (colorIndex + 1) % gooColors.length;
    f.style.color = gooColors[colorIndex];
    f.style.textShadow = "0 0 12px " + gooColors[colorIndex];
  }, 400);
  
  setTimeout(()=>{ clearInterval(colorInterval); f.remove(); }, 4000);
  f.style.color = gooColors[0];
  f.style.animation="float 4s ease-out forwards";
}
else if(isCritical){
  f.style.color="#ff1493";
  f.style.fontSize="18px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 10px #ff1493";
  f.style.setProperty("--x",(Math.random()*60-30)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 2.5s ease-out forwards";
  
  // Part√≠culas cr√≠ticas
  for(let i=0; i<8; i++){
    const p=document.createElement("div");
    p.style.position="absolute";
    p.style.width="8px";
    p.style.height="8px";
    p.style.background="#ff1493";
    p.style.borderRadius="50%";
    p.style.left=x+"px";
    p.style.top=y+"px";
    p.style.pointerEvents="none";
    p.style.animation=`particle-burst 1s ease-out forwards`;
    p.style.setProperty("--px",(Math.random()*200-100)+"px");
    p.style.setProperty("--py",(Math.random()*200-100)+"px");
    document.body.appendChild(p);
    setTimeout(()=>p.remove(),1000);
  }
}
else if(isInstantConversion){
  // Estilo especial para n√∫meros de Instant Conversion (miel)
  f.textContent="&"+fmt(val);
  f.style.color="#FFD700";
  f.style.fontSize="16px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 8px #FFD700";
  f.style.setProperty("--x",(Math.random()*40-20)+"px");
  f.style.setProperty("--r",(Math.random()*30-15)+"deg");
  f.style.animation="float 3s ease-out forwards";
}
else if(isPhoton){
  // Estilo especial para n√∫meros de Photon Bee - amarillo neon con glow intenso
  f.style.color="#FFFF00";
  f.style.fontSize="20px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 15px #FFFF00, 0 0 25px #FFD700, 0 0 35px #FF8C00";
  f.style.setProperty("--x",(Math.random()*50-25)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 3s ease-out forwards";
}

  // non-critical float styling depending on value with compact notation
  else if(val<1000){
    f.textContent="+"+Math.floor(val);
    f.style.color="#f1c40f";
    f.style.fontSize="11px";
    f.style.setProperty("--x","0px");
    f.style.setProperty("--r","0deg");
  } else if(val<1000000){
    const compact = (val/1000).toFixed(1) + 'K';
    f.textContent="+"+compact;
    f.style.color="#f39c12";
    f.style.fontSize="13px";
    f.style.setProperty("--x",(Math.random()*14-7)+"px");
    f.style.setProperty("--r","0deg");
  } else if(val<1000000000){
    const compact = (val/1000000).toFixed(1) + 'M';
    f.textContent="+"+compact;
    f.style.color="#9b59b6";
    f.style.fontSize="14px";
    f.style.setProperty("--x",(Math.random()*30-15)+"px");
    f.style.setProperty("--r",(Math.random()*20-10)+"deg");
  } else {
    const compact = (val/1000000000).toFixed(1) + 'B';
    f.textContent="+"+compact;
    f.style.color="#e74c3c";
    f.style.fontSize="15px";
    f.style.setProperty("--x",(Math.random()*40-20)+"px");
    f.style.setProperty("--r",(Math.random()*30-15)+"deg");
  }
  document.body.appendChild(f);
  
  // Determinar duraci√≥n seg√∫n tipo
  let duration = 1200;
  if(isGoo) duration = 4000;
  else if(isInstantConversion) duration = 2000;
  else if(isCritical) duration = 2500;
  
  if(!isGoo) setTimeout(()=>f.remove(), duration);
}

function showFloatingText(x, y, text, color){
  const f = document.createElement("div");
  f.style.position = "fixed";
  f.style.left = x + "px";
  f.style.top = y + "px";
  f.style.fontSize = "16px";
  f.style.fontWeight = "bold";
  f.style.color = color;
  f.style.textShadow = `0 0 8px ${color}`;
  f.style.pointerEvents = "none";
  f.style.zIndex = "9999";
  f.style.animation = "float 2s ease-out forwards";
  f.textContent = text;
  document.body.appendChild(f);
  setTimeout(() => f.remove(), 2000);
}

// create simple decorative particles inside a container (idempotent)
function createParticles(container, color='#f1c40f', count=6){
  if(!container || container.dataset.particlesInitialized) return;
  container.dataset.particlesInitialized = '1';
  for(let i=0;i<count;i++){
    const p = document.createElement('div');
    p.className = 'particle';
    // smaller particle visual
    p.style.width = '4px'; p.style.height = '4px';
    const left = Math.random()*80 + '%';
    const top = Math.random()*80 + '%';
    p.style.left = left; p.style.top = top;
    p.style.background = color;
    const px = (Math.random()*100-50) + 'px';
    const py = (Math.random()*100-60) + 'px';
    p.style.setProperty('--px', px);
    p.style.setProperty('--py', py);
    p.style.animationDuration = (900 + Math.random()*900) + 'ms';
    p.style.opacity = 0.95;
    container.appendChild(p);
  }
}

/* ================= CLICK ================= */
function clickTile(t, d, f, i){
  const tool = TOOLS.find(toolItem => toolItem.id === equippedToolId);
  if (!tool) return;

  // Apply Hasty Bee cooldown reduction (-20%)
  let effectiveCooldown = tool.cooldown;
  if(equippedBees.includes('bee3')){
    effectiveCooldown *= 0.8;
  }

  if (Date.now() - lastClick < effectiveCooldown) return;
  lastClick = Date.now();

  // count click for current field
  try{ ensureFieldStats(currentField); fieldStats[currentField].clicks = (fieldStats[currentField].clicks||0) + 1; }catch(e){}
  
  applyToolPattern(i, f);
  updateUI();
}





/* ================= CONVERT ================= */
setInterval(()=>{
const totalConvertBonus = stats.convertBonus + stats.beeConvertBonus;
const rate = 0.1 * (1 + totalConvertBonus / 100);
const c = Math.min(stats.pollen, rate);
stats.pollen -= c;
stats.honey += c * 0.15;
stats.totalHoney += c * 0.15;
honeyThisSec = c * 0.15;
pollenThisSec = 0;
updateUI();
saveGame();
}, 1000);

/* ================= SPECIAL BEE ABILITIES ================= */
/* ================= UPGRADES UI ================= */
function buildUpgrades(){
  const upgradesEl = document.getElementById("upgrades");
  upgradesEl.innerHTML="";
  UPGRADES.forEach(u=>{
    const lvl = upgradeLevels[u.id] || 0;
    const f = document.createElement('div');
    f.className = 'upgrade-frame';

    const top = document.createElement('div'); top.className = 'upgrade-top';
    const nameEl = document.createElement('div'); nameEl.style.fontWeight='bold'; nameEl.style.color='#f1c40f'; nameEl.textContent = u.name;
    top.appendChild(nameEl);
    const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.textContent = u.description || 'No description available';
    top.appendChild(descEl);
    // Show next upgrade level
    const levelEl = document.createElement('div'); levelEl.className='upgrade-desc'; levelEl.style.color='#aef1c4'; levelEl.style.marginTop='4px'; levelEl.textContent = u.levels && u.levels[lvl] ? `Next: ${u.levels[lvl].percent?`+${u.levels[lvl].percent}%`:(u.levels[lvl].amount?`+${u.levels[lvl].amount}`:'+0')}` : 'MAX';
    top.appendChild(levelEl);
    f.appendChild(top);

    // top-right image
    if(u.img){
      const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
      const imgEl = document.createElement('img'); imgEl.src = `images/${u.img}`; imgEl.style.width='48px'; imgEl.style.height='48px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='6px';
      imgEl.className = 'egg-art';
      art.appendChild(imgEl);
      // decorative particles for special upgrade art if name indicates rarity (optional)
      if(u.name && (/legend|mythic|myth/i).test(u.name)){
        createParticles(art, /myth/i.test(u.name) ? '#9b59b6' : '#f1c40f', 6);
      }
      f.appendChild(art);
    }

    // bottom row with button and price
    const btn = document.createElement('button'); btn.className='small-btn';
    btn.style.minWidth = '50px';
    const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
    if(lvl >= u.levels.length){
      btn.textContent = 'MAX'; btn.disabled = true;
    } else {
      const L = u.levels[lvl];
      btn.textContent = 'BUY';
      btn.onclick = ()=>{
        if(stats.honey < L.price) return; stats.honey -= L.price;
        if(u.stat === 'backpack'){
          stats[u.stat] += (L.amount||0);
          stats.pollenCapacity += (L.amount||0);
        } else if(u.stat === 'criticalPower'){
          stats[u.stat] += (L.percent||0);
        } else if(u.stat === 'maxSlots'){
          maxSlots += (L.amount||0);
        } else {
          stats[u.stat] += (L.percent||0);
        }
        upgradeLevels[u.id] = (upgradeLevels[u.id] || 0) + 1;
        saveGame(); buildUpgrades(); updateUI();
      };
    }
    bottom.appendChild(btn);
    f.appendChild(bottom);
    const priceWrap = document.createElement('div');
    priceWrap.className = 'upgrade-price-wrap';
    const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' üçØ') : '';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);
    upgradesEl.appendChild(f);
  });
  
  // Special Bees section
  const specialTitle = document.createElement('div');
  specialTitle.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:14px;margin:16px 0 8px 0;text-transform:uppercase;border-top:1px solid #444;padding-top:12px;';
  specialTitle.textContent = 'üåü SPECIAL BEES';
  upgradesEl.appendChild(specialTitle);
  
  SPECIAL_BEES.forEach(bee => {
    const owned = ownedSpecialBees.includes(bee.id);
    const isEquipped = equippedSpecialBees.includes(bee.id);
    const f = document.createElement('div');
    f.className = 'upgrade-frame';
    
    const top = document.createElement('div');
    top.className = 'upgrade-top';
    const nameEl = document.createElement('div');
    nameEl.style.fontWeight = 'bold';
    nameEl.style.color = bee.color;
    nameEl.textContent = bee.name + (isEquipped ? ' ‚ú®' : '');
    top.appendChild(nameEl);
    
    // Improved description with abilities
    const descEl = document.createElement('div');
    descEl.className = 'upgrade-desc';
    descEl.innerHTML = `<div style="margin-bottom:4px">${bee.desc}</div>
      <div style="font-size:11px;color:#aef1c4;line-height:1.4;">
        ${bee.bonusMultipliers ? Object.entries(bee.bonusMultipliers).map(([targetId, mult]) => {
          const targetBee = BEES.find(b => b.id === targetId);
          const bonusPercent = ((mult-1)*100).toFixed(0);
          return `<div>üìà ${targetBee?.name || 'Desconocida'}: +${bonusPercent}%</div>`;
        }).join('') : ''}
      </div>`;
    top.appendChild(descEl);
    f.appendChild(top);
    
    // Image
    if(bee.img){
      const art = document.createElement('div');
      art.style.gridColumn = '2/3';
      art.style.gridRow = '1/2';
      art.style.display = 'flex';
      art.style.alignItems = 'flex-start';
      art.style.justifyContent = 'center';
      const imgEl = document.createElement('img');
      imgEl.src = `images/${bee.img}`;
      imgEl.style.width = '48px';
      imgEl.style.height = '48px';
      imgEl.style.objectFit = 'cover';
      imgEl.style.borderRadius = '6px';
      imgEl.style.border = `2px solid ${bee.color}`;
      art.appendChild(imgEl);
      f.appendChild(art);
    }
    
    // Bottom button
    const bottom = document.createElement('div');
    bottom.className = 'upgrade-bottom';
    const btn = document.createElement('button');
    btn.className = 'small-btn';
    btn.style.minWidth = '50px';
    
    const equippedCount = equippedSpecialBees.length;
    
    if(!owned){
      btn.textContent = 'BUY';
      btn.onclick = () => {
        if(bee.priceType === 'tickets'){
          if(tickets < bee.price) {
            alert('No tienes suficientes tickets');
            return;
          }
          tickets -= bee.price;
        } else {
          if(stats.honey < bee.price) {
            alert('No tienes suficiente miel');
            return;
          }
          stats.honey -= bee.price;
        }
        ownedSpecialBees.push(bee.id);
        discoveredBees.push(bee.id);
        // Auto-equip if less than 3 are equipped
        if(equippedSpecialBees.length < 3){
          equippedSpecialBees.push(bee.id);
        } else {
          // Replace the first one if all 3 slots are full
          equippedSpecialBees.shift();
          equippedSpecialBees.push(bee.id);
        }
        saveGame();
        buildUpgrades();
        buildBeeGrid();
        updateBeeAbilities();
        updateUI();
      };
    } else if(isEquipped){
      btn.textContent = '‚úì EQUIPPED';
      btn.disabled = true;
    } else {
      btn.textContent = equippedCount >= 3 ? 'SWAP' : 'EQUIP';
      btn.onclick = () => {
        if(equippedSpecialBees.length < 3){
          equippedSpecialBees.push(bee.id);
        } else {
          // Si hay 3, quitar la primera y agregar la nueva
          equippedSpecialBees.shift();
          equippedSpecialBees.push(bee.id);
        }
        saveGame();
        buildUpgrades();
        buildBeeGrid();
        updateBeeAbilities();
        updateUI();
      };
    }
    
    const priceWrap = document.createElement('div');
    priceWrap.style.display='flex';
    priceWrap.style.justifyContent='space-between';
    priceWrap.style.marginTop='8px';
    priceWrap.appendChild(btn);
    const priceEl = document.createElement('div');
    priceEl.className = 'price-label';
    priceEl.textContent = owned ? '‚úì Comprada' : (fmt(bee.price) + (bee.priceType === 'tickets' ? ' üé´' : ' üçØ'));
    priceEl.style.alignSelf='center';
    priceEl.style.paddingLeft='8px';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);
    upgradesEl.appendChild(f);
  });
}

/* ================= TILES UPGRADES UI ================= */
function buildTilesUpgrades(){
  const tilesUpgradesEl = document.getElementById("tilesUpgrades");
  tilesUpgradesEl.innerHTML = "";
  
  TILE_UPGRADES.forEach(u => {
    const lvl = tileUpgradeLevels[u.id] || 0;
    const f = document.createElement('div');
    f.className = 'upgrade-frame';

    const top = document.createElement('div');
    top.className = 'upgrade-top';
    const nameEl = document.createElement('div');
    nameEl.style.fontWeight = 'bold';
    nameEl.style.color = '#f1c40f';
    nameEl.textContent = u.name;
    top.appendChild(nameEl);
    
    const descEl = document.createElement('div');
    descEl.className = 'upgrade-desc';
    descEl.textContent = u.description || 'No description available';
    top.appendChild(descEl);
    
    // Show next upgrade level
    const levelEl = document.createElement('div');
    levelEl.className = 'upgrade-desc';
    levelEl.style.color = '#aef1c4';
    levelEl.style.marginTop = '4px';
    
    if(u.levels && u.levels[lvl]){
      let nextText = 'Next: ';
      if(u.levels[lvl].amount){
        nextText += `+${u.levels[lvl].amount}`;
      } else if(u.levels[lvl].percent){
        nextText += `+${u.levels[lvl].percent}%`;
      } else if(u.levels[lvl].regenerationRange){
        nextText += `${u.levels[lvl].regenerationRange.min}ms-${u.levels[lvl].regenerationRange.max}ms`;
      }
      levelEl.textContent = nextText;
    } else {
      levelEl.textContent = 'MAX';
    }
    top.appendChild(levelEl);
    f.appendChild(top);

    // top-right image
    if(u.img){
      const art = document.createElement('div');
      art.style.gridColumn = '2/3';
      art.style.gridRow = '1/2';
      art.style.display = 'flex';
      art.style.alignItems = 'flex-start';
      art.style.justifyContent = 'center';
      const imgEl = document.createElement('img');
      imgEl.src = `images/${u.img}`;
      imgEl.style.width = '48px';
      imgEl.style.height = '48px';
      imgEl.style.objectFit = 'contain';
      imgEl.style.borderRadius = '6px';
      imgEl.className = 'egg-art';
      art.appendChild(imgEl);
      f.appendChild(art);
    }

    // bottom row with button and price
    const btn = document.createElement('button');
    btn.className = 'small-btn';
    btn.style.minWidth = '50px';
    
    const bottom = document.createElement('div');
    bottom.className = 'upgrade-bottom';
    
    if(lvl >= u.levels.length){
      btn.textContent = 'MAX';
      btn.disabled = true;
    } else {
      const L = u.levels[lvl];
      btn.textContent = 'BUY';
      btn.onclick = () => {
        if(stats.honey < L.price) return;
        stats.honey -= L.price;
        
        if(u.stat === 'maxGooTiles'){
          maxGooTiles += (L.amount || 0);
        } else if(u.stat === 'tileRegenerationRange'){
          tileRegenerationRange = L.regenerationRange || tileRegenerationRange;
        }
        
        tileUpgradeLevels[u.id] = (tileUpgradeLevels[u.id] || 0) + 1;
        saveGame();
        buildTilesUpgrades();
        updateUI();
      };
    }
    
    bottom.appendChild(btn);
    f.appendChild(bottom);
    
    const priceWrap = document.createElement('div');
    priceWrap.className = 'upgrade-price-wrap';
    const priceEl = document.createElement('div');
    priceEl.className = 'price-label';
    priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' üçØ') : '';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);
    
    tilesUpgradesEl.appendChild(f);
  });
}

/* ================= BEES CATALOG ================= */
function buildBeesCatalog(){
  const beesEl = document.getElementById("bees");
  beesEl.innerHTML = "";
  
  // Count discovered bees (distinct bee IDs)
  const totalCount = BEES.length + SPECIAL_BEES.length;
  
  // Add counter at the top with ID for dynamic updates
  const counterDiv = document.createElement('div');
  counterDiv.id = 'beeCounterDiv';
  counterDiv.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:14px;margin-bottom:12px;padding:8px;background:#262626;border-radius:0px;text-align:center;';
  updateBeeCounter(counterDiv);
  beesEl.appendChild(counterDiv);
  
  // Group bees by rarity
  const rarities = ['common', 'rare', 'epic', 'legendary', 'mythic'];
  const beesByRarity = {};
  rarities.forEach(r => beesByRarity[r] = []);
  
  BEES.forEach(bee => {
    if(beesByRarity[bee.rarity]) beesByRarity[bee.rarity].push(bee);
  });
  
  // Create sections for each rarity
  // Define completion rewards per rarity
  const completionRewards = {
    'common': 5,
    'rare': 50,
    'epic': 150,
    'legendary': 300,
    'mythic': 500
  };
  
  rarities.forEach(rarity => {
    const bees = beesByRarity[rarity];
    if(bees.length === 0) return;
    
    // Count discovered bees in this rarity
    const discoveredCount = bees.filter(b => discoveredBees.includes(b.id)).length;
    const totalCount = bees.length;
    const rewardTickets = completionRewards[rarity] || 0;
    const isComplete = discoveredCount === totalCount;
    
    // Rarity title with counter and reward button
    const titleContainer = document.createElement('div');
    titleContainer.className = 'rarity-title-container';
    
    const titleDiv = document.createElement('div');
    titleDiv.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:13px;text-transform:uppercase;display:flex;gap:10px;align-items:center;';
    
    const rarityLabel = document.createElement('span');
    rarityLabel.textContent = rarity;
    
    const counterText = document.createElement('span');
    counterText.style.cssText = 'color:#ccc;font-size:12px;font-weight:normal;';
    counterText.textContent = `${discoveredCount}/${totalCount}`;
    
    titleDiv.appendChild(rarityLabel);
    titleDiv.appendChild(counterText);
    
    // Reward claim button
    const rewardBtn = document.createElement('button');
    rewardBtn.className = 'small-btn';
    const isAlreadyClaimed = claimedRewards[rarity] === true;
    
    // Determine button state
    let btnStyle = '';
    if(isAlreadyClaimed){
      btnStyle = 'background:linear-gradient(135deg, #9E9E9E, #757575);';
    } else if(isComplete){
      btnStyle = 'background:linear-gradient(135deg, #4CAF50, #45a049);';
    } else {
      btnStyle = 'background:linear-gradient(135deg, #666, #555);opacity:0.6;cursor:not-allowed;';
    }
    
    rewardBtn.style.cssText = `
      ${btnStyle}
      color:#fff;
      padding:6px 12px;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
      transition:all 0.3s ease;
    `;
    
    if(isAlreadyClaimed){
      rewardBtn.innerHTML = `‚úì Reclamado`;
      rewardBtn.disabled = true;
    } else {
      rewardBtn.innerHTML = `üé´ ${rewardTickets}`;
      rewardBtn.disabled = !isComplete;
    }
    
    if(isComplete && !isAlreadyClaimed){
      rewardBtn.style.animation = 'reward-unlock 0.4s ease-out';
      rewardBtn.onclick = function(){
        // Add to player tickets
        stats.tickets = (stats.tickets || 0) + rewardTickets;
        // Mark as claimed
        claimedRewards[rarity] = true;
        // Update button
        rewardBtn.disabled = true;
        rewardBtn.style.animation = 'reward-claim 0.5s ease-out';
        rewardBtn.innerHTML = `‚úì Reclamado`;
        rewardBtn.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
        saveGame();
      };
    }
    
    titleContainer.appendChild(titleDiv);
    titleContainer.appendChild(rewardBtn);
    beesEl.appendChild(titleContainer);
    
    // Bees in this rarity
    bees.forEach(bee => {
      const isDiscovered = discoveredBees.includes(bee.id);
      const countEquipped = equippedBees.filter(b => b === bee.id).length;
      
      const frame = document.createElement('div');
      frame.className = 'bee-catalog-frame';
      
      // Apply color background based on colorType
      let backgroundColor = '#333';
      let colorAnimation = '';
      if(bee.colorType === 'red'){
        backgroundColor = 'rgba(255, 69, 0, 0.3)';
      } else if(bee.colorType === 'blue'){
        backgroundColor = 'rgba(65, 105, 225, 0.3)';
      } else if(bee.colorType === 'yellow'){
        backgroundColor = 'rgba(255, 215, 0, 0.3)';
      } else if(bee.colorType === 'purple'){
        backgroundColor = 'rgba(157, 78, 221, 0.3)';
      } else if(bee.colorType === 'white'){
        backgroundColor = 'rgba(255, 215, 0, 0.2)';
      } else if(bee.colorType === 'mixed' && bee.mixedColors){
        // Create animation style for mixed colors
        const color1 = bee.mixedColors[0] || '#FF4500';
        const color2 = bee.mixedColors[1] || '#4169E1';
        colorAnimation = `
          <style id="mixed-color-${bee.id}">
            @keyframes mixedColorBg-${bee.id} {
              0% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
              25% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
              50% { background-color: rgba(${parseInt(color2.slice(1,3),16)}, ${parseInt(color2.slice(3,5),16)}, ${parseInt(color2.slice(5,7),16)}, 0.3); }
              75% { background-color: rgba(${parseInt(color2.slice(1,3),16)}, ${parseInt(color2.slice(3,5),16)}, ${parseInt(color2.slice(5,7),16)}, 0.3); }
              100% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
            }
            #frame-${bee.id} {
              animation: mixedColorBg-${bee.id} 4s linear infinite;
            }
          </style>
        `;
      }
      
      frame.id = `frame-${bee.id}`;
      frame.className = 'bee-catalog-frame';
      frame.style.background = backgroundColor;
      frame.style.opacity = isDiscovered ? '0.85' : '0.3';
      frame.style.cursor = 'pointer';
      frame.style.border = `2px solid ${bee.color}`;
      
      // Add bee color type indicator
      const colorTypeLabel = bee.colorType === 'red' ? 'üî¥' : bee.colorType === 'blue' ? 'üîµ' : bee.colorType === 'yellow' ? 'üíõ' : bee.colorType === 'purple' ? 'üíú' : '‚ö™';
      const rarityLabel = rarity.toUpperCase();
      
      // Prepare color display label
      let colorDisplayLabel = bee.colorType === 'red' ? 'RED' : bee.colorType === 'blue' ? 'BLUE' : bee.colorType === 'yellow' ? 'YELLOW' : bee.colorType === 'purple' ? 'PURPLE' : bee.colorType === 'mixed' ? 'MIXED' : 'COLORLESS';
      
      // Determine color for rarity/type text based on bee color type
      let colorTextColor = '#ddd'; // default
      if(bee.colorType === 'red') colorTextColor = '#FF4500';
      else if(bee.colorType === 'blue') colorTextColor = '#4169E1';
      else if(bee.colorType === 'yellow') colorTextColor = '#FFD700';
      else if(bee.colorType === 'purple') colorTextColor = '#9D4EDD';
      else if(bee.colorType === 'colorless') colorTextColor = '#ffffff';
      else if(bee.colorType === 'mixed') colorTextColor = '#ddd'; // mixed stays as is, with animation
      
      // Create color cycling style if mixed for the catalog
      const colorCycleStyleCatalog = bee.colorType === 'mixed' && bee.mixedColors ? `
        <style>
          .color-label-${bee.id} {
            animation: colorCycleCatalog-${bee.id} 4s linear infinite;
          }
          @keyframes colorCycleCatalog-${bee.id} {
            0% { color: ${bee.mixedColors[0]}; }
            25% { color: ${bee.mixedColors[0]}; }
            50% { color: ${bee.mixedColors[1] || bee.mixedColors[0]}; }
            75% { color: ${bee.mixedColors[1] || bee.mixedColors[0]}; }
            100% { color: ${bee.mixedColors[0]}; }
          }
        </style>
      ` : '';
      
      // Generate tier stars
      const tierStars = () => {
        if(!bee.tier) return '';
        let html = '<div style="margin-top:2px;font-size:11px;letter-spacing:1px;">';
        for(let i = 1; i <= 5; i++){
          const isActive = i <= bee.tier;
          const starColor = isActive ? (i < bee.tier ? '#f1c40f' : '#FF69B4') : '#555';
          html += `<span style="color:${starColor};text-shadow:0 0 2px ${starColor}">‚òÖ</span>`;
        }
        html += '</div>';
        return html;
      };
      
      frame.innerHTML = `
        ${colorCycleStyleCatalog}
        <div style="position:relative;flex-shrink:0;">
          <img src="images/${bee.img}" style="width:48px;height:48px;object-fit:cover;border-radius:0px;${!isDiscovered ? 'filter:grayscale(100%);' : ''}">
          ${isDiscovered ? `<div style="position:absolute;bottom:-4px;right:-4px;background:#f1c40f;color:#000;border-radius:0px;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:11px;">${countEquipped}</div>` : ''}
          ${isDiscovered ? `<div style="position:absolute;top:-4px;right:-4px;background:rgba(0,0,0,0.7);color:${bee.colorType === 'mixed' && bee.mixedColors ? bee.mixedColors[0] : bee.color};border-radius:0px;padding:2px 6px;font-size:9px;font-weight:bold;${bee.colorType === 'mixed' && bee.mixedColors ? `animation:colorCycleCatalog-${bee.id} 4s linear infinite;` : ''}">${colorDisplayLabel}</div>` : ''}
        </div>
        <div style="flex:1;min-width:0;">
          <div style="font-weight:bold;color:#fff;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${isDiscovered ? bee.name : '???'}</div>
          <div style="font-size:10px;color:${bee.colorType === 'mixed' && bee.mixedColors ? '#ddd' : colorTextColor};${bee.colorType === 'mixed' && bee.mixedColors ? `animation:colorCycleCatalog-${bee.id} 4s linear infinite;` : ''}">${isDiscovered ? (rarityLabel + ' ' + colorTypeLabel) : 'No descubierta'}</div>
          ${isDiscovered ? tierStars() : ''}
        </div>
      `;
      
      if(isDiscovered){
        frame.onmouseenter = () => { frame.style.opacity = '1'; frame.style.boxShadow = `0 0 12px ${bee.color}`; };
        frame.onmouseleave = () => { frame.style.opacity = '0.85'; frame.style.boxShadow = 'none'; };
      }
      frame.onclick = () => showBeeDetails(bee);
      
      beesEl.appendChild(frame);
    });
  });
  
  // Special Bees section
  const specialTitle = document.createElement('div');
  specialTitle.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:13px;margin:12px 0 8px 0;text-transform:uppercase;';
  specialTitle.textContent = 'special (' + SPECIAL_BEES.length + ')';
  beesEl.appendChild(specialTitle);
  
  SPECIAL_BEES.forEach(bee => {
    const isDiscovered = discoveredBees.includes(bee.id);
    const frame = document.createElement('div');
    frame.className = 'bee-catalog-frame';
    
    // Apply color background based on colorType (like normal bees)
    let backgroundColor = '#333';
    let colorAnimation = '';
    if(bee.colorType === 'red'){
      backgroundColor = 'rgba(255, 69, 0, 0.3)';
    } else if(bee.colorType === 'blue'){
      backgroundColor = 'rgba(65, 105, 225, 0.3)';
    } else if(bee.colorType === 'yellow'){
      backgroundColor = 'rgba(255, 215, 0, 0.3)';
    } else if(bee.colorType === 'purple'){
      backgroundColor = 'rgba(157, 78, 221, 0.3)';
    } else if(bee.colorType === 'white'){
      backgroundColor = 'rgba(255, 215, 0, 0.2)';
    } else if(bee.colorType === 'mixed' && bee.mixedColors){
      // Create animation style for mixed colors
      const color1 = bee.mixedColors[0] || '#FF4500';
      const color2 = bee.mixedColors[1] || '#4169E1';
      colorAnimation = `
        <style id="mixed-color-special-${bee.id}">
          @keyframes mixedColorBg-special-${bee.id} {
            0% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
            25% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
            50% { background-color: rgba(${parseInt(color2.slice(1,3),16)}, ${parseInt(color2.slice(3,5),16)}, ${parseInt(color2.slice(5,7),16)}, 0.3); }
            75% { background-color: rgba(${parseInt(color2.slice(1,3),16)}, ${parseInt(color2.slice(3,5),16)}, ${parseInt(color2.slice(5,7),16)}, 0.3); }
            100% { background-color: rgba(${parseInt(color1.slice(1,3),16)}, ${parseInt(color1.slice(3,5),16)}, ${parseInt(color1.slice(5,7),16)}, 0.3); }
          }
          #frame-special-${bee.id} {
            animation: mixedColorBg-special-${bee.id} 4s linear infinite;
          }
        </style>
      `;
    }
    
    frame.id = `frame-special-${bee.id}`;
    frame.style.background = backgroundColor;
    frame.style.opacity = isDiscovered ? '0.85' : '0.3';
    frame.style.cursor = 'pointer';
    frame.style.border = `2px solid ${bee.color}`;
    
    const colorTypeLabel = bee.colorType === 'red' ? 'üî¥' : bee.colorType === 'blue' ? 'üîµ' : bee.colorType === 'yellow' ? 'üíõ' : bee.colorType === 'purple' ? 'üíú' : '‚ö™';
    let colorDisplayLabel = bee.colorType === 'red' ? 'RED' : bee.colorType === 'blue' ? 'BLUE' : bee.colorType === 'yellow' ? 'YELLOW' : bee.colorType === 'purple' ? 'PURPLE' : bee.colorType === 'mixed' ? 'MIXED' : 'COLORLESS';
    
    // Determine color for rarity/type text based on bee color type
    let colorTextColor = '#ddd'; // default
    if(bee.colorType === 'red') colorTextColor = '#FF4500';
    else if(bee.colorType === 'blue') colorTextColor = '#4169E1';
    else if(bee.colorType === 'yellow') colorTextColor = '#FFD700';
    else if(bee.colorType === 'purple') colorTextColor = '#9D4EDD';
    else if(bee.colorType === 'colorless') colorTextColor = '#ffffff';
    else if(bee.colorType === 'mixed') colorTextColor = '#ddd'; // mixed stays as is, with animation
    
    // Create color cycling style if mixed for the catalog
    const colorCycleStyleCatalog = bee.colorType === 'mixed' && bee.mixedColors ? `
      <style>
        .color-label-special-${bee.id} {
          animation: colorCycleCatalogSpecial-${bee.id} 4s linear infinite;
        }
        @keyframes colorCycleCatalogSpecial-${bee.id} {
          0% { color: ${bee.mixedColors[0]}; }
          25% { color: ${bee.mixedColors[0]}; }
          50% { color: ${bee.mixedColors[1] || bee.mixedColors[0]}; }
          75% { color: ${bee.mixedColors[1] || bee.mixedColors[0]}; }
          100% { color: ${bee.mixedColors[0]}; }
        }
      </style>
    ` : '';
    
    // Generate tier stars
    const tierStars = () => {
      if(!bee.tier) return '';
      let html = '<div style="margin-top:2px;font-size:11px;letter-spacing:1px;">';
      for(let i = 1; i <= 5; i++){
        const isActive = i <= bee.tier;
        const starColor = isActive ? (i < bee.tier ? '#f1c40f' : '#FF69B4') : '#555';
        html += `<span style="color:${starColor};text-shadow:0 0 2px ${starColor}">‚òÖ</span>`;
      }
      html += '</div>';
      return html;
    };
    
    frame.innerHTML = `
      ${colorAnimation}
      ${colorCycleStyleCatalog}
      <div style="position:relative;flex-shrink:0;">
        <img src="images/${bee.img}" style="width:48px;height:48px;object-fit:cover;border-radius:0px;${!isDiscovered ? 'filter:grayscale(100%);' : ''}">
        ${isDiscovered ? `<div style="position:absolute;bottom:-4px;right:-4px;background:#f1c40f;color:#000;border-radius:0px;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:11px;">1</div>` : ''}
        ${isDiscovered ? `<div style="position:absolute;top:-4px;right:-4px;background:rgba(0,0,0,0.7);color:${bee.colorType === 'mixed' && bee.mixedColors ? bee.mixedColors[0] : bee.color};border-radius:0px;padding:2px 6px;font-size:9px;font-weight:bold;${bee.colorType === 'mixed' && bee.mixedColors ? `animation:colorCycleCatalogSpecial-${bee.id} 4s linear infinite;` : ''}">${colorDisplayLabel}</div>` : ''}
      </div>
      <div style="flex:1;min-width:0;">
        <div style="font-weight:bold;color:#fff;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${isDiscovered ? bee.name : '???'}</div>
        <div style="font-size:10px;color:${bee.colorType === 'mixed' && bee.mixedColors ? '#ddd' : colorTextColor};${bee.colorType === 'mixed' && bee.mixedColors ? `animation:colorCycleCatalogSpecial-${bee.id} 4s linear infinite;` : ''}">${isDiscovered ? ('SPECIAL ' + colorTypeLabel) : 'No descubierta'}</div>
        ${isDiscovered ? tierStars() : ''}
      </div>
    `;
    
    if(isDiscovered){
      frame.onmouseenter = () => { frame.style.opacity = '1'; frame.style.boxShadow = `0 0 12px ${bee.color}`; };
      frame.onmouseleave = () => { frame.style.opacity = '0.85'; frame.style.boxShadow = 'none'; };
    }
    frame.onclick = () => showBeeDetails(bee);
    
    beesEl.appendChild(frame);
  });
}

function updateBeeCounter(el){
  const discoveredCount = discoveredBees.length;
  const totalCount = BEES.length + SPECIAL_BEES.length;
  el.textContent = `üêù ${discoveredCount}/${totalCount} Abejas Descubiertas`;
}

function showBeeDetails(bee){
  // Close existing modal
  const existing = document.getElementById('beeDetailsModal');
  if(existing) existing.remove();
  
  // Create modal
  const modal = document.createElement('div');
  modal.id = 'beeDetailsModal';
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;justify-content:flex-end;align-items:flex-start;z-index:3000;padding-top:60px;padding-right:20px;';
  
  const panel = document.createElement('div');
  panel.className = 'bee-details-panel';
  
  // Create animated gradient style for mixed color bees
  let panelStyle = `background:linear-gradient(135deg, ${bee.color}, #1a1a1a);border:2px solid ${bee.color};border-radius:0px;padding:16px;max-width:350px;box-shadow:0 10px 30px rgba(0,0,0,0.8);`;
  
  if(bee.colorType === 'mixed' && bee.mixedColors && bee.mixedColors.length > 0){
    const color1 = bee.mixedColors[0] || bee.color;
    const color2 = bee.mixedColors[1] || bee.color;
    panelStyle += `animation:beePanelGradient-${bee.id} 4s linear infinite;`;
  }
  
  panel.style.cssText = panelStyle;
  
  // Get synergies that include this bee
  const activeSynergies = SYNERGIES.filter(s => s.requirement.includes(bee.id));
  
  // Get color type label (uppercase)
  const colorTypeEmoji = bee.colorType === 'red' ? 'üî¥' : bee.colorType === 'blue' ? 'üîµ' : bee.colorType === 'yellow' ? 'üíõ' : bee.colorType === 'purple' ? 'üíú' : '‚ö™';
  const colorTypeLabel = bee.colorType === 'red' ? 'RED' : bee.colorType === 'blue' ? 'BLUE' : bee.colorType === 'yellow' ? 'YELLOW' : bee.colorType === 'purple' ? 'PURPLE' : 'COLORLESS';
  
  // Prepare color for text display (supports mixed colors)
  let colorTextStyle = '';
  let colorTypeDisplay = colorTypeLabel;
  if(bee.colorType === 'mixed' && bee.mixedColors && bee.mixedColors.length > 0){
    // For mixed colors, we'll apply animation via CSS
    const isMixedForAnimation = true;
    colorTextStyle = `color:#fff;animation:colorCycle 2s infinite;`;
    colorTypeDisplay = colorTypeLabel || 'MIXED';
    // We'll need to add CSS animation
  } else {
    // Use bee color or default
    const displayColor = bee.colorType === 'red' ? '#FF4500' : bee.colorType === 'blue' ? '#4169E1' : bee.colorType === 'yellow' ? '#FFD700' : bee.colorType === 'purple' ? '#9D4EDD' : '#FFD700';
    colorTextStyle = `color:${displayColor};`;
  }
  
  // Check if it's a special bee
  const isSpecialBee = bee.rarity === 'special';
  const isOwned = isSpecialBee ? ownedSpecialBees.includes(bee.id) : discoveredBees.includes(bee.id);
  const isEquipped = isSpecialBee ? equippedSpecialBees === bee.id : false;
  
  // Create color cycling style if mixed
  const colorCycleStyle = bee.colorType === 'mixed' && bee.mixedColors ? `
    <style>
      @keyframes colorCycle {
        0% { color: ${bee.mixedColors[0]}; }
        50% { color: ${bee.mixedColors[1] || bee.mixedColors[0]}; }
        100% { color: ${bee.mixedColors[0]}; }
      }
      @keyframes beePanelGradient-${bee.id} {
        0% { background:linear-gradient(135deg, ${bee.mixedColors[0]}, #1a1a1a); }
        25% { background:linear-gradient(135deg, ${bee.mixedColors[0]}, #1a1a1a); }
        50% { background:linear-gradient(135deg, ${bee.mixedColors[1] || bee.mixedColors[0]}, #1a1a1a); }
        75% { background:linear-gradient(135deg, ${bee.mixedColors[1] || bee.mixedColors[0]}, #1a1a1a); }
        100% { background:linear-gradient(135deg, ${bee.mixedColors[0]}, #1a1a1a); }
      }
    </style>
  ` : '';
  
  panel.innerHTML = `
    ${colorCycleStyle}
    <div style="text-align:center;margin-bottom:12px">
      <img src="images/${bee.img}" style="width:80px;height:80px;object-fit:cover;border-radius:0px;border:2px solid ${bee.color};margin-bottom:8px;${!isOwned ? 'filter:grayscale(100%);' : ''}">
      <div style="color:#fff;font-weight:bold;font-size:16px">${isOwned ? bee.name : '???'}</div>
      <div style="color:#ddd;font-size:12px;text-transform:uppercase;margin-bottom:4px">${isOwned ? bee.rarity.toUpperCase() : '?'}</div>
      <div style="${colorTextStyle}font-size:11px">${colorTypeEmoji} ${colorTypeDisplay}</div>
      ${isOwned && bee.tier ? `<div style="margin-top:4px;font-size:12px;letter-spacing:2px;">
        ${Array.from({length:5}).map((_, i) => {
          const isActive = i < bee.tier;
          const isLast = i === bee.tier - 1;
          const starColor = isActive ? (isLast ? '#FF69B4' : '#f1c40f') : '#555';
          return `<span style="color:${starColor};text-shadow:0 0 2px ${starColor};animation:starGrow 0.6s ease-in-out ${i*0.1}s both">‚òÖ</span>`;
        }).join('')}
      </div>` : ''}
    </div>
    <hr style="border:none;border-top:1px solid rgba(255,255,255,0.2);margin:8px 0;">
    <div style="color:#fff;font-size:12px;margin-bottom:8px">
      <div style="margin-bottom:6px"><b>Ability:</b></div>
      <div style="background:rgba(0,0,0,0.3);padding:6px;border-radius:0px;color:#aef1c4;font-size:11px">
        ${ABILITY_DESCRIPTIONS_EN[bee.ability] || 'No description available'}
      </div>
    </div>
    ${BEE_BUFFS[bee.id] && BEE_BUFFS[bee.id].length > 0 ? `
    <div style="color:#fff;font-size:12px;margin-bottom:8px">
      <div style="margin-bottom:6px"><b>Buffs:</b></div>
      ${BEE_BUFFS[bee.id].map(buff => `
        <div style="background:rgba(0,0,0,0.3);padding:6px;border-radius:0px;margin-bottom:4px;color:#FFD700;font-size:11px">
          ‚Ä¢ ${buff}
        </div>
      `).join('')}
    </div>
    ` : ''}
    ${isSpecialBee && bee.bonusMultipliers && Object.keys(bee.bonusMultipliers).length > 0 ? `
    <div style="color:#fff;font-size:12px;margin-bottom:8px">
      <div style="margin-bottom:6px"><b>Improves Bees:</b></div>
      ${Object.entries(bee.bonusMultipliers).map(([beeId, mult]) => {
        const targetBee = BEES.find(b => b.id === beeId);
        const bonusPercent = ((mult - 1) * 100).toFixed(0);
        return `
          <div style="background:rgba(0,0,0,0.3);padding:6px;border-radius:0px;margin-bottom:4px;color:#87CEEB;font-size:11px">
            ‚Ä¢ ${targetBee?.name || beeId}: +${bonusPercent}%
          </div>
        `;
      }).join('')}
    </div>
    ` : ''}
    <div style="color:#fff;font-size:12px;margin-bottom:8px">
      <div style="margin-bottom:6px"><b>Description:</b></div>
      <div style="background:rgba(0,0,0,0.3);padding:6px;border-radius:0px;color:#ddd;font-size:11px">
        ${bee.desc}
      </div>
    </div>
    ${activeSynergies.length > 0 ? `
    <hr style="border:none;border-top:1px solid rgba(255,255,255,0.2);margin:8px 0;">
    <div style="color:#fff;font-size:12px;">
      <div style="margin-bottom:6px;color:#AEF1C4"><b>Synergies:</b></div>
      ${activeSynergies.map(s => `
        <div style="background:rgba(0,0,0,0.3);padding:6px;border-radius:0px;margin-bottom:4px;border-left:3px solid #AEF1C4">
          <div style="font-weight:bold;color:#AEF1C4">${s.name}</div>
          <div style="color:#ccc;font-size:11px">
            ${Object.entries(s.bonus).map(([k,v]) => {
              const label = k.replace(/([A-Z])/g,' $1').trim();
              const val = (k.includes('chance') || k.includes('power')) ? `${v}` : `${v}%`;
              return `${label}: ${val}`;
            }).join(', ')}
          </div>
        </div>
      `).join('')}
    </div>
    ` : ''}
  `;
  
  modal.appendChild(panel);
  
  // Add star particle effect on the last star
  if(bee.tier && isOwned) {
    setTimeout(() => {
      const lastStar = panel.querySelector('[style*="FF69B4"]');
      if(lastStar) {
        lastStar.addEventListener('mouseenter', () => {
          for(let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            const angle = (i / 8) * Math.PI * 2;
            const distance = 20 + Math.random() * 20;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            
            particle.style.position = 'absolute';
            particle.style.left = lastStar.offsetLeft + 'px';
            particle.style.top = lastStar.offsetTop + 'px';
            particle.style.pointerEvents = 'none';
            particle.style.fontSize = '8px';
            particle.style.color = '#FF69B4';
            particle.innerHTML = '‚ú®';
            particle.style.setProperty('--px', x + 'px');
            particle.style.setProperty('--py', y + 'px');
            particle.style.animation = `starParticle 0.6s ease-out forwards`;
            panel.appendChild(particle);
            
            setTimeout(() => particle.remove(), 600);
          }
        });
      }
    }, 10);
  }
  
  // Close on click outside
  modal.onclick = (e) => {
    if(e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

function buildEggs(){
  const eggsEl = document.getElementById("eggs");
  eggsEl.innerHTML="";
  // Render egg shop cards instead of individual bees
  EGGS.forEach(egg => {
    const f = document.createElement("div");
    f.className = "egg-frame";
    // frame style (color or gradient)
    if(egg.frameStyle && egg.frameStyle.gradient){
      f.style.background = egg.frameStyle.bg;
    } else if(egg.frameStyle){
      f.style.borderLeft = `6px solid ${egg.frameStyle.bg}`;
    }

    f.innerHTML = `
      <div class="egg-art"><img src="images/${egg.img}" style="width:100%;height:100%;object-fit:contain;"/></div>
      <b>${egg.name}</b>
      <div style="font-size:12px;margin-top:6px;">Probabilidades:</div>
    `;
    // ensure mythic glow / particles and egg-art class are applied
    const artEl = f.querySelector('.egg-art');
    if(egg.id === 'egg_mythic') f.classList.add('mythic-egg');
    if(artEl){
      const artImg = artEl.querySelector('img');
      if(artImg) artImg.classList.add('egg-art');
      // add particles with color per egg rarity/type
      if(egg.probs){
        let col = null;
        if(egg.id === 'egg_golden') col = '#ffd700';
        else if(egg.id === 'egg_diamond') col = '#4fc3f7';
        else if(egg.id === 'egg_mythic') col = '#9b59b6';
        else if(egg.id === 'egg_silver') col = '#c0c0c0';
        // if egg has legendary/mythic chances, add particles
        if(col && (egg.probs.legendary > 0 || egg.probs.mythic > 0 || egg.id === 'egg_golden' || egg.id === 'egg_diamond')){
          createParticles(artEl, col, 8);
        }
      }
    }
    const probList = document.createElement('ul');
    probList.className = 'prob-list';
    ['common','rare','epic','legendary','mythic'].forEach(r=>{
      const li = document.createElement('li');
      li.textContent = `${r.charAt(0).toUpperCase()+r.slice(1)}: ${egg.probs[r] || 0}%`;
      probList.appendChild(li);
    });
    f.appendChild(probList);

    // no color/gradient controls (removed)

    const btn = document.createElement("button");
    btn.className = 'small-btn';
    btn.style.minWidth = '50px';
    const getPrice = () => eggPrices[egg.id] || egg.price;
    btn.textContent = `BUY`;
    btn.onclick = () => {
      const priceNow = getPrice();
      if(stats.honey < priceNow){ alert('No tienes suficiente miel'); return; }
      if(equippedBees.length >= maxSlots){ alert(`Tienes el n√∫mero m√°ximo de abejas equipadas (${maxSlots}). Compra m√°s slots en la tienda.`); return; }
      stats.honey -= priceNow;
      // hatch
      const hatchedBeeId = hatchBeeFromEgg(egg);
      if(hatchedBeeId){
        ownedBees.push(hatchedBeeId);
        // Add to discovered bees if not already discovered
        if(!discoveredBees.includes(hatchedBeeId)){
          discoveredBees.push(hatchedBeeId);
          // Add tickets reward for discovering a new bee
          const bee = BEES.find(b => b.id === hatchedBeeId);
          if(bee){
            const ticketRewards = {
              'common': 1,
              'rare': 5,
              'epic': 15,
              'legendary': 30,
              'mythic': 50
            };
            const reward = ticketRewards[bee.rarity] || 0;
            if(reward > 0){
              tickets += reward;
              showFloatingText(window.innerWidth / 2, 100, `üé´ +${reward} Tickets`, '#FFD700');
            }
          }
        }
        equipBee(hatchedBeeId);
      }
      // increase price by egg.mult and cap
      const mult = egg.mult || 1.5;
      const cap = egg.cap || Infinity;
      const newPrice = Math.min(Math.ceil(priceNow * mult), cap);
      eggPrices[egg.id] = newPrice;
      // refresh UI & save
      buildEggs();
      buildBeeGrid();
      updateUI();
      saveGame();
    };

    // f.appendChild(colorWrap);
    const priceWrap = document.createElement('div');
    priceWrap.style.display='flex';
    priceWrap.style.justifyContent='space-between';
    priceWrap.style.marginTop='8px';
    priceWrap.appendChild(btn);
    const priceLabel = document.createElement('div');
    priceLabel.style.alignSelf='center';
    priceLabel.style.paddingLeft='8px';
    priceLabel.className = 'price-label';
    priceLabel.textContent = fmt(getPrice()) + ' üçØ';
    priceWrap.appendChild(priceLabel);
    f.appendChild(priceWrap);

    eggsEl.appendChild(f);
  });

  // synergies are shown in player stats panel now
}

function buildSynergiesDisplay(){
  // kept for backward compatibility but not used; synergies are displayed in stats panel
}

// Hatch logic: pick a bee id based on egg probabilities
function hatchBeeFromEgg(egg){
  // build cumulative distribution of rarities
  const probs = egg.probs;
  const entries = ['common','rare','epic','legendary','mythic'];
  const rank = {common:0, rare:1, epic:2, legendary:3, mythic:4};
  // enforce upgraded eggs which guarantee higher rarities
  let minRank = 0;
  if(egg.id === 'egg_silver') minRank = 1; // superior a common -> at least rare
  else if(egg.id === 'egg_golden') minRank = 2; // superior a epic -> at least legendary
  
  else if(egg.id === 'egg_diamond') minRank = 3; // superior a epic -> at least legendary
  else if(egg.id === 'egg_mythic') minRank = 4; // mythic only

  // Build filtered list of entries taking into account minRank
  const filtered = entries.filter(e => rank[e] >= minRank && (probs[e]||0) > 0);
  const useEntries = (filtered.length > 0) ? filtered : entries.slice();

  const total = useEntries.reduce((s,k)=>s+(probs[k]||0),0);
  if(total <= 0) return null;
  let r = Math.random()*total;
  let chosenRarity = useEntries[0];
  for(const k of useEntries){
    r -= (probs[k]||0);
    if(r <= 0){ chosenRarity = k; break; }
  }

  // Filter BEES by chosenRarity, fallback to broader pools if empty
  let pool = BEES.filter(b=>b.rarity === chosenRarity);
  if(pool.length === 0 && rank[chosenRarity] < 4){
    // try to find any with higher rarities
    pool = BEES.filter(b => rank[b.rarity] >= rank[chosenRarity]);
  }
  const pickPool = pool.length ? pool : BEES;
  const chosen = pickPool[Math.floor(Math.random()*pickPool.length)];
  return chosen ? chosen.id : null;
}

/* ================= SHOP ================= */
function openShop(id){
document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
document.getElementById(id).classList.add("active");
if(id === "bees") buildBeesCatalog();
if(id === "eggs") buildEggs();
if(id === "storage") buildStorage();
if(id === "tilesUpgrades") buildTilesUpgrades();
}

// highlight active shop tab
function highlightShopTab(id){
  document.querySelectorAll('.shop-tabs button').forEach(b=>b.classList.remove('active-tab'));
  const btn = Array.from(document.querySelectorAll('.shop-tabs button')).find(b=>b.getAttribute('onclick') && b.getAttribute('onclick').includes(`openShop('${id}')`));
  if(btn) btn.classList.add('active-tab');
}

// wrap openShop to also highlight tab
const _openShop = openShop;
openShop = function(id){ _openShop(id); highlightShopTab(id); };

const TOOLS = [
{
  id:"shovel",
  name:"Shovel",
  price:0,
  cooldown:2000,
  pollenBonus:0,
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"Basic tool. Breaks 1 tile."
},
{
  id:"rake",
  name:"Rake",
  price:50,
  cooldown:1800,
  pollenBonus:10,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"Breaks tiles in a cross."
},
{
  id:"clippers",
  name:"Clippers",
  price:300,
  cooldown:1000,
  pollenBonus:0,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},
{
  id:"magnet",
  name:"Magnet",
  price:2800,
  cooldown:1500,
  pollenBonus:20,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},
{
  id:"vacuum",
  name:"Vacuum",
  price:14000,
  cooldown:1000,
  pollenBonus:20,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},{
  id:"pulsar",
  name:"Pulsar",
  price:50000,
  cooldown:1000,
  pollenBonus:30,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,1,1,1,1,1,1,1,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},
{
  id:"scissors",
  name:"Scissors",
  price:50000,
  cooldown:500,
  pollenBonus:50,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,1,0,0,0],
    [0,0,0,1,0,1,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},{
  id:"electrowand",
  name:"Electro-Wand",
  price:300000,
  cooldown:2000,
  pollenBonus:45,
  bonuses:{pollenBonus:0},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,1,1,1,1,1,0,0],
    [0,0,1,0,1,0,1,0,0],
    [0,0,1,1,1,1,1,0,0],
    [0,0,1,0,1,0,1,0,0],
    [0,0,1,1,1,1,1,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},{
  id:"honeydipper",
  name:"Honey Dipper",
  price:1000000,
  cooldown:1000,
  pollenBonus:50,
  bonuses:{pollenBonus:10},
  pattern:[
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,1,1,1,1,1,0,0],
    [0,1,1,1,1,1,1,1,0],
    [0,0,1,1,1,1,1,0,0],
    [0,0,0,1,1,1,0,0,0],
    [0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
  ],
  desc:"."
},
{
  id:"grandmaster",
  name:"Grandmaster Porcelain",
  price:10,
  cooldown:1000,
  pollenBonus:400,
  bonuses:{pollenBonus:300},
  pattern:[
    [0,0,1,1,1,1,1,0,0],
    [0,1,1,1,1,1,1,1,0],
    [1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1],
    [0,1,1,1,1,1,1,1,0],
    [0,0,1,1,1,1,1,0,0]
  ],
  desc:"Large AoE tool."
}
];

/* ================= STORAGE ================= */
const STORAGE = [
  {id:'pouch',name:'Pouch',price:50,desc:'Small pouch for carrying pollen. Increases capacity by +50',bonuses:{pollenCapacity:50},img:'storage_pouch.png'},
  {id:'jar',name:'Jar',price:650,desc:'Glass jar for storing pollen. Increases capacity by +800',bonuses:{pollenCapacity:800},img:'storage_jar.png'},
  {id:'backpack',name:'Backpack',price:4500,desc:'Spacious backpack for large amounts of pollen. Increases capacity by +5,200',bonuses:{pollenCapacity:5200},img:'storage_backpack.png'},
  {id:'canister',name:'Canister',price:22000,desc:'Reinforced metal canister for pollen storage. Increases capacity by +10,000',bonuses:{pollenCapacity:10000},img:'storage_canister.png'},

  {id:'megajug',name:'Mega Jug',price:75000,desc:'Massive jug with advanced compression. Increases capacity by +32,000',bonuses:{pollenCapacity:32000},img:'storage_megajug.png'},
  {id:'compressor',name:'Compressor',price:250000,desc:'Mechanical compressor for ultra-dense storage. Increases capacity by +100,000',bonuses:{pollenCapacity:100000},img:'storage_compressor.png'},
  {id:'coconutbag',name:'Coconut bag',price:20,desc:'Legendary coconut-woven bag with infinite potential. Increases capacity by +100B',bonuses:{pollenCapacity:100000000000},img:'storage_coconutbag.png'},

];

function buildStorage(){
  const storageEl = document.getElementById('storage');
  storageEl.innerHTML = '';
  STORAGE.forEach(s=>{
    const f = document.createElement('div'); f.className='upgrade-frame';
    const top = document.createElement('div'); top.className='upgrade-top';
    const nameEl = document.createElement('div'); nameEl.style.fontWeight='bold'; nameEl.style.color='#f1c40f'; nameEl.textContent = s.name;
    const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.textContent = s.desc;
    top.appendChild(nameEl); 
    top.appendChild(descEl);
    
    // Add capacity info
    const capacityEl = document.createElement('div'); 
    capacityEl.className='upgrade-desc'; 
    capacityEl.style.color='#FFD700';
    capacityEl.style.marginTop='4px';
    capacityEl.textContent = `Capacity: +${fmt(s.bonuses.pollenCapacity)}`;
    top.appendChild(capacityEl);
    
    // Add bonuses info if any
    if(s.bonuses && Object.keys(s.bonuses).length > 1){
      const bonusesEl = document.createElement('div');
      bonusesEl.className='upgrade-desc';
      bonusesEl.style.color='#aef1c4';
      bonusesEl.style.marginTop='4px';
      const bonusTexts = [];
      if(s.bonuses.pollenBonus) bonusTexts.push(`Pollen Bonus: +${s.bonuses.pollenBonus}%`);
      if(s.bonuses.convertBonus) bonusTexts.push(`Convert Bonus: +${s.bonuses.convertBonus}%`);
      bonusesEl.textContent = bonusTexts.join(', ');
      if(bonusTexts.length > 0) top.appendChild(bonusesEl);
    }
    
    f.appendChild(top);
    // top-right storage image (animated like egg)
    if(s.img){
      const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
      const imgEl = document.createElement('img'); imgEl.src = `images/${s.img}`; imgEl.style.width='48px'; imgEl.style.height='48px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='6px'; imgEl.className = 'egg-art';
      art.appendChild(imgEl);
      f.appendChild(art);
    }

    const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
    const b = document.createElement('button'); b.className='small-btn';
    b.style.minWidth = '50px';
    const owned = ownedStorages.includes(s.id);
    const equipped = (equippedStorageId === s.id);
    if(!owned){
      b.textContent = 'BUY';
      b.onclick = ()=>{
        if(stats.honey < s.price) return alert('No tienes suficiente miel');
        stats.honey -= s.price; ownedStorages.push(s.id); saveGame(); buildStorage(); updateUI();
      };
    } else if(!equipped){
      b.textContent = 'EQUIP'; b.onclick = ()=>{ equipStorage(s.id); };
    } else {
      b.textContent = 'EQUIPPED'; b.disabled = true;
    }
    bottom.appendChild(b);
    f.appendChild(bottom);
    
    const priceWrap = document.createElement('div');
    priceWrap.className = 'upgrade-price-wrap';
    const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = !owned ? (fmt(s.price) + ' üçØ') : '';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);
    
    storageEl.appendChild(f);
  });
}

function equipStorage(id){
  // remove previous storage bonuses
  const prev = STORAGE.find(s=>s.id===equippedStorageId);
  if(prev && prev.bonuses){
    for(const [k,v] of Object.entries(prev.bonuses)){
      stats[k] = (stats[k] || 0) - v;
    }
  }
  equippedStorageId = id;
  const s = STORAGE.find(x=>x.id===id);
  if(s && s.bonuses){
    for(const [k,v] of Object.entries(s.bonuses)){
      stats[k] = (stats[k] || 0) + v;
    }
  }
  saveGame();
  buildStorage();
  updateUI();
}

/* ================= INIT ================= */
loadGame();
buildFieldList();
buildGrid();
buildUpgrades();
buildTilesUpgrades();
updateUI();
buildTools();
// Toggle button for field list (overlay)
const _toggleBtn = document.getElementById('toggleFieldListBtn');
if(_toggleBtn){
  _toggleBtn.onclick = ()=>{
    const panel = document.getElementById('fieldList');
    if(panel) panel.classList.toggle('open');
  };
}

// Convert button: hold to convert pollen -> honey at 20x speed
const _convertBtn = document.getElementById('convertBtn');
let _convertInterval = null;
let _convertParticleInterval = null;

function spawnHoneyDrop(){
  if(!_convertBtn) return;
  const r = _convertBtn.getBoundingClientRect();
  const x = r.left + r.width * (0.3 + Math.random()*0.4);
  const y = r.top + r.height - 6;
  const drop = document.createElement('div');
  drop.className = 'honey-drop';
  drop.style.left = (x) + 'px';
  drop.style.top = (y) + 'px';
  document.body.appendChild(drop);
  setTimeout(()=>{ try{ drop.remove(); }catch(e){} }, 900);
}
function doConvertTick(mult=20, tickMs=200){
  const totalConvertBonus = stats.convertBonus + stats.beeConvertBonus;
  // Base: 1 honey per 1 pollen/sec
  // For every +50% conversion, add +10 to the conversion amount
  // Example: 100% conversion = 1 + (100/50)*10 = 1 + 20 = 21 honey per pollen
  const bonusStacks = Math.floor(totalConvertBonus / 50);
  const baseConversionRate = 1 + (bonusStacks * 10);
  const amount = Math.min(stats.pollen, baseConversionRate * mult * (tickMs/1000));
  if(amount <= 0) return;
  stats.pollen -= amount;
  const honeyGain = amount;
  stats.honey += honeyGain;
  stats.totalHoney += honeyGain;
  honeyThisSec = honeyGain;
  pollenThisSec = 0;
  updateUI();
}
function startConvertHold(){ if(_convertInterval) return; _convertBtn.classList.add('convert-active'); _convertInterval = setInterval(()=>doConvertTick(20,200),200); _convertParticleInterval = setInterval(spawnHoneyDrop, 160); }
function stopConvertHold(){ if(!_convertInterval) return; clearInterval(_convertInterval); _convertInterval = null; if(_convertParticleInterval){ clearInterval(_convertParticleInterval); _convertParticleInterval = null; } _convertBtn.classList.remove('convert-active'); saveGame(); }
if(_convertBtn){
  _convertBtn.addEventListener('pointerdown',(e)=>{ e.preventDefault(); startConvertHold(); });
  window.addEventListener('pointerup',()=>{ stopConvertHold(); });
  _convertBtn.addEventListener('pointerleave',()=>{ stopConvertHold(); });
  // touch fallback
  _convertBtn.addEventListener('touchstart',(e)=>{ e.preventDefault(); startConvertHold(); });
  _convertBtn.addEventListener('touchend',()=>{ stopConvertHold(); });
  window.addEventListener('blur',()=>{ stopConvertHold(); });
}

// click outside to close field list overlay
document.addEventListener('click', (e)=>{
  const panel = document.getElementById('fieldList');
  if(!panel) return;
  if(!panel.classList.contains('open')) return;
  const target = e.target;
  if(panel.contains(target)) return;
  if(_toggleBtn && _toggleBtn.contains(target)) return;
  panel.classList.remove('open');
});

buildBeeGrid();

// Developer command para probar destrucci√≥n de tiles
window.testDestroyTile = function(index = 0) {
  console.log(`üß™ TEST: Destroying tile ${index}`);
  if (!fieldData[currentField]) {
    console.error("‚ùå fieldData[currentField] does not exist!");
    return;
  }
  const tile = fieldData[currentField][index];
  console.log(`Tile ${index} before:`, tile);
  
  // Manually set to empty
  fieldData[currentField][index] = {c: "", ty: 0, transparent: true};
  
  // Get DOM element
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl.querySelector(`[data-idx="${index}"]`);
  if (tileEl) {
    // Re-render it
    renderTile(tileEl, fieldData[currentField][index]);
    // Fade it out
    tileEl.style.transition = "opacity 0.4s";
    tileEl.style.opacity = "0";
    console.log(`‚úÖ Tile ${index} destroyed and rendered`);
    
    // Regenerate after 2 seconds
    setTimeout(() => {
      fieldData[currentField][index] = createTile(currentField);
      renderTile(tileEl, fieldData[currentField][index]);
      tileEl.style.opacity = "1";
      console.log(`‚úÖ Tile ${index} regenerated:`, fieldData[currentField][index]);
    }, 2000);
  } else {
    console.error(`‚ùå Tile element not found in DOM for index ${index}`);
    console.log("Available tiles:", gridEl.querySelectorAll('[data-idx]').length);
  }
  updateUI();
};

// Quick test: destroy first 5 tiles
window.testAll = function() {
  for(let i = 0; i < 5; i++) {
    setTimeout(() => testDestroyTile(i), i * 500);
  }
};

// Developer command para a√±adir honey
window.addHoney = function(amount = 1000) {
  stats.honey += amount;
  stats.totalHoney += amount;
  saveGame();
  updateUI();
  console.log(`‚úì A√±adidas ${amount} miel. Total: ${stats.honey}`);
};

</script>
</body>
</html>
