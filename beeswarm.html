<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>G</title>

<style>
*{box-sizing:border-box}
:root{--bee-slot-size:60px}
body{
margin:0;
background:#141414;
font-family:Arial,sans-serif;
color:white;
display:flex;
justify-content:center;
align-items:center;
height:100vh;
overflow:hidden;
}
.game{
display:flex;
gap:18px;
background:#000000;
padding:18px;
border-radius:0px;
align-items:flex-start;
}

/* FIELD LIST */
.field-panel{width:220px;background:#000000;padding:8px;border-radius:0px;max-height:80vh;overflow-y:auto}
.field-panel{position:absolute;left:18px;top:18px;display:none;z-index:1200;box-shadow:0 10px 30px rgba(0, 0, 0, 0.7)}
.field-panel.open{display:block}
.field-panel::-webkit-scrollbar{width:8px}
.field-panel::-webkit-scrollbar-thumb{background:#0c0808;border-radius:0px}
.field-item{padding:6px;margin-bottom:8px;background:#1d1d1d;border-radius:0px;cursor:pointer;font-size:13px;display:flex;align-items:center;justify-content:space-between;gap:8px}
.field-item img{width:36px;height:28px;object-fit:cover;margin-right:8px;border-radius:0px}
.field-item .left{display:flex;align-items:center;gap:8px;flex:1}
.field-item .name{flex:1}
.field-item .req-bees{margin-left:8px;color:#ffffff;font-weight:bold}
.field-item.locked{opacity:0.5;cursor:not-allowed}
.field-item.active{background:#f1c40f;color:black;font-weight:bold}

/* CENTER */
.center{width:650x;display:flex;flex-direction:column}
.stats{display:flex;gap:80px;margin-bottom:10px}
.stat{flex:1;background:#0f0f0f;padding:6px;border-radius:0px;text-align:center;font-size:12px;font-weight:bold;}
.field{background:#0f0f0f;padding:12px;border-radius:0px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.6);border:1px solid #181818}
.field .field-title{position:absolute;left:12px;top:6px;font-size:13px;color:#ffffff}
.grid{display:grid;grid-template-columns:repeat(30,24px);gap:0px;justify-content:center;width:fit-content;height:fit-content}
.grid{background:linear-gradient(180deg,#071214,transparent);padding:6px;border-radius:0px;position:relative}
.tile{width:24px;height:24px;background:#1b8a3c;cursor:pointer;position:relative;overflow:visible}
.tile.transparent{background:#2b8f3d;border:2px solid #00000018;opacity:1}
.tile.transparent img{display:none}
.tile img{width:100%;height:100%;pointer-events:none}

/* Fire effect overlay */
.tile.fire-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid #FF4500;
  box-shadow:0 0 6px #FF4500, inset 0 0 4px rgba(255,69,0,0.5);
  pointer-events:none;
  z-index:10;
  animation:fire-pulse 0.6s ease-in-out infinite;
  border-radius:0px;
}
@keyframes fire-pulse{
  0%,100%{box-shadow:0 0 6px #FF4500, inset 0 0 4px rgba(255,69,0,0.5)}
  50%{box-shadow:0 0 12px #FF6347, inset 0 0 8px rgba(255,99,71,0.7)}
}

/* Dark fire effect overlay */
.tile.dark-fire-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid;
  border-image:linear-gradient(135deg, #4a0080, #7d3c98, #a855c2, #d946ef) 1;
  box-shadow:
    0 0 8px rgba(125,60,152,0.8),
    0 0 12px rgba(168,85,194,0.6),
    inset 0 0 6px rgba(217,70,239,0.3);
  pointer-events:none;
  z-index:10;
  animation:dark-fire-pulse 0.7s ease-in-out infinite;
  border-radius:0px;
}
@keyframes dark-fire-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(125,60,152,0.8),
    0 0 12px rgba(168,85,194,0.6),
    inset 0 0 6px rgba(217,70,239,0.3)}
  50%{box-shadow:
    0 0 12px rgba(125,60,152,1),
    0 0 18px rgba(168,85,194,0.8),
    inset 0 0 10px rgba(217,70,239,0.5)}
}

/* Bubble effect overlay */
.tile.bubble-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid #3498DB;
  box-shadow:0 0 8px #3498DB, inset 0 0 4px rgba(52,152,219,0.5);
  pointer-events:none;
  z-index:10;
  animation:bubble-pulse 0.5s ease-in-out infinite;
  border-radius:0px;
}
@keyframes bubble-pulse{
  0%,100%{box-shadow:0 0 8px #3498DB, inset 0 0 4px rgba(52,152,219,0.5)}
  50%{box-shadow:0 0 14px #5DADE2, inset 0 0 8px rgba(93,173,226,0.7)}
}

/* Goo effect overlay */
.tile.goo-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid;
  box-shadow:
    0 0 8px rgba(255,105,180,0.7),
    0 0 12px rgba(57,255,20,0.5),
    inset 0 0 6px rgba(157,78,221,0.3);
  pointer-events:none;
  z-index:10;
  animation:goo-pulse 0.8s ease-in-out infinite, goo-color-shift 3s ease-in-out infinite;
  border-radius:0px;
}
@keyframes goo-color-shift{
  0%{border-color:#FF69B4}
  33%{border-color:#39FF14}
  66%{border-color:#9D4EDD}
  100%{border-color:#FF69B4}
}
@keyframes goo-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(255,105,180,0.7),
    0 0 12px rgba(57,255,20,0.5),
    inset 0 0 6px rgba(157,78,221,0.3)}
  50%{box-shadow:
    0 0 12px rgba(255,105,180,0.9),
    0 0 16px rgba(57,255,20,0.7),
    inset 0 0 10px rgba(157,78,221,0.5)}
}

/* Energy effect overlay */
.tile.energy-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:3px solid;
  border-image:linear-gradient(135deg, #4169E1, #00BFFF, #1E90FF, #4169E1) 1;
  box-shadow:
    0 0 8px rgba(65,105,225,0.8),
    0 0 12px rgba(0,191,255,0.6),
    inset 0 0 6px rgba(30,144,255,0.3);
  pointer-events:none;
  z-index:10;
  animation:energy-pulse 0.7s ease-in-out infinite;
}
@keyframes energy-pulse{
  0%,100%{box-shadow:
    0 0 8px rgba(65,105,225,0.8),
    0 0 12px rgba(0,191,255,0.6),
    inset 0 0 6px rgba(30,144,255,0.3)}
  50%{box-shadow:
    0 0 12px rgba(65,105,225,1),
    0 0 16px rgba(0,191,255,0.8),
    inset 0 0 10px rgba(30,144,255,0.5)}
}

/* Photon Bee effect */
@keyframes photonGlow{
  0%,100%{
    box-shadow: 0 0 8px rgba(255,215,0,0.6), inset 0 0 4px rgba(255,215,0,0.3);
  }
  50%{
    box-shadow: 0 0 16px rgba(255,215,0,1), inset 0 0 8px rgba(255,215,0,0.6);
  }
}

/* CRIMSON BUFF EFFECT */
.tile.crimson-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid #DC143C;
  box-shadow:
    0 0 10px rgba(220,20,60,0.8),
    0 0 16px rgba(220,20,60,0.6),
    inset 0 0 6px rgba(220,20,60,0.4);
  pointer-events:none;
  z-index:10;
  animation:crimson-glow 0.9s ease-in-out infinite;
  border-radius:0px;
}
@keyframes crimson-glow{
  0%,100%{
    box-shadow:
      0 0 10px rgba(220,20,60,0.8),
      0 0 16px rgba(220,20,60,0.6),
      inset 0 0 6px rgba(220,20,60,0.4);
  }
  50%{
    box-shadow:
      0 0 16px rgba(220,20,60,1),
      0 0 24px rgba(220,20,60,0.8),
      inset 0 0 10px rgba(220,20,60,0.6);
  }
}

/* ENHANCED GOO BUFF EFFECT */
.tile.enhanced-goo-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid;
  border-image:linear-gradient(135deg, #FF1493, #00FF7F, #FF1493) 1;
  box-shadow:
    0 0 12px rgba(255,20,147,0.8),
    0 0 16px rgba(0,255,127,0.6),
    inset 0 0 8px rgba(255,20,147,0.4);
  pointer-events:none;
  z-index:10;
  animation:enhanced-goo-pulse 0.7s ease-in-out infinite;
  border-radius:0px;
}
@keyframes enhanced-goo-pulse{
  0%,100%{
    box-shadow:
      0 0 12px rgba(255,20,147,0.8),
      0 0 16px rgba(0,255,127,0.6),
      inset 0 0 8px rgba(255,20,147,0.4);
  }
  50%{
    box-shadow:
      0 0 18px rgba(255,20,147,1),
      0 0 24px rgba(0,255,127,0.8),
      inset 0 0 12px rgba(255,20,147,0.6);
  }
}

.tile.enhanced-goo-effect::after{
  content:'';
  position:absolute;
  top:50%;left:50%;
  width:100%;height:100%;
  transform:translate(-50%,-50%);
  background:radial-gradient(circle, rgba(255,20,147,0.3), transparent);
  pointer-events:none;
  animation:enhanced-goo-sparkle 1.2s ease-in-out infinite;
}
@keyframes enhanced-goo-sparkle{
  0%,100%{
    opacity:0.4;
    transform:translate(-50%,-50%) scale(1);
  }
  50%{
    opacity:0.8;
    transform:translate(-50%,-50%) scale(1.2);
  }
}

/* Particle effect animation */
@keyframes particle-drift{
  0%{
    transform: translate(0, 0);
    opacity: 1;
  }
  100%{
    transform: translate(var(--drift-x), var(--drift-y));
    opacity: 0;
  }
}

/* CRITICAL ERROR BUFF EFFECT */
.tile.critical-error-effect::before{
  content:'';
  position:absolute;
  top:0px;right:0px;bottom:0px;left:0px;
  border:2px solid #1a1a1a;
  box-shadow:
    0 0 0 0 rgba(0,0,0,1),
    inset 0 0 8px rgba(0,0,0,0.8);
  pointer-events:none;
  animation:critical-error-glitch 0.4s ease-in-out infinite;
  border-radius:0px;
}

@keyframes critical-error-glitch{
  0%{
    border-color:#1a1a1a;
    box-shadow:
      0 0 12px rgba(0,0,0,0.9),
      inset 0 0 8px rgba(0,0,0,0.8);
  }
  33%{
    border-color:#DC143C;
    box-shadow:
      0 0 16px rgba(220,20,60,0.9),
      inset 0 0 10px rgba(220,20,60,0.6);
  }
  66%{
    border-color:#9D4EDD;
    box-shadow:
      0 0 16px rgba(157,78,221,0.9),
      inset 0 0 10px rgba(157,78,221,0.6);
  }
  100%{
    border-color:#1a1a1a;
    box-shadow:
      0 0 12px rgba(0,0,0,0.9),
      inset 0 0 8px rgba(0,0,0,0.8);
  }
}

.bee-grid{
  display:grid;
  grid-template-columns:repeat(5,var(--bee-slot-size));
  gap:6px;
  margin-top:12px;
  justify-content:flex-start;
  padding:8px;
  background:rgba(255,255,255,0.02);
  border-radius:0px;
  border:1px solid rgba(255,215,0,0.08);
}
.bee-slot{
  width:var(--bee-slot-size);
  height:var(--bee-slot-size);
  border-radius:0px;
  cursor:pointer;
  border:2px solid #333;
  background:#151515;
  position:relative;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:14px;
  font-weight:bold;
  transition:all 0.15s ease-in-out;
  box-shadow:0 2px 4px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
}
.bee-slot img{
  width:100%;
  height:100%;
  object-fit:cover;
}
.bee-slot:hover{
  border-color:#f1c40f;
  transform:scale(1.08);
  box-shadow:0 4px 12px rgba(241,196,15,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
}

.tool-pattern{
  display:inline-block;
}
.tool-pattern .row{
  display:flex;
}
.tool-pattern span{
  width:10px;
  height:10px;
  margin:1px;
  background:#333;
}
.tool-pattern .on{
  background:#f1c40f;
}

/* tool-grid cells */
.tool-grid{display:grid;grid-template-columns:repeat(9,12px);grid-auto-rows:12px;gap:3px}
.tool-grid .cell{width:12px;height:12px;background:#2a2a2a;border-radius:0px}
.tool-grid .cell.on{background:#f1c40f}

/* Tool frame layout (taller so price is below the pattern) */
.tool-frame{display:grid;grid-template-columns:1fr 90px;grid-template-rows:auto auto auto auto auto;gap:10px;align-items:start;padding:16px;border-radius:0px;background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);border:1px solid rgba(255,215,0,0.1);min-height:auto;box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05)}
.tool-top{grid-column:1/3;grid-row:1/2}
.tool-name{font-weight:bold;color:#f1c40f;font-size:14px;margin-bottom:4px}
.tool-desc{font-size:12px;color:#ccc;margin-top:2px;line-height:1.4}
.tool-stats{grid-column:1/3;grid-row:2/3;list-style:none;padding-left:12px;color:#ddd;font-size:11px;margin:4px 0;display:flex;flex-direction:column;gap:2px}
.tool-stats li{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}
.tool-pattern{grid-column:1/3;grid-row:3/4;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:8px;background:rgba(0,0,0,0.2);border-radius:0px}
.tool-bottom{grid-column:1/3;grid-row:4/5;display:flex;justify-content:space-between;align-items:flex-end;gap:10px;margin-top:4px;flex-wrap:wrap}
.tool-bottom .price-label{margin-right:4px;align-self:flex-end;font-size:11px}
.tool-price-wrap{grid-column:1/3;grid-row:5/6;display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap}

/* make upgrade frames match tool-frame layout */
.upgrade-frame{display:grid;grid-template-columns:1fr 96px;grid-template-rows:auto 1fr auto auto;gap:8px;align-items:start;padding:12px;border-radius:0px;background:#262626;border:1px solid rgba(255,255,255,0.03);min-height:140px;transition:all 0.3s ease-out}
.upgrade-top{grid-column:1/2;grid-row:1/2}
.upgrade-desc{font-size:12px;color:#ccc;margin-top:4px}
.upgrade-bottom{grid-column:1/3;grid-row:3/4;display:flex;justify-content:space-between;align-items:flex-end;margin-top:6px;padding-bottom:6px}
.upgrade-price-wrap{grid-column:1/3;grid-row:4/5;display:flex;justify-content:flex-end;margin-top:8px}

/* nicer scrollbars for panels */
.section::-webkit-scrollbar, .field-panel::-webkit-scrollbar, .player-stats-panel::-webkit-scrollbar, .hive-panel::-webkit-scrollbar{width:8px;height:8px}
.section::-webkit-scrollbar-track, .field-panel::-webkit-scrollbar-track, .player-stats-panel::-webkit-scrollbar-track, .hive-panel::-webkit-scrollbar-track{background:#1a1a1a;border-radius:0px}
.section::-webkit-scrollbar-thumb, .field-panel::-webkit-scrollbar-thumb, .player-stats-panel::-webkit-scrollbar-thumb, .hive-panel::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#333,#555);border-radius:0px}
.section::-webkit-scrollbar-thumb:hover, .field-panel::-webkit-scrollbar-thumb:hover, .player-stats-panel::-webkit-scrollbar-thumb:hover, .hive-panel::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,#444,#666)}

/* FLOATING */
.floating{
position:absolute;
font-weight:bold;
pointer-events:none;
animation:float 1.2s ease-out forwards;
}
@keyframes float{
to{opacity:0;transform:translate(var(--x),-35px) rotate(var(--r))}
}

@keyframes particle-burst{
to{
  opacity:0;
  transform:translate(var(--px), var(--py)) scale(0);
}
}

@keyframes starGrow{
0%{
  transform:scale(0);
  opacity:0;
}
50%{
  transform:scale(1.2);
}
100%{
  transform:scale(1);
  opacity:1;
}
}

@keyframes starParticle{
0%{
  opacity:1;
  transform:translate(0,-0px) scale(1);
}
100%{
  opacity:0;
  transform:translate(var(--px), var(--py)) scale(0.3);
}
}

/* SHOP */
.shop{
width:450px;
border-radius:0px;
padding:12px;
display:flex;
flex-direction:column;
box-shadow:0 8px 24px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);
position:relative;
border:1px solid rgba(85, 85, 85, 0.432);
}

.hive-panel{
  margin-bottom:12px;
  padding:12px;
  border-radius:0px;
  border:1px solid rgba(109, 109, 109, 0.274);
  overflow-x:hidden;
  box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
}
.hive-panel{max-height:calc(var(--bee-slot-size)*3 + 48px);overflow-y:auto}
.hive-panel .bee-grid{grid-template-columns:repeat(10,var(--bee-slot-size));grid-auto-rows:var(--bee-slot-size);justify-items:stretch}
.bee-slot img{width:100%;height:100%;object-fit:cover}
.shop-tabs{
display:flex;
gap:3px;
margin-bottom:6px;
flex-wrap:nowrap;
justify-content:space-between;
align-items:center;
}
.shop-tabs button{
flex:1;
cursor:pointer;
min-width:65px;
padding:8px 10px;
font-size:13px;
white-space:nowrap;
border-radius:0px;
border:1px solid rgba(100, 100, 100, 0.411);
color:#ffffff;
font-weight:500;
transition:all 0.3s ease;
}
.shop-tabs button:hover{
border-color:rgba(255,215,0,0.4);
box-shadow:0 4px 12px rgba(255,215,0,0.1);
}
.section{
  display:none;
  max-height:500px;
  overflow-y:auto;
  padding:12px;
  border-radius:0px;
  margin-bottom:8px;
}
.section.active{display:block}

.section::-webkit-scrollbar{
  width:5px;
}
.section::-webkit-scrollbar-thumb{
  background:#444;
  border-radius:0px;
}


/* UPGRADE */
.upgrade-frame{
background:linear-gradient(135deg, #1f1f1f 0%, #1a1a1a 100%);
padding:14px;
border-radius:0px;
margin-bottom:10px;
position:relative;
min-height:90px;
border:1px solid rgba(56, 56, 56, 0.514);
box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
transition:all 0.3s ease;
}
.upgrade-frame img{
position:absolute;
top:8px;
right:8px;
width:50px;
height:50px;
}
.upgrade-frame button{
width:100%;
margin-top:8px;
}

/* PLAYER STATS */
.player-stats-panel{
width:350px;
border-radius:0px;
padding:16px;
font-size:13px;
max-height:560px;
overflow-y:auto;
box-shadow:0 8px 24px rgba(0,0,0,0.7), inset 0 1px 0 rgba(73, 73, 73, 0.1);
border:1px solid rgba(94, 94, 94, 0.363);
}
.player-stats-panel::-webkit-scrollbar {
  width: 6px;
}
.player-stats-panel::-webkit-scrollbar-track {
  background: #1a1a1a;
  border-radius: 0px;
}
.player-stats-panel::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 0px;
}
.player-stats-panel::-webkit-scrollbar-thumb:hover {
  background: #777;
}
.player-stats-panel h3{
margin:0 0 8px 0;
text-align:center;
font-size:14px;
}
.player-stat{
display:flex;
justify-content:space-between;
margin-bottom:6px;
}
.player-stat span:last-child{
font-weight:bold;
}
.small-btn{background:#202020;color:#ffffff;border:1px solid #333;padding:4px 6px;border-radius:0px;cursor:pointer}
.small-btn{padding:6px 10px;font-size:11px;border-radius:0px;background:linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);border:1px solid rgba(68, 68, 68, 0.432);transition:all 0.3s ease;font-weight:500}
.small-btn:hover{background:linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);border-color:rgba(80, 80, 80, 0.582)}

/* Button state styles */
.small-btn.btn-can-afford{background:linear-gradient(135deg, #50a373 0%, #32ad7a 100%);border-color:rgba(76,175,80,0.6);color:#fff}
.small-btn.btn-can-afford:hover{background:linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);box-shadow:0 0 10px rgba(76,175,80,0.4)}

.small-btn.btn-cannot-afford{background:linear-gradient(135deg, #333333 0%, #555454 100%);border-color:rgba(149,165,166,0.4);color:#bdc3c7;cursor:not-allowed}
.small-btn.btn-cannot-afford:hover{background:linear-gradient(135deg, #4b4b4b 0%, #434444 100%)}

.small-btn.btn-purchased{background:linear-gradient(135deg, #3498db 0%, #2980b9 100%);border-color:rgba(52,152,219,0.6);color:#fff}
.small-btn.btn-purchased:hover{background:linear-gradient(135deg, #5dade2 0%, #3498db 100%);box-shadow:0 0 12px rgba(52,152,219,0.4)}

.small-btn.btn-equipped{background:linear-gradient(135deg, #cc953c 0%, #e67e22 100%);border-color:rgba(243,156,18,0.6);color:#fff}
.small-btn.btn-equipped:hover{background:linear-gradient(135deg, #d19b43 0%, #d37f36 100%);box-shadow:0 0 10px rgba(230, 162, 54, 0.4)}
.small-btn.btn-equipped:disabled{opacity:1;cursor:default}

.small-btn.btn-max-level{background:linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);border-color:rgba(155,89,182,0.6);color:#fff}
.small-btn.btn-max-level:hover{background:linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);box-shadow:0 0 12px rgba(155,89,182,0.4)}

.shop-tabs button.active-tab{background:linear-gradient(135deg, #bbab51, #8d6825);color:#111;font-weight:bold;box-shadow:0 6px 10px rgba(255,215,0,0.3);border-color:rgba(131, 123, 81, 0.8)}

/* Convert button active honey gradient and drop particles */
.convert-active{background:linear-gradient(180deg,#f7c948,#f1a12d);color:#ffffff;border-color:#e07b00;box-shadow:0 6px 18px rgba(240,180,60,0.12) !important}
@keyframes honey-drop-fall{0%{transform:translateY(0);opacity:1}100%{transform:translateY(80px);opacity:0}}
.honey-drop{width:6px;height:12px;border-radius:0px;position:fixed;pointer-events:none;background:linear-gradient(180deg,#ffd166,#f39c12);box-shadow:0 2px 6px rgba(0,0,0,0.3);animation:honey-drop-fall 800ms linear forwards}

/* Egg / Tool frame visuals */
.egg-frame{padding:10px;border-radius:0px;background:#222;border:1px solid rgba(255,255,255,0.03);position:relative;overflow:hidden}
.egg-frame .egg-art{position:absolute;right:8px;top:8px;width:80px;height:80px}
.egg-frame .prob-list{margin-top:8px;color:#ddd;font-size:12px;padding-left:14px}
.egg-frame .prob-list li{margin:2px 0}
.egg-frame .egg-art img{animation:egg-swing 2.6s ease-in-out infinite;transform-origin:center center}
@keyframes egg-swing{0%{transform:rotate(-5deg)}50%{transform:rotate(5deg)}100%{transform:rotate(-5deg)}}
/* Mythic egg pulsing purple glow */
@keyframes mythic-glow{0%{box-shadow:0 0 6px #7b1fa2}50%{box-shadow:0 0 18px #9b59b6}100%{box-shadow:0 0 6px #7b1fa2}}
.egg-frame.mythic-egg{animation:mythic-glow 3s ease-in-out infinite;border:1px solid #632d7a}

/* Bee details swing animation */
@keyframes bee-swing{0%{transform:rotate(-2deg)}50%{transform:rotate(2deg)}100%{transform:rotate(-2deg)}}
.bee-details-panel{animation:bee-swing 2.8s ease-in-out infinite;transform-origin:center top;background: #2222;border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:0px;position:relative;overflow:hidden;box-shadow:0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05)}
.bee-details-panel.ultimate-bee{animation:ultimate-pulse 2s ease-in-out infinite, ultimate-rotate 2.4s ease-in-out infinite;border:3px solid #FF00FF !important;background:linear-gradient(135deg, #FFD700 0%, #FF1493 25%, #00FF00 50%, #00BFFF 75%, #FF00FF 100%) !important;box-shadow:0 0 20px rgba(255, 0, 255, 0.8), 0 0 30px rgba(136, 24, 24, 0.6) !important}

/* Bee catalog frame */
.bee-catalog-frame{display:flex;flex-direction:row;gap:12px;align-items:flex-start;padding:16px;border-radius:0px;margin-bottom:12px;transition:all 0.3s;width:100%;box-sizing:border-box;background:linear-gradient(135deg, rgba(255,235,59,0.08) 0%, rgba(255,107,107,0.08) 50%, rgba(76,175,80,0.08) 100%);border:2px solid;box-shadow:0 0 12px rgba(255, 107, 107, 0.2);text-align:left;cursor:pointer;position:relative;min-height:120px}
.bee-catalog-frame:hover{background:linear-gradient(135deg, rgba(255,235,59,0.15) 0%, rgba(255,107,107,0.15) 50%, rgba(76,175,80,0.15) 100%);box-shadow:0 0 20px rgba(255, 107, 107, 0.4), inset 0 0 8px rgba(255, 215, 0, 0.1);transform:translateX(2px)}

/* Particles inside art containers */
.egg-art{position:relative;animation:egg-swing 2.6s ease-in-out infinite;transform-origin:center center;display:block}
.egg-art .particle{width:4px;height:4px;border-radius:0px;position:absolute;opacity:0.95;animation:particle-float 1600ms linear infinite}
@keyframes particle-float{0%{transform:translate(0,0);opacity:1}100%{transform:translate(var(--px,0px),var(--py,0px));opacity:0}}

@keyframes mythic-pulse{0%{box-shadow:0 0 6px rgba(155,89,182,0.45)}50%{box-shadow:0 0 20px rgba(155,89,182,0.75)}100%{box-shadow:0 0 6px rgba(155,89,182,0.45)}}

@keyframes reward-unlock{0%{transform:scale(0.8);opacity:0}50%{transform:scale(1.1)}100%{transform:scale(1);opacity:1}}
@keyframes reward-claim{0%{transform:translateY(0)}50%{transform:translateY(-8px);opacity:1}100%{transform:translateY(0);opacity:0.5}}

@keyframes color-shift{
  0%{color:#ff0000;text-shadow:0 0 8px #ff0000}
  25%{color:#ff6600;text-shadow:0 0 10px #ff6600}
  50%{color:#ffff00;text-shadow:0 0 8px #ffff00}
  75%{color:#ff0066;text-shadow:0 0 10px #ff0066}
  100%{color:#ff0000;text-shadow:0 0 8px #ff0000}
}

@keyframes rainbow-frame-glow{
  0%{box-shadow:0 0 15px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 107, 107, 0.3), inset 0 0 8px rgba(255, 215, 0, 0.1)}
  25%{box-shadow:0 0 20px rgba(255, 107, 107, 0.6), 0 0 40px rgba(0, 255, 0, 0.3), inset 0 0 10px rgba(255, 107, 107, 0.2)}
  50%{box-shadow:0 0 20px rgba(0, 255, 0, 0.6), 0 0 40px rgba(0, 191, 255, 0.3), inset 0 0 10px rgba(0, 255, 0, 0.2)}
  75%{box-shadow:0 0 20px rgba(0, 191, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(0, 191, 255, 0.2)}
  100%{box-shadow:0 0 15px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 107, 107, 0.3), inset 0 0 8px rgba(255, 215, 0, 0.1)}
}

@keyframes super-critical-color{
  0%{color:#ff0000;text-shadow:0 0 15px #ff0000, 0 0 30px #ff0000}
  50%{color:#ffff00;text-shadow:0 0 15px #ffff00, 0 0 30px #ff8800}
  100%{color:#ff0000;text-shadow:0 0 15px #ff0000, 0 0 30px #ff0000}
}

@keyframes super-critical-rotate{
  0%{transform:rotate(5deg)}
  50%{transform:rotate(-5deg)}
  100%{transform:rotate(5deg)}
}

@keyframes super-critical-float{
  0%{transform:translateY(0) translateX(0) scale(1);opacity:1}
  50%{transform:translateY(-60px) translateX(var(--x,0px)) scale(1.1);opacity:1}
  100%{transform:translateY(-120px) translateX(var(--x,0px)) scale(0.8);opacity:0}
}
.super-critical-float{display:grid;grid-template-columns:repeat(auto-fill, minmax(250px, 1fr));gap:8px;padding:4px;width:100%}

.rarity-title-container{display:flex;gap:12px;align-items:center;margin:14px 0 10px 0;justify-content:space-between}
.rarity-toggle-btn{background:#333;border:1px solid #555;color:#f1c40f;cursor:pointer;padding:4px 8px;font-size:12px;font-weight:bold;border-radius:0px;transition:all 0.2s;min-width:30px}
.rarity-toggle-btn:hover{background:#444;border-color:#f1c40f}
.rarity-toggle-btn.collapsed{background:#555;color:#999}
@keyframes slideUp{0%{max-height:500px;opacity:1}100%{max-height:0;opacity:0}}
@keyframes slideDown{0%{max-height:0;opacity:0}100%{max-height:500px;opacity:1}}
.rarity-frames-container{transition:max-height 0.4s ease-in-out;display:grid;grid-template-columns:repeat(auto-fill, minmax(250px, 1fr));gap:8px;padding:4px;width:100%}
.rarity-frames-container.collapsing{animation:slideUp 0.4s ease-in-out forwards}
.rarity-frames-container.expanding{animation:slideDown 0.4s ease-in-out forwards}

/* Tutorial Modal */
.tutorial-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:3500;animation:fadeIn 0.3s ease-in-out}
.tutorial-modal{background:linear-gradient(135deg, #1a1a1a, #0d0d0d);border:2px solid #252525;border-radius:0px;padding:30px;max-width:600px;max-height:80vh;overflow-y:auto;position:relative;box-shadow:0 0 40px rgba(0, 0, 0, 0.863);animation:zoomIn 0.3s ease-in-out}
.tutorial-modal::-webkit-scrollbar{width:6px}
.tutorial-modal::-webkit-scrollbar-track{background:#1a1a1a}
.tutorial-modal::-webkit-scrollbar-thumb{background:#3a3a3a;border-radius:0px}
.tutorial-modal img{width:100%;height:auto;margin-bottom:20px;border:1px solid #46464500;border-radius:0px;max-height:300px;object-fit:contain}
.tutorial-modal h2{color:#ffe031;font-size:24px;margin:0 0 15px 0;text-transform:uppercase}
.tutorial-modal p{color:#ddd;font-size:14px;line-height:1.6;margin-bottom:12px}
.tutorial-modal ul{color:#ddd;font-size:14px;line-height:1.8;margin-left:20px;margin-bottom:12px}
.tutorial-modal li{margin-bottom:8px}
.tutorial-nav{display:flex;justify-content:space-between;align-items:center;margin-top:20px;padding-top:15px;border-top:1px solid rgba(255, 255, 255, 0.2)}
.tutorial-nav button{background:#646464;color:#000000;border:none;padding:8px 16px;font-weight:bold;cursor:pointer;border-radius:0px;transition:all 0.2s;font-size:12px}
.tutorial-nav button:hover{background:#FFD700;box-shadow:0 0 10px rgba(255,215,0,0.5)}
.tutorial-nav button:disabled{background:#2c2c2c;color:#3d3d3d;cursor:not-allowed;box-shadow:none}
.tutorial-counter{color:#ffffff9c;font-weight:bold;font-size:12px}
@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}
@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}
@keyframes zoomIn{0%{opacity:0;transform:scale(0.9)}100%{opacity:1;transform:scale(1)}}

/* Question mark button */
.question-btn{position:fixed;top:10px;left:10px;width:36px;height:36px;background: #9b4646;border:3px solid #ffffff;border-radius:0;color:#111;font-size:24px;font-weight:bold;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s;box-shadow:0 0 10px rgba(0, 0, 0, 0.3);z-index:9999}
.question-btn:hover{box-shadow:0 0 20px rgba(224, 90, 90, 0.6);transform:scale(1.1)}
.question-btn:active{transform:scale(0.95)}

/* Mythic bee no longer has special styling - only ultimate bees have border */

/* Bee details scroll container */
.bee-details-scroll{max-height:400px;overflow-y:auto;padding-right:8px}
.bee-details-scroll::-webkit-scrollbar{width:8px}
.bee-details-scroll::-webkit-scrollbar-track{background:rgba(0,0,0,0.3);border-radius:0px}
.bee-details-scroll::-webkit-scrollbar-thumb{border-radius:0px;box-shadow:inset 0 0 4px rgba(0,0,0,0.5)}

@keyframes special-pulse{0%{box-shadow:0 0 8px rgba(76,175,80,0.6), inset 0 0 4px rgba(76,175,80,0.3)}50%{box-shadow:0 0 24px rgba(76,175,80,0.9), inset 0 0 8px rgba(76,175,80,0.5)}100%{box-shadow:0 0 8px rgba(76,175,80,0.6), inset 0 0 4px rgba(76,175,80,0.3)}}
.bee-slot.special-bee{
  animation:special-pulse 2.2s ease-in-out infinite;
  border:3px solid #4CAF50;
  background:linear-gradient(90deg,rgba(76,175,80,0.15),transparent,rgba(76,175,80,0.15));
  transform:scale(1.05);
}

/* bee tooltip */
.bee-tooltip{position:fixed;pointer-events:none;background:rgba(20,20,20,1);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:0px;color:#fff;font-size:12px;z-index:2000;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
.bee-tooltip b{color:#f1c40f}
.price-label{color:#f1c40f;font-weight:bold}

/* Abilities grid - REMOVED */
.ability-slot{width:40px;height:40px;min-width:40px;position:relative;cursor:pointer;border:1px solid rgba(255,255,255,0.2);display:flex;align-items:flex-end;justify-content:flex-end;font-size:10px;color:#fff;overflow:visible;transition:filter 0.2s;flex-shrink:0}
.ability-slot.special{border:2px solid #4CAF50;box-shadow:0 0 12px rgba(76,175,80,0.8),0 0 24px rgba(76,175,80,0.4),inset 0 0 8px rgba(76,175,80,0.3)}
.ability-slot img{width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;z-index:1}
.ability-cooldown{position:absolute;bottom:2px;right:2px;font-size:10px;font-weight:bold;background:rgba(0,0,0,0.8);padding:1px 2px;color:#fff;z-index:20}
.ability-tooltip{position:fixed;background:rgba(20,20,20,0.95);border:1px solid rgba(255,215,0,0.2);padding:10px;border-radius:0px;color:#fff;font-size:11px;z-index:2100;box-shadow:0 6px 18px rgba(0,0,0,0.8);pointer-events:none;max-width:200px;white-space:normal}

/* NOTIFICATION SYSTEM */
.notifications-container{position:fixed;bottom:20px;right:20px;display:flex;flex-direction:column;gap:8px;z-index:3000;max-width:300px}
.notification{background:linear-gradient(135deg, #262626 0%, #1a1a1a 100%);border:1px solid rgba(255,215,0,0.2);padding:12px 16px;border-radius:0px;color:#fff;font-size:13px;box-shadow:0 4px 12px rgba(0,0,0,0.5);animation:slideInNotif 0.3s ease-out forwards;min-height:40px;display:flex;align-items:center}
.notification.success{border-color:rgba(76,175,80,0.4);color:#4CAF50}
.notification.error{border-color:rgba(244,67,54,0.4);color:#F44336}
.notification.warning{border-color:rgba(255,193,7,0.4);color:#FFD700}
.notification.info{border-color:rgba(33,150,243,0.4);color:#2196F3}
@keyframes slideInNotif{from{opacity:0;transform:translateX(100%)}to{opacity:1;transform:translateX(0)}}
@keyframes slideOutNotif{from{opacity:1;transform:translateX(0)}to{opacity:0;transform:translateX(100%)}}
.notification.removing{animation:slideOutNotif 0.3s ease-out forwards}

/* ULTIMATE RARITY ANIMATION */
@keyframes rainbow-text{
  0%{color:#ff0000}
  8%{color:#ff7f00}
  16%{color:#ffff00}
  25%{color:#00ff00}
  33%{color:#00ff7f}
  42%{color:#0000ff}
  50%{color:#4b0082}
  58%{color:#9400d3}
  66%{color:#ff0080}
  75%{color:#ff0000}
  83%{color:#ff7f00}
  92%{color:#ffff00}
  100%{color:#ff0000}
}
@keyframes rainbow-glow{
  0%{text-shadow:0 0 12px #ff0000, 0 0 20px #ff0000}
  8%{text-shadow:0 0 12px #ff7f00, 0 0 20px #ff7f00}
  16%{text-shadow:0 0 12px #ffff00, 0 0 20px #ffff00}
  25%{text-shadow:0 0 12px #00ff00, 0 0 20px #00ff00}
  33%{text-shadow:0 0 12px #00ff7f, 0 0 20px #00ff7f}
  42%{text-shadow:0 0 12px #0000ff, 0 0 20px #0000ff}
  50%{text-shadow:0 0 12px #4b0082, 0 0 20px #4b0082}
  58%{text-shadow:0 0 12px #9400d3, 0 0 20px #9400d3}
  66%{text-shadow:0 0 12px #ff0080, 0 0 20px #ff0080}
  75%{text-shadow:0 0 12px #ff0000, 0 0 20px #ff0000}
  83%{text-shadow:0 0 12px #ff7f00, 0 0 20px #ff7f00}
  92%{text-shadow:0 0 12px #ffff00, 0 0 20px #ffff00}
  100%{text-shadow:0 0 12px #ff0000, 0 0 20px #ff0000}
}
.ultimate-name{animation:rainbow-text 5s linear infinite,rainbow-glow 5s linear infinite}

/* ULTIMATE RARITY ANIMATION (LEVEL 6 - Ultimate Tier) */
@keyframes ultimate-border-glow{
  0%{border-color:#FF00FF;box-shadow:0 0 12px rgba(255,0,255,0.6), 0 0 24px rgba(255,0,255,0.3)}
  50%{border-color:#6a3085;box-shadow:0 0 20px rgba(121, 54, 197, 0.8), 0 0 40px rgba(255,0,255,0.5)}
  100%{border-color:#00ff6a;box-shadow:0 0 12px rgba(32, 161, 97, 0.6), 0 0 24px rgba(255,0,255,0.3)}
}

@keyframes ultimate-pulse{
  0%{box-shadow:0 0 6px rgba(255,0,255,0.45)}
  50%{box-shadow:0 0 20px rgba(255,0,255,0.75), 0 0 20px rgba(255,20,147,0.6)}
  100%{box-shadow:0 0 6px rgba(255,0,255,0.45)}
}

@keyframes ultimate-rotate{
  0%{transform:rotate(-2deg)}
  50%{transform:rotate(2deg)}
  100%{transform:rotate(-2deg)}
}

.catalog-ultimate-bee{
  border: 4px solid #FF00FF !important;
  animation: ultimate-border-glow 2s ease-in-out infinite;
  box-shadow: 0 0 12px rgba(255,0,255,0.6), 0 0 24px rgba(255,0,255,0.3);
}

@keyframes rainbow-border{
  0%{border-color:#ff0000}
  16%{border-color:#ff7f00}
  33%{border-color:#ffff00}
  50%{border-color:#00ff00}
  66%{border-color:#0000ff}
  83%{border-color:#9d4edd}
  100%{border-color:#ff0000}
}

.bee-slot.ultimate-bee{
  animation: ultimate-pulse 2s ease-in-out infinite, ultimate-rotate 2.4s ease-in-out infinite, rainbow-border 5s linear infinite;
  border: 3px solid #FF00FF;
  background: linear-gradient(90deg, rgba(255,0,255,0.1), transparent, rgba(255,0,255,0.1));
}

.rarity-ultimate-title{
  color: #FF00FF;
  animation: rainbow-text 4s linear infinite, rainbow-glow 4s linear infinite;
  font-weight: bold;
  text-shadow: 0 0 12px rgba(255,0,255,0.8);
}
</style>
</head>

<!-- MODULAR CONFIG FILES -->
<script src="configs/bees.js"></script>
<script src="configs/storage.js"></script>
<script src="configs/fields.js"></script>
<script src="configs/tools.js"></script>
<script src="configs/upgrades.js"></script>
<script src="configs/player-stats.js"></script>
<script src="configs/tile-buffs.js"></script>
<script src="configs/rarities.js"></script>

<body>
<div id="notificationsContainer" class="notifications-container"></div>
<div class="game">

<div class="field-panel" id="fieldList"></div>

<div class="center">
  <div style="display:flex;justify-content:flex-start;margin-bottom:8px">
    <button id="toggleFieldListBtn" class="small-btn">Fields List</button>
    <button id="convertBtn" class="small-btn" style="margin-left:8px;">Convert</button>
  </div>
  <div id="currentFieldTitle" style="margin-bottom:8px;text-align:left">
    <div id="fieldName" style="font-weight:bold;color:#ffffff;font-size:14px"></div>
  </div>
  <div id="fieldInfo" style="position:absolute;right:24px;top:18px;text-align:right;color:#ccc;font-size:12px"></div>
<div class="stats">
<div class="stat">
Pollen<br>
<b><span id="pollen">0</span>/<span id="capacity">100</span></b><br>
<small><span id="pollenSec">0</span>/s</small>
</div>
<div class="stat">
Tickets<br>
<b><span id="tickets">0</span></b><br>
<small></small>
</div>
<div class="stat">
Honey<br>
<b><span id="honey">0</span></b><br>
<small><span id="honeySec">0</span>/s</small>
</div>
</div>
<div class="field">
<div class="grid" id="grid">
  <!-- Laser reference guides (invisible) -->
  <svg id="laserGuides" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0">
    <defs>
      <line id="verticalLaserGuide" x1="10" y1="0" x2="10" y2="100%" stroke="transparent" stroke-width="28"/>
      <line id="horizontalLaserGuide" x1="0" y1="10" x2="100%" y2="10" stroke="transparent" stroke-width="28"/>
    </defs>
  </svg>
</div>
<!-- hive panel moved after abilities -->
<div class="hive-panel" style="margin-top:8px;">
  <div id="beeGrid" class="bee-grid"></div>
</div>
</div>
</div>

<div class="shop">
<div class="shop-tabs">
<button class="small-btn" onclick="openShop('upgrades')">Upgrades</button>
<button class="small-btn" onclick="openShop('tools')">Tools</button>
<button class="small-btn" onclick="openShop('storage')">Storage</button>
<button class="small-btn" onclick="openShop('bees')">Bees</button>
<button class="small-btn" onclick="openShop('eggs')">Eggs</button>
</div>
<div id="upgrades" class="section active"></div>
<div id="tools" class="section"></div>
<div id="storage" class="section"></div>
<div id="bees" class="section">Bees coming soon</div>
<div id="eggs" class="section">Eggs coming soon</div>
</div>

<div class="player-stats-panel" id="playerStatsPanel">
  <button class="question-btn" onclick="openTutorial()" title="Game Guide">?</button>
</div>

</div>

<script>
/* ================= SAVE ================= */
const SAVE_KEY="grassSave";

/* ================= FORMAT ================= */
const ABBR=["","K","M","B","T","Qa","Qi","Sx","Sp","Oc","No","Dc"];
function fmt(n){
if(n<1000)return n.toFixed(1);
let e=Math.floor(Math.log10(n)/3);
return (n/10**(e*3)).toFixed(2)+ABBR[e];
}

/* Stats loaded from configs/player-stats.js */
let stats = Object.assign({}, PLAYER_STATS);

/* ABILITY_TYPES loaded from configs/upgrades.js */

let tickets = 0; // Currency for buying special bees
let ticketBeeAbilityTime = 0;
let goldenBeeAbilityTime = 0;
let tileTicketProbBonus = 0; // Bonus to tile ticket spawn chance from Golden Bee

let currentStatsTab = 'stats'; // Track which tab is currently open


let ownedTools=["shovel"];
let equippedToolId="shovel";

let ownedBees=[];
let equippedBees=[];
let discoveredBees=[]; // Array of bee IDs that have been unlocked
let ownedSpecialBees=[]; // Array of special bee IDs that have been purchased
let equippedSpecialBees=[]; // Array of up to 3 special bee IDs that are currently equipped
let claimedRewards={}; // Track which rarity rewards have been claimed

// Confirmation tracking for dangerous actions (mythic/special bee deletion)
let pendingConfirmations = {}; // {key: timestamp} to track single clicks

// Tracking for honey/tickets earned in 30-second windows
let honeyEarned30s = 0;
let ticketsEarned30s = 0;
let honeyLastValue = 0;
let ticketsLastValue = 0;
// Abilities execution tracking
let activeAbilities = []; // Array of {ability, name, color, img, desc, executeTime} for recently executed abilities
let abilityLastState = {}; // Track last cooldown state to detect execution

/* ================= BEE INSTANCE TRACKING ================= */
// Mapea cada bee equipada a un ID Ãºnico para trackear sus habilidades individualmente
// Formato: beeId_instanceIndex (ej: "bee6_0", "bee6_1", "bee20_0")
let beeInstanceTimers = {}; // Mapea beeInstanceId -> {lastAbilityTime: 0, lastAbilityScheduledTime: 0}

function getBeeInstanceId(beeId, instanceIndex) {
  return `${beeId}_${instanceIndex}`;
}

function getBeeInstanceTimer(beeId, instanceIndex) {
  const id = getBeeInstanceId(beeId, instanceIndex);
  if(!beeInstanceTimers[id]) {
    beeInstanceTimers[id] = {lastAbilityTime: 0, lastAbilityScheduledTime: 0};
  }
  return beeInstanceTimers[id];
}

// Particle loops - track active particle generation for tiles
let activeParticleLoops = {}; // Maps tileIndex to {intervalId, config}

// per-field statistics
let fieldStats = {};
let lastFieldEnter = Date.now();

function ensureFieldStats(f){
  if(!fieldStats[f]) fieldStats[f] = {pollenCollected:0, timeSpentSeconds:0, clicks:0};
}

// Storage system
let ownedStorages = [];
let equippedStorageId = null;

/* ================= TOOL ABILITIES TRACKING ================= */
// Grandmaster Porcelain tracking
let grandmasterTilesDestroyed = 0;
let grandmasterActive = false;
let grandmasterEffectStartTime = 0;

// Porcelain Dipper tracking
let porcelainTilesDestroyed = 0;
let porcelainBuffActive = false;
let porcelainBuffStartTime = 0;

/* ================= STORAGE ABILITIES TRACKING ================= */
// Coconut Bag tracking
/* All player state and ability tracking loaded from configs/player-stats.js */
// Initialize player state from config
Object.keys(PLAYER_TRACKING).forEach(key => window[key] = PLAYER_TRACKING[key]);
Object.keys(ABILITY_STATES).forEach(key => window[key] = ABILITY_STATES[key]);
Object.keys(SPECIAL_ABILITY_STATES).forEach(key => window[key] = SPECIAL_ABILITY_STATES[key]);
Object.keys(TILE_UPGRADE_STATES).forEach(key => window[key] = TILE_UPGRADE_STATES[key]);

// Color cycle for animations
const gooColorList = ['#FF69B4', '#39FF14', '#9D4EDD'];

// Track applied bonuses
let currentToolBonuses = {};
let currentStorageBonuses = {};

let equippedTool="Shovel";
let pollenThisSec=0,
honeyThisSec=0,
lastClick=0,
currentField="dandelion",
currentSection="tools";

// Helper function to generate bee image name from bee name
function getBeeImageName(name) {
  const firstWord = name.split(' ')[0].toLowerCase();
  return `bee_${firstWord}.png`;
}

setInterval(()=>{
  pollenThisSec*=0.5;
  honeyThisSec*=0.5;
  
  // Update buff timers
  if(grandmasterBuffTimeLeft > 0) grandmasterBuffTimeLeft--;
  if(porcelainBuffTimeLeft > 0) porcelainBuffTimeLeft--;
  if(coconutBagBuffTimeLeft > 0) coconutBagBuffTimeLeft--;
  
  // Auto-clear ability flags when timers reach 0
  if(grandmasterBuffTimeLeft <= 0 && grandmasterActive) {
    grandmasterActive = false;
    grandmasterBuffTimeLeft = 0;
  }
  if(porcelainBuffTimeLeft <= 0 && porcelainBuffActive) {
    porcelainBuffActive = false;
    porcelainBuffTimeLeft = 0;
  }
  if(coconutBagBuffTimeLeft <= 0 && coconutBagBuffActive) {
    coconutBagBuffActive = false;
    coconutBagBuffTimeLeft = 0;
  }
  
  // Clean up expired buff tiles
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  // Clean Crimson tiles (30 second duration)
  for(const idx in crimsonTilesActive){
    if(crimsonTilesActive[idx] && crimsonTilesActive[idx].createdAt){
      const elapsed = now - crimsonTilesActive[idx].createdAt;
      if(elapsed > 30000){
        delete crimsonTilesActive[idx];
        const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
        if(tileEl) tileEl.classList.remove("crimson-effect");
      }
    }
  }
  
  // Clean Enhanced Goo tiles (30 second duration)
  for(const idx in enhancedGooTiles){
    if(enhancedGooTiles[idx] && enhancedGooTiles[idx].createdAt){
      const elapsed = now - enhancedGooTiles[idx].createdAt;
      if(elapsed > 30000){
        delete enhancedGooTiles[idx];
        const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
        if(tileEl) tileEl.classList.remove("enhanced-goo-effect");
      }
    }
  }
  
  // Clean Critical Error tiles (10 second duration + auto-destroy)
  for(const idx in criticalErrorTiles){
    if(criticalErrorTiles[idx] && criticalErrorTiles[idx].createdAt){
      const elapsed = now - criticalErrorTiles[idx].createdAt;
      if(elapsed > 10000){
        delete criticalErrorTiles[idx];
        const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("critical-error-effect");
          // Auto-destroy the tile
          if(fieldData[currentField] && fieldData[currentField][idx]){
            fieldData[currentField][idx] = null;
            tileEl.style.background = '#1b8a3c';
            tileEl.classList.add('transparent');
            tileEl.innerHTML = '';
          }
        }
      }
    }
  }
  
  updateBeeAbilities(); // Update abilities every second to check Royal Guard buff
  updateUI();
  updatePlayerStatsPanel(); // Update stats panel in real-time
  updateAffordabilityButtons(); // Update buy buttons affordability in real-time
},1000);

// Every 30 seconds, show notifications for honey and tickets earned
setInterval(()=>{
  const honeyChange = stats.totalHoney - honeyLastValue;
  const ticketsChange = tickets - ticketsLastValue;
  
  if(honeyChange > 0) {
    showNotification(`Miel ganada: ${fmt(honeyChange)} ðŸ¯`, 'info');
  }
  if(ticketsChange > 0) {
    showNotification(`Tickets ganados: ${ticketsChange} ðŸŽ«`, 'info');
  }
  
  honeyLastValue = stats.totalHoney;
  ticketsLastValue = tickets;
},30000);

let fieldData={};

/* ================= ADVANCED BUFF & ABILITY SYSTEM ================= */

// Centralized active buffs tracker - tracks all buffs currently applied
let activeBeeBuffs = {}; // {buffType: {source: beeId, value: amount}}
let activeToolBuffs = {}; // {buffType: {source: toolId, value: amount}}
let activeStorageBuffs = {}; // {buffType: {source: storageId, value: amount}}

// Track equipped items to detect changes (avoid recalculating buffs every tick)
let previousEquippedBees = [];
let previousEquippedSpecialBees = [];
let previousEquippedToolId = null;
let previousEquippedStorageId = null;

// Ability execution queue - prevents abilities from interrupting each other
const abilityQueue = {
  pending: [], // [{abilityName, beeId, priority, executeAt}]
  executing: null, // {abilityName, beeId, startTime}
  addAbility(abilityName, beeId, priority = 0) {
    if(!this.pending.find(a => a.abilityName === abilityName && a.beeId === beeId)) {
      this.pending.push({abilityName, beeId, priority, executeAt: Date.now()});
      this.pending.sort((a, b) => b.priority - a.priority);
    }
  },
  processNext() {
    if(this.executing || this.pending.length === 0) return;
    this.executing = this.pending.shift();
    this.executeAbility(this.executing);
  },
  markComplete() {
    this.executing = null;
    this.processNext(); // Auto-process next in queue
  },
  executeAbility(abilityData) {
    const {abilityName, beeId} = abilityData;
    try {
      // Execute ability by name
      switch(abilityName) {
        case 'fireBeeTick': fireBeeTick(); break;
        case 'spicyBeeTick': spicyBeeTick(); break;
        case 'bubbleBeeTick': bubbleBeeTick(); break;
        case 'demonBeeTick': demonBeeTick(); break;
        case 'laserBeeTick': laserBeeTick(); break;
        case 'thunderBeeTick': thunderBeeTick(); break;
        case 'teslaBeeAbility': teslaBeeAbility(); break;
        case 'ticketBeeAbility': ticketBeeAbility(); break;
        case 'goldenBeeAbility': goldenBeeAbility(); break;
        case 'lionBeeAbility': lionBeeAbility(); break;
        case 'photonBeeAbility': photonBeeAbility(); break;
        case 'digitalBeeAbility': digitalBeeAbility(); break;
        case 'moonBeeAbility': moonBeeAbility(); break;
        case 'fourBeeAbility': fourBeeAbility(); break;
        case 'kingCrimsonBeeTick': kingCrimsonBeeTick(); break;
        case 'crimsonGuardSynergyTick': crimsonGuardSynergyTick(); break;
        case 'gummyBeeTick': gummyBeeTick(); break;
        case 'gooTileSystemTick': gooTileSystemTick(); break;
        case 'lionBeeAutoDestruct': lionBeeAutoDestruct(); break;
      }
    } catch(e) {
      console.error(`Error executing ability ${abilityName}:`, e);
    }
    // Mark as complete immediately (abilities are synchronous)
    this.markComplete();
  }
};

// Tile effects system - allows multiple effects on same tile with proper stacking
const tileEffectsSystem = {
  tileEffects: {}, // {tileIdx: [{type, source, startTime, duration, data}]}
  addEffect(tileIdx, effectType, source, duration, data = {}) {
    if(!this.tileEffects[tileIdx]) this.tileEffects[tileIdx] = [];
    // Check if same effect type from same source exists
    const existing = this.tileEffects[tileIdx].find(e => e.type === effectType && e.source === source);
    if(!existing) {
      this.tileEffects[tileIdx].push({
        type: effectType,
        source: source,
        startTime: Date.now(),
        duration: duration,
        data: data
      });
    }
    return this.tileEffects[tileIdx];
  },
  removeEffect(tileIdx, effectType, source) {
    if(!this.tileEffects[tileIdx]) return;
    this.tileEffects[tileIdx] = this.tileEffects[tileIdx].filter(e => !(e.type === effectType && e.source === source));
  },
  getEffects(tileIdx) {
    return this.tileEffects[tileIdx] || [];
  },
  cleanExpired() {
    const now = Date.now();
    for(const idx in this.tileEffects) {
      this.tileEffects[idx] = this.tileEffects[idx].filter(e => now - e.startTime < e.duration);
      if(this.tileEffects[idx].length === 0) delete this.tileEffects[idx];
    }
  },
  // Clear all effects from a tile
  clearTile(tileIdx) {
    delete this.tileEffects[tileIdx];
  },
  // Clear all effects of a specific type
  clearEffectType(effectType) {
    for(const idx in this.tileEffects) {
      this.tileEffects[idx] = this.tileEffects[idx].filter(e => e.type !== effectType);
      if(this.tileEffects[idx].length === 0) delete this.tileEffects[idx];
    }
  },
  // Clear effects from a specific source
  clearSource(source) {
    for(const idx in this.tileEffects) {
      this.tileEffects[idx] = this.tileEffects[idx].filter(e => e.source !== source);
      if(this.tileEffects[idx].length === 0) delete this.tileEffects[idx];
    }
  }
};

/* All data loaded from config files */

function applyToolPattern(centerIndex, fieldKey){
  const tool = TOOLS.find(t => t.id === equippedToolId);
  if (!tool) return;
  
  const GRID_W = 30;
  const GRID_H = 15;
  const cx = centerIndex % GRID_W;
  const cy = Math.floor(centerIndex / GRID_W);

  const patternSize = tool.pattern.length || 5;
  const centerOff = Math.floor(patternSize / 2);
  const tilesToDestroy = [];

  tool.pattern.forEach((row, py) => {
    row.forEach((cell, px) => {
      if (!cell) return;

      const gx = cx + (px - centerOff);
      const gy = cy + (py - centerOff);
      if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return;

      const idx = gy * GRID_W + gx;
      tilesToDestroy.push(idx);
    });
  });

  let destroyedCount = 0;
  // Optimize: Skip some floating numbers if destroying many tiles at once
  const skipFloatingNumbers = tilesToDestroy.length > 50;
  const floatingNumberFrequency = tilesToDestroy.length > 20 ? Math.ceil(tilesToDestroy.length / 15) : 1;
  
  tilesToDestroy.forEach((idx, destroyIndex) => {
    const tile = fieldData[fieldKey][idx];
    
    if (!tile) return;
    
    // Skip floating numbers to avoid clutter when destroying many tiles
    const shouldSkipFloatingNumber = skipFloatingNumbers && (destroyIndex % floatingNumberFrequency !== 0);

    // Handle empty tiles (ty === 0) - give minimal pollen
    const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
    const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
    
    const totalCritChance = stats.criticalChance + stats.beeCriticalChance;
    let isCritical = Math.random() * 100 < totalCritChance;
    let isSuperCritical = false;
    
    // 3% chance of super critical when there's a critical hit
    if(isCritical && Math.random() * 100 < stats.superCriticalChance){
      isSuperCritical = true;
      isCritical = false; // Super critical replaces normal critical
    }
    
    // Apply buff-based critical chance boosts AFTER initial crit calculation
    let buffCritChance = 0;
    if(crimsonTilesActive[idx]){
      buffCritChance += 20;
    }
    if(enhancedGooTiles[idx]){
      buffCritChance += 30;
    }
    if(criticalErrorTiles[idx]){
      buffCritChance = 100; // Critical Error guarantees a critical hit
    }
    
    // Apply buff critical chances
    if(buffCritChance > 0){
      const adjustedCritChance = Math.min(100, totalCritChance + buffCritChance);
      if(Math.random() * 100 < adjustedCritChance){
        isCritical = true;
        isSuperCritical = false; // Reset super critical if buff triggered crit
      }
    }
    
    const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
    const critMultiplier = isSuperCritical ? 10 : (isCritical ? totalCritPower : 1);
    const finalPollenValue = pollenValue * critMultiplier;
    
    // Track Royal Guard crit counter (only if no buff/cooldown active)
    if((isCritical || isSuperCritical) && equippedSpecialBees && equippedSpecialBees.includes('special_bee2')){
      if(!royalGuardBuffActive && !royalGuardCooldownActive){
        royalGuardCritCount++;
        if(royalGuardCritCount >= 10){
          royalGuardBuffActive = true;
          royalGuardBuffStartTime = Date.now();
          royalGuardCritCount = 0; // Reset counter after buff activates
          console.log('âš”ï¸ Royal Guard BUFF ACTIVATED! +1000% Crit Chance for 3s');
        }
      }
    }
    
    const totalInstantConv = stats.instantConversion + stats.beeInstantConversion;
    let isInstantConversion = Math.random() * 100 < totalInstantConv;
    let instantHoneyAmount = isInstantConversion ? finalPollenValue * 0.5 : 0;
    
    const pollenAfterConversion = finalPollenValue - instantHoneyAmount;
    
    const totalPollenBonus = stats.pollenBonus + stats.beePollenBonus;
    let gain = pollenAfterConversion
      * (1 + totalPollenBonus / 100)
      * (1 + tool.pollenBonus / 100);
    
    // Track destroyed tiles for Fuzzy Bee (every 20 tiles triggers +5000% buff for 5s)
    if(equippedBees && equippedBees.includes('bee5')){
      const now = Date.now();
      
      // Check if buff/cooldown expired
      if(fuzzyBuffActive && now > fuzzyBuffEndTime){
        fuzzyBuffActive = false;
      }
      if(now > fuzzyBuffCooldownEnd){
        fuzzyBuffCooldownEnd = 0;
      }
      
      // Increment destruction count
      fuzzyDestructionCount++;
      
      // Every 20 tiles destroyed and no cooldown active
      if(fuzzyDestructionCount >= 20 && !fuzzyBuffCooldownEnd){
        fuzzyBuffActive = true;
        fuzzyBuffEndTime = now + 5000; // 5 second buff
        fuzzyBuffCooldownEnd = now + 10000; // 10s cooldown (starts after buff ends, total 15s)
        fuzzyDestructionCount = 0;
        console.log('âœ¨ Fuzzy Bee BUFF ACTIVATED! +500% pollen for 5s');
      }
    }
    
    // Track blue flower destruction for Bouyan Bee (every 30 blue = +x1.01 capacity bonus, max 50 stacks)
    if(equippedBees && equippedBees.includes('bee7')){
      const now = Date.now();
      
      // Check if 2 minutes have passed without blue flower destruction
      if(bouyanbeeBlueCount > 0 && (now - bouyanbeeLastBlueTime) > 120000){
        const previousCapacity = calculateCapacity();
        console.log('ðŸŸ¦ Bouyan Bee: 2 minutes without blue flowers, resetting to x1.0');
        bouyanbeeStackCount = 0;
        bouyanbeeMultiplier = 1.0;
        bouyanbeeBlueCount = 0;
        const newCapacity = calculateCapacity(); // Will be recalculated
        console.log(`ðŸŸ¦ Bouyan Reset! Capacity: ${previousCapacity} â†’ ${newCapacity}`);
      }
      
      // If this is a blue flower
      if(tile.c === 'blue'){
        bouyanbeeLastBlueTime = now;
        bouyanbeeBlueCount++;
        
        // Every 30 blue flowers, increase multiplier (max 100 stacks)
        if(bouyanbeeBlueCount >= 30 && bouyanbeeStackCount < 100){
          bouyanbeeBlueCount = 0;
          // Calculate capacity BEFORE incrementing
          const previousCapacity = calculateCapacity();
          bouyanbeeStackCount++;
          bouyanbeeMultiplier = Math.pow(1.01, bouyanbeeStackCount);
          
          // Notify player
          const newCapacity = calculateCapacity(); // Recalculated with new stack
          const capacityIncrease = newCapacity - previousCapacity;
          console.log(`ðŸŸ¦ Bouyan Bee: Stack ${bouyanbeeStackCount}/100 (x${bouyanbeeMultiplier.toFixed(4)}) - Capacity: ${previousCapacity} â†’ ${newCapacity}`);
        }
      }
    }
    
    // Check if this tile is affected by Fire Bee (x2 pollen if destroyed)
    let fireBeeBuff = 1;
    if(fireBeeTilesActive[idx]){
      fireBeeBuff = 2; // x2 pollen for Fire Bee tiles
      // Devil Bee buff: Fire Pollen x2 (doubles the fire buff)
      const hasDevilBee = equippedBees && equippedBees.includes('bee24');
      if(hasDevilBee){
        fireBeeBuff *= 2; // x4 total with Devil Bee (x2 Fire Bee * x2 Devil Bee)
      }
      delete fireBeeTilesActive[idx]; // Remove after applying bonus
      stopParticles(idx); // Stop particle loop
      // Remove fire border
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("fire-effect");
      }
    }
    
    // Check if this tile is affected by Spicy Bee / Dark Fire (x7 pollen if destroyed)
    let spicyBeeBuff = 1;
    if(spicyTilesActive[idx]){
      spicyBeeBuff = 7; // x7 pollen for Spicy Bee (Dark Fire) tiles
      delete spicyTilesActive[idx]; // Remove after applying bonus
      stopParticles(idx); // Stop particle loop
      // Remove dark fire border
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("dark-fire-effect");
      }
    }
    
    // Check if this tile is affected by Bubble Bee (x2 pollen if destroyed)
    let bubbleBeeBuff = 1;
    if(bubbleTilesActive[idx]){
      bubbleBeeBuff = 2; // x2 pollen for Bubble Bee tiles
      delete bubbleTilesActive[idx]; // Remove after applying bonus
      stopParticles(idx); // Stop particle loop
      // Remove bubble border
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("bubble-effect");
      }
    }
    
    // === CRIMSON BUFF EFFECT ===
    let crimsonBuff = 1;
    let crimsonCritChance = 0;
    if(crimsonTilesActive[idx]){
      crimsonBuff = 4; // x4 base pollen
      // Additional +500% pollen = x6 total from crimson
      crimsonBuff = 6;
      crimsonCritChance = 20; // +20% critical chance
      
      // If red pollen, apply x4 multiplier as mentioned
      if(tile.c === 'red'){
        crimsonBuff = 4; // x4 for red pollen
      }
      
      delete crimsonTilesActive[idx];
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("crimson-effect");
      }
    }
    
    // === ENHANCED GOO BUFF EFFECT ===
    let enhancedGooBuff = 1;
    let enhancedGooCritChance = 0;
    if(enhancedGooTiles[idx]){
      enhancedGooBuff = 5; // x5 pollen
      enhancedGooCritChance = 30; // +30% critical chance
      
      delete enhancedGooTiles[idx];
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("enhanced-goo-effect");
      }
    }
    
    // === CRITICAL ERROR BUFF EFFECT ===
    let criticalErrorBuff = 1;
    let criticalErrorCritChance = 0;
    if(criticalErrorTiles[idx]){
      // x10 red pollen only
      if(tile.c === 'red'){
        criticalErrorBuff = 10;
      }
      criticalErrorCritChance = 100; // +100% critical chance (guaranteed crit)
      
      delete criticalErrorTiles[idx];
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("critical-error-effect");
      }
    }
    
    // Apply Fire/Spicy Bee, Bubble Bee, and Bouyan multipliers
    gain = gain * fireBeeBuff * spicyBeeBuff * bubbleBeeBuff * crimsonBuff * enhancedGooBuff * criticalErrorBuff * bouyanbeeMultiplier;
    
    // Apply Fuzzy Bee buff (500% = x6 total)
    if(fuzzyBuffActive){
      gain *= 6; // 1 + 500%
    }
    
    // === GRANDMASTER PORCELAIN EFFECT ===
    if(grandmasterActive){
      // +3000% pollen bonus, x2 for red/blue colors, +20% crit chance check
      console.log(`[GRANDMASTER BUFF] Applied x31 to ${tile.c} tile, gain before: ${Math.round(gain/31)}, gain after: ${Math.round(gain)}`);
      gain *= 31; // +3000% = x31 total
      
      // Increase crit chance by 20% temporarily
      const boostCritChance = 20;
      const adjustedCritChance = Math.min(100, totalCritChance + boostCritChance);
      if(Math.random() * 100 < adjustedCritChance){
        isCritical = true;
      }
      
      // x2 red/blue multiplier
      if(tile.c === 'red' || tile.c === 'blue'){
        gain *= 2;
      }
    }
    
    // === PORCELAIN DIPPER BUFF ===
    if(porcelainBuffActive){
      // +300% pollen bonus (x4 total)
      console.log(`[PORCELAIN BUFF] Applied x4 to ${tile.c} tile, gain before: ${Math.round(gain/4)}, gain after: ${Math.round(gain)}`);
      gain *= 4;
    }

    // === COCONUT BAG BUFF ===
    if(coconutBagBuffActive && tile.c === 'white'){
      // x3 white pollen
      console.log(`[COCONUT BUFF] Applied x3 to white tile, gain before: ${Math.round(gain/3)}, gain after: ${Math.round(gain)}`);
      gain *= 3;
    }
    
    // Apply Diamond Bee buff (+5000% convert rate = x51 on conversion)
    // Apply Goo multiplier if on this tile (x2.5 pollen + x1.5 from Gummy Bee = x3.75 + 100% instant conv)
    let hasGoo = false;
    if(gooTiles[idx]){
      const gooMultiplier = 2.5 * 1.5; // x3.75 total (x2.5 base + x1.5 Gummy Bee buff)
      gain *= gooMultiplier;
      stats.gooMultiplier = gooMultiplier; // Track goo multiplier
      isInstantConversion = true; // Force instant conversion for Goo
      instantHoneyAmount = gain * 0.5; // Recalculate honey with Goo buff
      hasGoo = true;
      
      // Apply Gummy Bee specific buffs
      // White pollen x3 and Goo pollen x2
      if(equippedSpecialBees && equippedSpecialBees.includes('special_bee3')){
        if(tile.c === 'white'){
          gain *= 3; // x3 white pollen bonus from Gummy Bee
        }
        gain *= 2; // x2 goo pollen bonus from Gummy Bee (applies to all goo)
      }
    }

    // === ENERGY TILE BUFF ===
    let hadEnergyBuff = false;
    if(energyTiles[idx]){
      hadEnergyBuff = true;
      // x5 blue pollen, x2 pollen para otras, 100% instant conv
      if(tile.c === 'blue'){
        gain *= bluePollenMultiplier * 5;
        stats.blueTotal += gain;
      } else {
        gain *= 2;
        if(tile.c === 'red') stats.redTotal += gain;
        else if(tile.c === 'white') stats.whiteTotal += gain;
        else if(tile.c === 'yellow') stats.yellowTotal = (stats.yellowTotal || 0) + gain;
        else if(tile.c === 'purple') stats.purpleTotal = (stats.purpleTotal || 0) + gain;
      }
      isInstantConversion = true;
      instantHoneyAmount = gain * 0.5;
      // Eliminar el energy buff de la tile
      delete energyTiles[idx];
    } else {
      // Apply color-based multipliers normalmente
      if(tile.c === 'red'){
        gain *= redPollenMultiplier;
        stats.redTotal += gain;
      } else if(tile.c === 'blue'){
        gain *= bluePollenMultiplier;
        stats.blueTotal += gain;
      } else if(tile.c === 'white'){
        gain *= whitePollenMultiplier;
        stats.whiteTotal += gain;
      } else if(tile.c === 'yellow'){
        gain *= yellowPollenMultiplier;
        stats.yellowTotal = (stats.yellowTotal || 0) + gain;
      } else if(tile.c === 'purple'){
        gain *= purplePollenMultiplier;
        stats.purpleTotal = (stats.purpleTotal || 0) + gain;
      }
    }

    const currentCapacity = calculateCapacity();
    const added = Math.min(currentCapacity - stats.pollen, gain);
    stats.pollen += added;
    try{ ensureFieldStats(fieldKey); fieldStats[fieldKey].pollenCollected = (fieldStats[fieldKey].pollenCollected||0) + added; }catch(e){}
    stats.honey += instantHoneyAmount;
    stats.totalHoney += instantHoneyAmount;
    pollenThisSec += added;
    
    // Track pollen for Coconut Bag ability (when collected from tiles)
    // DON'T track while buff is active - restart tracking when buff ends
    if(equippedStorageId === 'coconut_bag' && !coconutBagBuffActive){
      coconutBagPollenStored += added;
      console.log(`[COCONUT] Pollen collected: ${coconutBagPollenStored}/1000000 (+${Math.round(added)})`);
      
      // Check if reached 1M milestone
      if(coconutBagPollenStored >= 1000000){
        coconutBagPollenStored = 0;
        applyCoconutBagBuff();
      }
    }
    // Track Goo pollen collected
    if(hasGoo){
      stats.gooPollenCollected += added;
    }
    
    // Track Goo destruction for Gummy token
    if(hasGoo){
      gooDestroyedCount++;
      delete gooTiles[idx];
      // Remove goo border styling
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("goo-effect");
      }
    }

    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if (tileEl) {
      const r = tileEl.getBoundingClientRect();
      
      // Crear partÃ­culas de Goo que suben
      if(hasGoo){
        const now = Date.now();
        for(let p = 0; p < 6; p++){
          const particle = document.createElement('div');
          particle.style.position = 'fixed';
          particle.style.left = (r.left + r.width/2) + 'px';
          particle.style.top = (r.top + r.height/2) + 'px';
          particle.style.width = '4px';
          particle.style.height = '4px';
          particle.style.borderRadius = '0';
          particle.style.background = gooColorList[Math.floor(Math.random() * gooColorList.length)];
          particle.style.pointerEvents = 'none';
          particle.style.zIndex = '9999';
          particle.style.boxShadow = '0 0 4px ' + particle.style.background;
          document.body.appendChild(particle);
          
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 100 + 50;
          const vx = Math.cos(angle) * speed;
          let px = r.left + r.width/2;
          let py = r.top + r.height/2;
          
          const particleAnim = setInterval(()=>{
            px += vx * 0.016;
            py -= 80 * 0.016; // Subir
            
            // Cambiar color durante la animaciÃ³n
            const currentColorIndex = Math.floor((Date.now() - now) / 150) % gooColorList.length;
            particle.style.background = gooColorList[currentColorIndex];
            particle.style.boxShadow = '0 0 4px ' + gooColorList[currentColorIndex];
            
            particle.style.left = px + 'px';
            particle.style.top = py + 'px';
            particle.style.opacity = Math.max(0, 1 - (Date.now() - now) / 800);
            if(Date.now() - now > 800){
              clearInterval(particleAnim);
              particle.remove();
            }
          }, 16);
        }
      }
      
      // Limpiar efecto visual del Goo
      if(hasGoo){
        tileEl.style.filter = 'none';
      }
      
      // Only show floating numbers if not skipped (optimization for many tiles)
      if(!shouldSkipFloatingNumber){
        floating(r.left + r.width / 2, r.top, gain, isCritical, hasGoo, false, false, false, isSuperCritical);
        if (isInstantConversion) {
          floating(r.left + r.width / 2, r.top + 20, instantHoneyAmount * 0.5, false, false, true);
        }
      }
      
      // Update tile visual immediately to show it's been destroyed
      renderTile(tileEl, fieldData[fieldKey][idx]);
      
      tileEl.style.transition = "opacity 0.4s ease-out";
      tileEl.style.opacity = "0";
      
      // 1% chance to get a ticket from tile destruction
      if(Math.random() < (0.01 + (tileTicketProbBonus || 0))){
        tickets += 1;
        showFloatingText(r.left + r.width / 2, r.top, 'ðŸŽ« +1 Ticket', '#FFA500');
      }
    }

    console.log(`    -> DESTROYING tile ${idx}`);
    destroyedCount++; // Track tiles destroyed for tool abilities
    fieldData[fieldKey][idx] = {c: "", ty: 0, transparent: true};

    const capturedIdx = idx;
    const capturedFieldKey = fieldKey;
    // Random regeneration time using tileRegenerationRange
    const regenerationTime = tileRegenerationRange.min + Math.random() * (tileRegenerationRange.max - tileRegenerationRange.min);
    const regenerationTimer = setTimeout(() => {
      if (fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]) {
        fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
        if (currentField === capturedFieldKey) {
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
          if (tileEl) {
            tileEl.style.transition = "opacity 0.8s ease-in";
            tileEl.style.opacity = "0";
            // Force reflow to apply initial state
            void tileEl.offsetWidth;
            renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
            tileEl.style.opacity = "1";
          }
        }
        saveGame();
      }
    }, regenerationTime);
  });

  // Track tiles destroyed for tool abilities
  if (destroyedCount > 0) {
    // Grandmaster Porcelain tracking - DON'T COUNT if effect is active
    if (equippedToolId === 'porcelain_grandmaster' && !grandmasterActive) {
      grandmasterTilesDestroyed += destroyedCount;
      console.log(`Grandmaster tiles destroyed: ${grandmasterTilesDestroyed}/200`);
      
      if (grandmasterTilesDestroyed >= 200) {
        grandmasterTilesDestroyed = 0;
        activateGrandmasterEffect();
      }
    }
    
    // Porcelain Dipper tracking - DON'T COUNT if buff is active
    if (equippedToolId === 'porcelain_dipper' && !porcelainBuffActive) {
      porcelainTilesDestroyed += destroyedCount;
      console.log(`Porcelain Dipper tiles destroyed: ${porcelainTilesDestroyed}/100`);
      
      if (porcelainTilesDestroyed >= 100) {
        porcelainTilesDestroyed = 0;
        applyPorcelainDipperBuff();
      }
    }
  }

  saveGame();
}

/* ================= TOOL/STORAGE ABILITIES ================= */

/**
 * Activates Grandmaster Porcelain effect
 * Next destroyed tiles get +3000% pollen, +20% crit chance, x2 color multipliers for 30s
 */
function activateGrandmasterEffect(){
  grandmasterActive = true;
  grandmasterEffectStartTime = Date.now();
  grandmasterBuffTimeLeft = 30; // 30 seconds
  console.log('Grandmaster Porcelain effect activated!');
  showNotification('â­ GRANDMASTER EFFECT ACTIVATED! â­', 'success', 3000);
  
  // Schedule deactivation after 30 seconds
  setTimeout(() => {
    grandmasterActive = false;
    grandmasterBuffTimeLeft = 0;
    console.log('Grandmaster Porcelain effect ended');
    showNotification('â­ Grandmaster effect ended', 'info', 2000);
    updatePlayerStatsPanel(); // Force UI update to remove frame
  }, 30000);
}

/**
 * Applies Porcelain Dipper buff
 * +300% pollen, -20% tool cooldown for 1 minute
 */
function applyPorcelainDipperBuff(){
  porcelainBuffActive = true;
  porcelainBuffStartTime = Date.now();
  porcelainBuffTimeLeft = 60; // 60 seconds
  console.log('Porcelain Dipper buff applied!');
  showNotification('ðŸ’§ DIPPER BUFF: +300% POLLEN, -20% COOLDOWN ðŸ’§', 'success', 3000);
  
  // Schedule buff end after 60 seconds
  setTimeout(() => {
    porcelainBuffActive = false;
    porcelainBuffTimeLeft = 0;
    console.log('Porcelain Dipper buff ended');
    showNotification('ðŸ’§ Dipper buff ended', 'info', 2000);
    updatePlayerStatsPanel(); // Force UI update to remove frame
  }, 60000);
}

/**
 * Applies Coconut Bag buff
 * +500% pollen, white pollen x3 for 30s
 */
function applyCoconutBagBuff(){
  coconutBagBuffActive = true;
  coconutBagBuffStartTime = Date.now();
  coconutBagBuffTimeLeft = 30; // 30 seconds
  console.log('Coconut Bag buff applied!');
  showNotification('ðŸ¥¥ COCONUT BUFF: +500% POLLEN, WHITE x3 ðŸ¥¥', 'success', 3000);
  
  // Schedule buff end after 30 seconds
  setTimeout(() => {
    coconutBagBuffActive = false;
    coconutBagBuffTimeLeft = 0;
    console.log('Coconut Bag buff ended');
    showNotification('ðŸ¥¥ Coconut buff ended', 'info', 2000);
    updatePlayerStatsPanel(); // Force UI update to remove frame
  }, 30000);
}

/* ================= UPGRADES ================= */
/* UPGRADES loaded from configs/upgrades.js - contains UPGRADES, POLLEN_COLOR_UPGRADES, TILE_UPGRADES arrays */
Object.keys(UPGRADES).length && console.log('âœ“ UPGRADES loaded from config');
let upgradeLevels={};
// Initialize from config if available
if(typeof UPGRADES !== 'undefined') {
  UPGRADES.forEach(u => upgradeLevels[u.id] = 0);
}
if(typeof POLLEN_COLOR_UPGRADES !== 'undefined') {
  POLLEN_COLOR_UPGRADES.forEach(u => upgradeLevels[u.id] = 0);
}

/* TILE_UPGRADES loaded from configs/upgrades.js */
let tileUpgradeLevels={};
let maxGooTiles = 0;
let tileRegenerationRange = {min:500,max:2000};
let torretTilesPerShot = 0; // Total tiles to destroy per shot (3 per upgrade level)
let torretInterval = 30000;
let torretLastTime = Date.now() + torretInterval; // Prevent firing on page load
let torretHasStarted = false; // Flag to ensure torret starts correctly
let playerRankLevel = 0;
let playerRankBuffs = {};
// Initialize from config if available
if(typeof TILE_UPGRADES !== 'undefined') {
  TILE_UPGRADES.forEach(t => tileUpgradeLevels[t.id] = 0);
}

// Function to calculate torret tiles based on level
function calculateTorretTiles(){
  const torretUpgrade = TILE_UPGRADES && TILE_UPGRADES.find(u => u.stat === 'torretTiles');
  if(!torretUpgrade) return 0;
  
  const level = tileUpgradeLevels[torretUpgrade.id] || 0;
  // Each level adds +3 tiles: level 1 = 3, level 2 = 6, etc.
  return level * 3;
}

/* ================= SAVE / LOAD ================= */
function saveGame(){
  localStorage.setItem(SAVE_KEY,JSON.stringify({
    stats,upgradeLevels,currentField,currentSection,fieldData,playTime,equippedTool,ownedTools,equippedToolId,ownedBees,equippedBees,discoveredBees,ownedSpecialBees,equippedSpecialBees,maxEquippedBeesEver,eggPrices,maxSlots,ownedStorages,equippedStorageId,fieldStats,claimedRewards,bouyanbeeStackCount,bouyanbeeMultiplier,bouyanbeeBlueCount,bouyanbeeLastBlueTime,bouyanbeeBaseCapacity,fuzzyDestructionCount,gooDestroyedCount,redPollenMultiplier,bluePollenMultiplier,whitePollenMultiplier,yellowPollenMultiplier,purplePollenMultiplier,tickets,ticketBeeAbilityTime,goldenBeeAbilityTime,tileTicketProbBonus,
    // Ability states
    fireBeeTilesActive,spicyTilesActive,gooTiles,fuzzyBuffActive,fuzzyBuffEndTime,fuzzyBuffCooldownEnd,demonTilesActive,activeLaserLines,lastFireBeeAbility,lastSpicyAbility,lastDemonAbility,lastLaserAbility,lastGooGeneration,gooColorCycle,energyTiles,lastTeslaBeeAbility,lastThunderBeeAbility,lastGooTileGeneration,activeGooTileIndices,lastPhotonAbility,lastDigitalRandomEffect,lastDigitalGlitch,glitchedTiles,lastMoonLaser,lastFourFormation,lastLionDestruction,crimsonTilesActive,enhancedGooTiles,criticalErrorTiles,lastKingCrimsonAbility,lastCrimsonGuardSynergy,bubbleTilesActive,lastBubbleBeeAbility,
    // Tile upgrades
    tileUpgradeLevels,maxGooTiles,tileRegenerationRange,torretInterval,torretLastTime,playerRankLevel,playerRankBuffs,
    // Tool/Storage abilities
    grandmasterTilesDestroyed,grandmasterActive,grandmasterEffectStartTime,grandmasterBuffTimeLeft,porcelainTilesDestroyed,porcelainBuffActive,porcelainBuffStartTime,porcelainBuffTimeLeft,coconutBagPollenStored,coconutBagBuffActive,coconutBagBuffStartTime,coconutBagBuffTimeLeft,
    // Advanced buff tracking
    activeBeeBuffs,activeToolBuffs,activeStorageBuffs,
    // Tile effects system
    tileEffectsTiles: tileEffectsSystem.tileEffects
  }));
}
function loadGame(){
const s=JSON.parse(localStorage.getItem(SAVE_KEY));
if(!s)return;
Object.assign(stats,s.stats||{});
upgradeLevels=s.upgradeLevels||upgradeLevels;
currentField=s.currentField||currentField;
currentSection=s.currentSection||"tools";

  // restore storages
  ownedStorages = s.ownedStorages || ownedStorages;
  equippedStorageId = s.equippedStorageId || equippedStorageId;
  fieldStats = s.fieldStats || fieldStats;

fieldData = {};
if (s.fieldData) {
  for (const fieldKey in s.fieldData) {
    fieldData[fieldKey] = s.fieldData[fieldKey].map(tile => {
      if (!tile || typeof tile !== 'object') return createTile(fieldKey);
      return {
        c: tile.c || "",
        ty: tile.ty !== undefined ? tile.ty : 0,
        transparent: tile.transparent === true
      };
    });
  }
}

playTime=s.playTime||0;
ownedTools=s.ownedTools||ownedTools;
// Migration: convert old "grandmaster" ID to new "porcelain_grandmaster"
if(ownedTools.includes('grandmaster')) {
  ownedTools = ownedTools.map(t => t === 'grandmaster' ? 'porcelain_grandmaster' : t);
}
if(s.equippedToolId === 'grandmaster') {
  equippedToolId = 'porcelain_grandmaster';
} else {
  equippedToolId = s.equippedToolId || "shovel";
}
ownedBees=s.ownedBees||ownedBees;
equippedBees=s.equippedBees||equippedBees;
discoveredBees=s.discoveredBees||discoveredBees;
ownedSpecialBees=s.ownedSpecialBees||ownedSpecialBees;
equippedSpecialBees=s.equippedSpecialBees||equippedSpecialBees;
claimedRewards=s.claimedRewards||claimedRewards;
maxEquippedBeesEver = s.maxEquippedBeesEver || maxEquippedBeesEver;
if(s.eggPrices) eggPrices = Object.assign(eggPrices || {}, s.eggPrices);
maxSlots = s.maxSlots || maxSlots;
bouyanbeeStackCount = s.bouyanbeeStackCount || 0;
bouyanbeeMultiplier = s.bouyanbeeMultiplier || 1.0;
bouyanbeeBlueCount = s.bouyanbeeBlueCount || 0;
bouyanbeeLastBlueTime = s.bouyanbeeLastBlueTime || 0;
bouyanbeeBaseCapacity = s.bouyanbeeBaseCapacity || bouyanbeeBaseCapacity;
fuzzyDestructionCount = s.fuzzyDestructionCount || 0;
gooDestroyedCount = s.gooDestroyedCount || 0;
redPollenMultiplier = s.redPollenMultiplier || 1.0;
bluePollenMultiplier = s.bluePollenMultiplier || 1.0;
whitePollenMultiplier = s.whitePollenMultiplier || 1.0;
yellowPollenMultiplier = s.yellowPollenMultiplier || 1.0;
purplePollenMultiplier = s.purplePollenMultiplier || 1.0;
// Restore ability states
fireBeeTilesActive = s.fireBeeTilesActive || {};
spicyTilesActive = s.spicyTilesActive || {};
gooTiles = s.gooTiles || {};
fuzzyBuffActive = s.fuzzyBuffActive || false;
fuzzyBuffEndTime = s.fuzzyBuffEndTime || 0;
fuzzyBuffCooldownEnd = s.fuzzyBuffCooldownEnd || 0;
demonTilesActive = s.demonTilesActive || {};
activeLaserLines = s.activeLaserLines || {};
lastLionDestruction = s.lastLionDestruction || 0;
lastFireBeeAbility = s.lastFireBeeAbility || 0;
lastSpicyAbility = s.lastSpicyAbility || 0;
lastDemonAbility = s.lastDemonAbility || 0;
lastDiamondCheck = s.lastDiamondCheck || 0;
lastLaserAbility = s.lastLaserAbility || 0;
lastGooGeneration = s.lastGooGeneration || 0;
gooColorCycle = s.gooColorCycle || 0;
energyTiles = s.energyTiles || {};
lastTeslaBeeAbility = s.lastTeslaBeeAbility || 0;
lastThunderBeeAbility = s.lastThunderBeeAbility || 0;
lastPhotonAbility = s.lastPhotonAbility || 0;
lastDigitalRandomEffect = s.lastDigitalRandomEffect || 0;
lastDigitalGlitch = s.lastDigitalGlitch || 0;
glitchedTiles = s.glitchedTiles || {};
lastMoonLaser = s.lastMoonLaser || 0;
lastFourFormation = s.lastFourFormation || 0;
lastGooTileGeneration = s.lastGooTileGeneration || 0;
activeGooTileIndices = s.activeGooTileIndices || [];
bubbleTilesActive = s.bubbleTilesActive || {};
lastBubbleBeeAbility = s.lastBubbleBeeAbility || 0;
tickets = s.tickets || 0;
ticketBeeAbilityTime = s.ticketBeeAbilityTime || 0;
goldenBeeAbilityTime = s.goldenBeeAbilityTime || 0;
tileTicketProbBonus = s.tileTicketProbBonus || 0;
tileUpgradeLevels = s.tileUpgradeLevels || tileUpgradeLevels;
maxGooTiles = s.maxGooTiles || 0;
tileRegenerationRange = s.tileRegenerationRange || {min:500,max:2000};

// Restore Tile Upgrade abilities
torretLastTime = s.torretLastTime || Date.now();
playerRankLevel = s.playerRankLevel || 0;
playerRankBuffs = s.playerRankBuffs || {};

// Recalculate torretTilesPerShot based on actual upgrade level
torretTilesPerShot = calculateTorretTiles();

// Restore Tool/Storage abilities
grandmasterTilesDestroyed = s.grandmasterTilesDestroyed || 0;
grandmasterActive = s.grandmasterActive || false;
grandmasterEffectStartTime = s.grandmasterEffectStartTime || 0;
grandmasterBuffTimeLeft = s.grandmasterBuffTimeLeft || 0;
porcelainTilesDestroyed = s.porcelainTilesDestroyed || 0;
porcelainBuffActive = s.porcelainBuffActive || false;
porcelainBuffStartTime = s.porcelainBuffStartTime || 0;
porcelainBuffTimeLeft = s.porcelainBuffTimeLeft || 0;
coconutBagPollenStored = s.coconutBagPollenStored || 0;
coconutBagBuffActive = s.coconutBagBuffActive || false;
coconutBagBuffStartTime = s.coconutBagBuffStartTime || 0;
coconutBagBuffTimeLeft = s.coconutBagBuffTimeLeft || 0;
crimsonTilesActive = s.crimsonTilesActive || {};
enhancedGooTiles = s.enhancedGooTiles || {};
criticalErrorTiles = s.criticalErrorTiles || {};
lastKingCrimsonAbility = s.lastKingCrimsonAbility || 0;
lastCrimsonGuardSynergy = s.lastCrimsonGuardSynergy || 0;

// Restore advanced buff tracking
activeBeeBuffs = s.activeBeeBuffs || {};
activeToolBuffs = s.activeToolBuffs || {};
activeStorageBuffs = s.activeStorageBuffs || {};

// Restore tile effects system
if(s.tileEffectsTiles) {
  tileEffectsSystem.tileEffects = s.tileEffectsTiles;
} else {
  tileEffectsSystem.tileEffects = {};
}

const tool = TOOLS.find(t => t.id === equippedToolId);
if (tool) equippedTool = tool.name;

updateBeeAbilities();

// Restore player's last visited shop section
openShop(currentSection);
}

/* ================= TIME ================= */
function formatTime(sec){
const h=Math.floor(sec/3600);
const m=Math.floor((sec%3600)/60);
const s=sec%60;
return `${h}h ${m}m ${s}s`;
}
setInterval(()=>{
playTime++;
updatePlayerStatsPanel();
saveGame();
},1000);

// call highlight on init
setTimeout(()=>{ try{ highlightShopTab(currentSection); }catch(e){} },100);

/* ================= PROFILE EXPORT/IMPORT ================= */
const SAVES_KEY = "grassSaves";

function getSaves(){
  const saves = localStorage.getItem(SAVES_KEY);
  return saves ? JSON.parse(saves) : {};
}

function savesToLocalStorage(saves){
  localStorage.setItem(SAVES_KEY, JSON.stringify(saves));
}

function saveProfileToFolder(profileName){
  if(!profileName || profileName.trim() === ""){
    alert('Please enter a profile name');
    return;
  }
  
  const saves = getSaves();
  
  // Check if profile already exists
  if(saves[profileName]){
    if(!confirm(`Profile "${profileName}" already exists. Overwrite?`)) return;
  }
  
  const profileData = {
    version: "1.0",
    saveDate: new Date().toISOString(),
    profileName: profileName,
    stats,
    upgradeLevels,
    currentField,
    currentSection,
    playTime,
    equippedTool,
    ownedTools,
    equippedToolId,
    ownedBees,
    equippedBees,
    maxEquippedBeesEver,
    eggPrices,
    maxSlots,
    ownedStorages,
    equippedStorageId,
    discoveredBees,
    ownedSpecialBees,
    equippedSpecialBees,
    fieldStats
  };
  
  saves[profileName] = profileData;
  savesToLocalStorage(saves);
  alert(`Profile "${profileName}" saved successfully in saves folder`);
  buildSavesManager();
}

function loadProfileFromFolder(profileName){
  const saves = getSaves();
  const profileData = saves[profileName];
  
  if(!profileData){
    alert(`Profile "${profileName}" does not exist`);
    return;
  }
  
  // Load data
  Object.assign(stats, profileData.stats || {});
  upgradeLevels = profileData.upgradeLevels || upgradeLevels;
  currentField = profileData.currentField || currentField;
  currentSection = profileData.currentSection || "tools";
  equippedTool = profileData.equippedTool || equippedTool;
  ownedTools = profileData.ownedTools || ownedTools;
  equippedToolId = profileData.equippedToolId || equippedToolId;
  ownedBees = profileData.ownedBees || ownedBees;
  equippedBees = profileData.equippedBees || equippedBees;
  discoveredBees = profileData.discoveredBees || discoveredBees;
  ownedSpecialBees = profileData.ownedSpecialBees || ownedSpecialBees;
  equippedSpecialBees = profileData.equippedSpecialBees || equippedSpecialBees;
  claimedRewards = profileData.claimedRewards || claimedRewards;
  maxEquippedBeesEver = profileData.maxEquippedBeesEver || maxEquippedBeesEver;
  eggPrices = profileData.eggPrices || eggPrices;
  maxSlots = profileData.maxSlots || maxSlots;
  ownedStorages = profileData.ownedStorages || ownedStorages;
  equippedStorageId = profileData.equippedStorageId || equippedStorageId;
  fieldStats = profileData.fieldStats || fieldStats;
  
  // Rebuild grid and UI
  buildFieldList();
  buildGrid();
  buildUpgrades();
  buildTools();
  updateBeeAbilities();
  updateUI();
  
  // Restore player's last visited shop section
  openShop(currentSection);
  
  alert(`Profile "${profileName}" loaded successfully`);
  saveGame();
}

function deleteProfileFromFolder(profileName){
  if(!confirm(`Are you sure you want to delete profile "${profileName}"?`)) return;
  
  const saves = getSaves();
  delete saves[profileName];
  savesToLocalStorage(saves);
  alert(`Profile "${profileName}" deleted successfully`);
  buildSavesManager();
}

function buildSavesManager(){
  const modal = document.getElementById('savesModal');
  if(!modal) return;
  
  const saves = getSaves();
  const savesList = Object.keys(saves);
  
  let html = `
    <div style="position:relative;background:#1b1b1b;border-radius:0px;padding:16px;max-width:400px;box-shadow:0 10px 30px rgba(0,0,0,0.7)">
      <button onclick="closeSavesModal()" style="position:absolute;right:8px;top:8px;background:#333;border:none;color:#f1c40f;cursor:pointer;padding:4px 8px;border-radius:0px">âœ•</button>
      <h3 style="color:#f1c40f;margin:0 0 12px 0;text-align:center">ðŸ“ Saves Folder</h3>
      <div style="margin-bottom:12px">
        <input type="text" id="profileNameInput" placeholder="Profile Name" style="width:100%;padding:8px;background:#262626;border:1px solid #444;color:#fff;border-radius:0px;box-sizing:border-box;margin-bottom:8px">
        <button onclick="saveProfileToFolder(document.getElementById('profileNameInput').value)" class="small-btn" style="width:100%">ðŸ’¾ Save Profile</button>
      </div>
      <div style="border-top:1px solid #444;padding-top:12px">
        <div style="font-size:12px;color:#ccc;margin-bottom:8px"><b>Saved Profiles (${savesList.length}):</b></div>
  `;
  
  if(savesList.length === 0){
    html += `<div style="color:#888;font-size:12px;text-align:center;padding:12px">No saved profiles</div>`;
  } else {
    savesList.forEach(name => {
      const save = saves[name];
      const date = new Date(save.saveDate).toLocaleString('es-ES');
      html += `
        <div style="background:#262626;padding:8px;border-radius:0px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center">
          <div style="flex:1">
            <div style="color:#f1c40f;font-size:12px;font-weight:bold">${name}</div>
            <div style="color:#888;font-size:10px">${date}</div>
            <div style="color:#bbb;font-size:10px">Miel: ${fmt(save.stats.totalHoney)}</div>
          </div>
          <div style="display:flex;gap:4px;flex-direction:column">
            <button onclick="loadProfileFromFolder('${name}')" class="small-btn" style="padding:4px 8px;font-size:10px;min-width:60px">ðŸ“‚ Load</button>
            <button onclick="deleteProfileFromFolder('${name}')" class="small-btn" style="padding:4px 8px;font-size:10px;min-width:60px;background:#c0392b;color:#fff">ðŸ—‘ï¸ Delete</button>
          </div>
        </div>
      `;
    });
  }
  
  html += `
      </div>
    </div>
  `;
  
  modal.innerHTML = html;
  modal.style.display = 'flex';
}

function openSavesManager(){
  let modal = document.getElementById('savesModal');
  if(!modal){
    modal = document.createElement('div');
    modal.id = 'savesModal';
    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:5000;';
    document.body.appendChild(modal);
  }
  buildSavesManager();
}

function closeSavesModal(){
  const modal = document.getElementById('savesModal');
  if(modal) modal.style.display = 'none';
}

/* ================= UPDATE UI ================= */
function calculateCapacity(){
  // Base capacity: 120 + storage bonuses (accumulated in stats.pollenCapacity from storage equips)
  const storage = STORAGE.find(s => s.id === equippedStorageId);
  let storageBonus = 0;
  if(storage && storage.bonuses && storage.bonuses.pollenCapacity){
    storageBonus = storage.bonuses.pollenCapacity;
  }
  
  // Include player rank capacity bonus
  const playerRankCapacityBonus = (playerRankBuffs && playerRankBuffs.capacityBonus) ? playerRankBuffs.capacityBonus : 0;
  
  const baseCapacity = 120 + storageBonus + (stats.beeCapacityBonus || 0) + playerRankCapacityBonus;
  
  // Apply Bouyan multiplier if any Bouyan Bee is equipped
  let bouyantMultiplier = 1.0;
  const bouyantBeeCount = equippedBees ? equippedBees.filter(id => id === 'bee7').length : 0;
  if(bouyantBeeCount > 0 && bouyanbeeStackCount > 0){
    // Each Bouyan Bee applies the multiplier independently
    bouyantMultiplier = Math.pow(bouyanbeeMultiplier, bouyantBeeCount);
  }
  
  return Math.floor(baseCapacity * bouyantMultiplier);
}

function applyPlayerRankBuffs(){
  // Apply player rank buffs directly (assign, not accumulate)
  // Stats are reset at the start of updateBeeAbilities(), so this happens once per tick
  if(playerRankLevel > 0 && playerRankBuffs){
    if(playerRankBuffs.pollenBonus) stats.pollenBonus += playerRankBuffs.pollenBonus;
    if(playerRankBuffs.convertBonus) stats.convertBonus += playerRankBuffs.convertBonus;
    if(playerRankBuffs.criticalChance) stats.criticalChance += playerRankBuffs.criticalChance;
    if(playerRankBuffs.criticalPower) stats.criticalPower += playerRankBuffs.criticalPower;
    if(playerRankBuffs.honeyBonus) stats.honeyBonus += playerRankBuffs.honeyBonus;
    if(playerRankBuffs.superCriticalChance) stats.superCriticalChance += playerRankBuffs.superCriticalChance;
    if(playerRankBuffs.fireMultiplier) stats.fireMultiplier = (stats.fireMultiplier || 1) * playerRankBuffs.fireMultiplier;
    if(playerRankBuffs.darkFireMultiplier) stats.darkFireMultiplier = (stats.darkFireMultiplier || 1) * playerRankBuffs.darkFireMultiplier;
    if(playerRankBuffs.gooMultiplier) stats.gooMultiplier = (stats.gooMultiplier || 1) * playerRankBuffs.gooMultiplier;
  }
}

function updateAffordabilityButtons(){
  // Update all buy buttons based on current honey/tickets
  
  // Upgrades buttons
  const upgradesEl = document.getElementById("upgrades");
  if(upgradesEl){
    const buttons = upgradesEl.querySelectorAll('[data-buy-btn="true"]');
    buttons.forEach(btn => {
      const price = parseInt(btn.getAttribute('data-price') || '0');
      const priceType = btn.getAttribute('data-price-type') || 'honey';
      let canAfford = false;
      
      if(priceType === 'tickets'){
        canAfford = tickets >= price;
      } else {
        canAfford = stats.honey >= price;
      }
      
      // Update button state
      btn.classList.remove('btn-can-afford', 'btn-cannot-afford');
      if(canAfford){
        btn.classList.add('btn-can-afford');
        btn.disabled = false;
      } else {
        btn.classList.add('btn-cannot-afford');
        btn.disabled = true;
      }
    });
  }
  
  // Tools buttons
  const toolsEl = document.getElementById("tools");
  if(toolsEl){
    const buttons = toolsEl.querySelectorAll('[data-buy-btn="true"]');
    buttons.forEach(btn => {
      const price = parseInt(btn.getAttribute('data-price') || '0');
      const canAfford = stats.honey >= price;
      
      btn.classList.remove('btn-can-afford', 'btn-cannot-afford');
      if(canAfford){
        btn.classList.add('btn-can-afford');
        btn.disabled = false;
      } else {
        btn.classList.add('btn-cannot-afford');
        btn.disabled = true;
      }
    });
  }
  
  // Storage buttons
  const storageEl = document.getElementById("storage");
  if(storageEl){
    const buttons = storageEl.querySelectorAll('[data-buy-btn="true"]');
    buttons.forEach(btn => {
      const price = parseInt(btn.getAttribute('data-price') || '0');
      const canAfford = stats.honey >= price;
      
      btn.classList.remove('btn-can-afford', 'btn-cannot-afford');
      if(canAfford){
        btn.classList.add('btn-can-afford');
        btn.disabled = false;
      } else {
        btn.classList.add('btn-cannot-afford');
        btn.disabled = true;
      }
    });
  }
}

function updateUI(){
// Automatic Torret firing logic - destroys random tiles with staggered delays
if(torretTilesPerShot > 0 && Date.now() - torretLastTime >= torretInterval){
  // Get available tile indices (non-destroyed tiles with valid type)
  const availableTiles = [];
  if(fieldData[currentField]){
    for(let idx = 0; idx < 600; idx++){
      const tile = fieldData[currentField][idx];
      // Include tiles that are not destroyed (ty !== -1) and have valid data
      if(tile && tile.ty !== -1 && tile.ty !== null && tile.ty !== undefined){
        availableTiles.push(idx);
      }
    }
  }
  
  // Destroy tiles with staggered delays (0.2s - 2s random per tile)
  let tilesDestroyed = 0;
  for(let i = 0; i < torretTilesPerShot && availableTiles.length > 0; i++){
    const randomPos = Math.floor(Math.random() * availableTiles.length);
    const tileIdx = availableTiles[randomPos];
    const tile = fieldData[currentField][tileIdx];
    
    if(tile && tile.ty !== -1){
      // Random delay between 0.2s and 2s for each tile destruction
      const randomDelay = 200 + Math.random() * 1800;
      setTimeout(() => {
        try {
          applyToolPattern(tileIdx, currentField);
        } catch(e) {
          console.error('ðŸŽ¯ Error destroying tile:', e);
        }
      }, randomDelay);
      tilesDestroyed++;
      // Remove this tile from available list
      availableTiles.splice(randomPos, 1);
    }
  }
  
  if(tilesDestroyed > 0){
    console.log(`ðŸŽ¯ Torreta fired! Destroying ${tilesDestroyed}/${torretTilesPerShot} tiles with staggered timing`);
  }
  torretLastTime = Date.now();
}

document.getElementById("pollen").textContent=fmt(stats.pollen);
document.getElementById("honey").textContent=fmt(stats.honey);
document.getElementById("tickets").textContent=tickets;
const capacity = calculateCapacity();
document.getElementById("capacity").textContent=fmt(capacity);
document.getElementById("pollenSec").textContent=fmt(pollenThisSec);
document.getElementById("honeySec").textContent=fmt(honeyThisSec);
updatePlayerStatsPanel();

  // update current field title + requirement
  const fieldNameEl = document.getElementById('fieldName');
  if(fieldNameEl) fieldNameEl.textContent = fields[currentField] ? fields[currentField].name : currentField;
  

}

/* ================= STATS PANEL ================= */
function updatePlayerStatsPanel(){
  const playerStatsPanelEl = document.getElementById("playerStatsPanel");
  
  // OptimizaciÃ³n: solo actualizar si el panel existe y no es la primera carga
  if(!playerStatsPanelEl) return;
  
  // Intentar actualizar solo los valores dinÃ¡micos en lugar de regenerar todo
  const toolCounterEl = playerStatsPanelEl.querySelector(`[data-stat="toolCounter"]`);
  const storageCounterEl = playerStatsPanelEl.querySelector(`[data-stat="storageCounter"]`);
  const beeCounterEl = playerStatsPanelEl.querySelector(`[data-stat="beeCounter"]`);
  const colorBonusEls = playerStatsPanelEl.querySelectorAll(`[data-stat="colorBonus"]`);
  
  // Si los elementos no existen, hacer render completo
  if(!toolCounterEl || !storageCounterEl) {
    renderFullPlayerStatsPanel(playerStatsPanelEl);
    return;
  }
  
  // Actualizar contadores de herramientas
  if(equippedToolId === 'porcelain_grandmaster') {
    toolCounterEl.textContent = `${grandmasterTilesDestroyed}/200`;
  } else if(equippedToolId === 'porcelain_dipper') {
    toolCounterEl.textContent = `${porcelainTilesDestroyed}/100`;
  }
  
  // Actualizar contador de storage
  if(equippedStorageId === 'coconut_bag') {
    storageCounterEl.textContent = `${fmt(coconutBagPollenStored)}/1000000`;
  }
  
  // Actualizar multiplicadores de color
  if(colorBonusEls.length > 0) {
    const colorValues = {
      'white': whitePollenMultiplier.toFixed(2),
      'red': redPollenMultiplier.toFixed(2),
      'blue': bluePollenMultiplier.toFixed(2),
      'yellow': yellowPollenMultiplier.toFixed(2),
      'purple': purplePollenMultiplier.toFixed(2)
    };
    colorBonusEls.forEach(el => {
      const color = el.getAttribute('data-color');
      if(colorValues[color]) el.textContent = `x${colorValues[color]}`;
    });
  }
}

// FunciÃ³n para render completo (solo se llama cuando es necesario)
function renderFullPlayerStatsPanel(playerStatsPanelEl){
  const activeSynergies = SYNERGIES.filter(s => s.requirement.every(req => equippedBees.includes(req)));
  let synergiesHtml = '';
  if(activeSynergies.length > 0){
    synergiesHtml += `<div style="text-align:left;margin-bottom:6px;color:#AEF1C4;font-size:13px"><b>âš¡ Active Synergies:</b></div>`;
    activeSynergies.forEach(s => {
      const bonuses = Object.entries(s.bonus).map(([k,v])=>{
        const label = k.replace(/([A-Z])/g,' $1');
        const val = (String(k).toLowerCase().includes('chance') || String(k).toLowerCase().includes('power')) ? `${v}` : `${v}%`;
        return `<div style="font-size:12px;color:#CFF1D6;margin-left:6px">â€¢ ${s.name}: ${label.trim()} ${val}</div>`;
      }).join('');
      synergiesHtml += bonuses;
    });
  } else {
    synergiesHtml = `<div style="text-align:center;margin-bottom:6px;color:#888;font-size:13px">âš¡ Synergies: None</div>`;
  }
  playerStatsPanelEl.innerHTML=`
<div style="position:relative;width:100%;">
  <button class="question-btn" onclick="openTutorial()" title="Game Guide" style="position:absolute;top:-8px;right:0;z-index:100">?</button>
  <h3>ðŸ“Š Stats</h3>
</div>
${synergiesHtml}
<b style="color:#f1c40f;font-size:12px">General</b>
<div class="player-stat"><span>ðŸ¯ Total Honey</span><span>${fmt(stats.totalHoney)}</span></div>
<div class="player-stat"><span>â±ï¸ Playtime</span><span>${formatTime(playTime)}</span></div>
<div class="player-stat"><span>ðŸ”§ Tool</span><span>${equippedTool}</span></div>
<div class="player-stat"><span>ðŸ“¦ Storage</span><span>${(() => { const st = STORAGE.find(st => st.id === equippedStorageId); return st ? st.name : 'None'; })()}</span></div>
${equippedToolId === 'porcelain_grandmaster' ? `<div class="player-stat"><span>â­ GM Porcelain</span><span data-stat="toolCounter">${grandmasterTilesDestroyed}/200</span></div>` : ''}
${equippedToolId === 'porcelain_dipper' ? `<div class="player-stat"><span>ðŸ’§ Dipper Tool</span><span data-stat="toolCounter">${porcelainTilesDestroyed}/100</span></div>` : ''}
${equippedStorageId === 'coconut_bag' ? `<div class="player-stat"><span>ðŸ¥¥ Coconut Bag</span><span data-stat="storageCounter">${fmt(coconutBagPollenStored)}/1000000</span></div>` : ''}
${grandmasterActive ? `<div class="player-stat" style="background:rgba(255,215,0,0.2);border-left:3px solid #FFD700"><span>â­ Grandmaster</span><span>x31 POLLEN</span><span style="font-size:11px;color:#FFD700">${grandmasterBuffTimeLeft}s</span></div>` : ''}
${porcelainBuffActive ? `<div class="player-stat" style="background:rgba(65,105,225,0.2);border-left:3px solid #4169E1"><span>ðŸ’§ Dipper Buff</span><span>x4 POLLEN</span><span style="font-size:11px;color:#4169E1">${porcelainBuffTimeLeft}s</span></div>` : ''}
${coconutBagBuffActive ? `<div class="player-stat" style="background:rgba(255,228,181,0.2);border-left:3px solid #FFE4B5"><span>ðŸ¥¥ Coconut Buff</span><span>x3 WHITE</span><span style="font-size:11px;color:#FFE4B5">${coconutBagBuffTimeLeft}s</span></div>` : ''}
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Bonuses</b>
<div class="player-stat"><span>ðŸŒ¸ Pollen Bonus</span><span>+${stats.pollenBonus + stats.beePollenBonus + (getToolBuffs(equippedToolId).pollenBonus || 0) + (getStorageBuffs(equippedStorageId).pollenBonus || 0)}%</span></div>
<div class="player-stat"><span>ðŸ¯ Convert Rate</span><span>+${stats.convertBonus + stats.beeConvertBonus + (getToolBuffs(equippedToolId).convertBonus || 0) + (getStorageBuffs(equippedStorageId).convertBonus || 0)}%</span></div>
<div class="player-stat"><span>ðŸ“¦ Capacity</span><span>${fmt(calculateCapacity())}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Combat</b>
<div class="player-stat"><span>âš¡ Crit Power</span><span>x${(stats.criticalPower + stats.beeCriticalPower + (getToolBuffs(equippedToolId).criticalPower || 0) + (getStorageBuffs(equippedStorageId).criticalPower || 0)).toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ’¥ Crit Chance</span><span>${stats.criticalChance + stats.beeCriticalChance + (getToolBuffs(equippedToolId).criticalChance || 0) + (getStorageBuffs(equippedStorageId).criticalChance || 0)}%</span></div>
<div class="player-stat"><span>ðŸŒŸ Super Critical</span><span>${stats.superCriticalChance}% (x10)</span></div>
<div class="player-stat"><span>âš™ï¸ Instant Conv</span><span>${stats.instantConversion + stats.beeInstantConversion + (getToolBuffs(equippedToolId).instantConversion || 0) + (getStorageBuffs(equippedStorageId).instantConversion || 0)}%</span></div>
<div class="player-stat"><span>ðŸ¯ Honey Bonus</span><span>+${stats.honeyBonus + (getToolBuffs(equippedToolId).honeyBonus || 0) + (getStorageBuffs(equippedStorageId).honeyBonus || 0)}%</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Color Bonuses</b>
<div class="player-stat"><span>âšª White</span><span data-stat="colorBonus" data-color="white">x${(whitePollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ”´ Red</span><span data-stat="colorBonus" data-color="red">x${(redPollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ”µ Blue</span><span data-stat="colorBonus" data-color="blue">x${(bluePollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ’› Yellow</span><span data-stat="colorBonus" data-color="yellow">x${(yellowPollenMultiplier).toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ’œ Purple</span><span data-stat="colorBonus" data-color="purple">x${(purplePollenMultiplier).toFixed(2)}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Total Collected</b>
<div class="player-stat"><span>âšª White Total</span><span>${fmt(stats.whiteTotal)}</span></div>
<div class="player-stat"><span>ðŸ”´ Red Total</span><span>${fmt(stats.redTotal)}</span></div>
<div class="player-stat"><span>ðŸ”µ Blue Total</span><span>${fmt(stats.blueTotal)}</span></div>
<div class="player-stat"><span>ðŸ’› Yellow Total</span><span>${fmt(stats.yellowTotal)}</span></div>
<div class="player-stat"><span>ðŸ’œ Purple Total</span><span>${fmt(stats.purpleTotal)}</span></div>
<hr style="opacity:.2">
<b style="color:#f1c40f;font-size:12px">Multipliers</b>
<div class="player-stat"><span>ðŸ”¥ Fire</span><span>x${stats.fireMultiplier.toFixed(1)}</span></div>
<div class="player-stat"><span>ðŸŒ‘ Dark Fire</span><span>x${stats.darkFireMultiplier.toFixed(1)}</span></div>
<div class="player-stat"><span>ðŸ’— Goo</span><span>x${stats.gooMultiplier.toFixed(2)}</span></div>
<div class="player-stat"><span>ðŸ«§ Bubble</span><span>x${stats.bubbleMultiplier.toFixed(1)}</span></div>
<div class="player-stat"><span>ðŸ’— Goo Pollen</span><span>${fmt(stats.gooPollenCollected)}</span></div>
${equippedBees.length > 0 ? `<hr style="opacity:.2">
<div class="player-stat"><span>ðŸ Equipped</span><span>${equippedBees.length}/${maxSlots}</span></div>
<div class="player-stat"><span>ðŸ Max Equipped Ever</span><span>${maxEquippedBeesEver}</span></div>
${stats.beePollenBonus > 0 ? `<div class="player-stat"><span>ðŸŒ¸ Bee Pollen</span><span>+${stats.beePollenBonus}%</span></div>` : ''}
${stats.beeConvertBonus > 0 ? `<div class="player-stat"><span>ðŸ¯ Bee Convert</span><span>+${stats.beeConvertBonus}%</span></div>` : ''}
${stats.beeCriticalChance > 0 ? `<div class="player-stat"><span>ðŸ’¥ Bee Crit</span><span>+${stats.beeCriticalChance}%</span></div>` : ''}
${stats.beeCriticalPower > 0 ? `<div class="player-stat"><span>âš¡ Bee Power</span><span>+${stats.beeCriticalPower.toFixed(2)}</span></div>` : ''}
${stats.beeInstantConversion > 0 ? `<div class="player-stat"><span>âš™ï¸ Bee Conv</span><span>+${stats.beeInstantConversion}%</span></div>` : ''}
${(() => {
  const synergies = SYNERGIES.filter(s => s.requirement.every(req => equippedBees.includes(req)));
  return synergies.length > 0 ? `<div class="player-stat"><span>âš¡ Synergies</span><span>${synergies.length}</span></div>` : '';
})()}` : ''}
<hr style="opacity:.2">
<div style="display:flex;gap:6px;margin-top:8px">
  <button class="small-btn" onclick="openSavesManager()" style="flex:1;font-size:11px;padding:6px 4px">ðŸ“ Saves</button>
</div>
`;
}

// Helper function to get the bee name and ability index for an ability
function getBeeAbilityInfo(abilityName) {
  // Search in BEES and SPECIAL_BEES for the bee that has this ability
  const allBees = [...BEES, ...SPECIAL_BEES];
  let beeWithAbility = null;
  
  for(let bee of allBees) {
    if(bee.ability === abilityName) {
      beeWithAbility = bee;
      break;
    }
  }
  
  if(!beeWithAbility) return null;
  
  // Count how many bees with the same name have abilities
  const beesWithSameName = allBees.filter(b => b.name === beeWithAbility.name && b.ability);
  let abilityIndex = 1;
  
  if(beesWithSameName.length > 1) {
    abilityIndex = beesWithSameName.findIndex(b => b.id === beeWithAbility.id) + 1;
  }
  
  return {
    beeName: beeWithAbility.name,
    abilityIndex: abilityIndex
  };
}

// Register ability execution to show it in the abilities grid for 10 seconds
function registerAbilityExecution(abilityName){
  if(!abilityName || !ABILITY_TYPES[abilityName]) return;
  
  // Get ability info from ABILITY_TYPES
  const abilityDef = ABILITY_TYPES[abilityName];
  
  // Get bee name and ability index
  const beeAbilityInfo = getBeeAbilityInfo(abilityName);
  let imgPath = abilityDef.img; // fallback to original
  
  if(beeAbilityInfo) {
    const beeName = beeAbilityInfo.beeName.toLowerCase().replace(/\s+/g, '');
    if(beeAbilityInfo.abilityIndex > 1) {
      imgPath = `${beeName}${beeAbilityInfo.abilityIndex}.png`;
    } else {
      imgPath = `${beeName}.png`;
    }
  }
  
  // Add to active abilities
  activeAbilities.push({
    ability: abilityName,
    name: abilityDef.name,
    color: abilityDef.color,
    img: imgPath,
    desc: abilityDef.desc,
    executeTime: Date.now(),
    maxCooldown: abilityDef.maxCooldown || 3
  });
}

// Update abilities grid with recently executed abilities

// ABILITIES GRID - REMOVED

// Get cooldown info for a specific ability
function getCooldownInfo(abilityName){
  const now = Date.now();
  
  // Map abilities to their cooldown timers with max cooldown
  const cooldownMap = {
    'fireBeeAbility': { nextTime: lastFireBeeAbility + 3000, maxCooldown: 3 },
    'spicyAbility': { nextTime: lastSpicyAbility + 2000, maxCooldown: 2 },
    'demonBeeAbility': { nextTime: lastDemonAbility + 4000, maxCooldown: 4 },
    'laserBeeAbility': { nextTime: lastLaserAbility + 2000, maxCooldown: 2 },
    'gooAbility': { nextTime: lastGooGeneration + 2000, maxCooldown: 2 },
    'teslaBeeAbility': { nextTime: lastTeslaBeeAbility + 3000, maxCooldown: 3 },
    'thunderBeeAbility': { nextTime: lastThunderBeeAbility + 2000, maxCooldown: 2 },
    'photonAbility': { nextTime: lastPhotonAbility + 0.5 * 1000 + Math.random() * 1500, maxCooldown: 2 },
    'digitalRandomEffect': { nextTime: lastDigitalRandomEffect + 30000, maxCooldown: 30 },
    'digitalGlitch': { nextTime: lastDigitalGlitch + 60000 + Math.random() * 60000, maxCooldown: 120 },
    'moonBeeAbility': { nextTime: lastMoonLaser + 3000, maxCooldown: 3 },
    'lionBeeAutoDestruct': { nextTime: lastLionDestruction + 30000 + Math.random() * 30000, maxCooldown: 60 },
    'fourFormation': { nextTime: lastFourFormation + 2000, maxCooldown: 2 }
  };
  
  return cooldownMap[abilityName] || null;
}

// Show ability tooltip
function showAbilityTooltip(event, name, ability, desc){
  let html = `<b>${name}</b><br><i style="color:#f1c40f">${ability}</i><br><br>${desc}`;
  
  const tt = document.getElementById('abilityTooltip') || document.createElement('div');
  tt.id = 'abilityTooltip';
  tt.className = 'ability-tooltip';
  tt.innerHTML = html;
  tt.style.left = event.pageX + 10 + 'px';
  tt.style.top = event.pageY + 10 + 'px';
  document.body.appendChild(tt);
}

// Hide ability tooltip
function hideAbilityTooltip(){
  const tt = document.getElementById('abilityTooltip');
  if(tt) tt.remove();
}

function drawPattern(p){
  return p.map(r=>`
    <div class="row">
      ${r.map(c=>`<span class="${c?"on":"off"}"></span>`).join("")}
    </div>
  `).join("");
}

// Draw a 9x9 tool pattern as a DOM grid optimized for tool frames
function drawToolPatternDOM(pattern){
  const grid = document.createElement('div');
  grid.className = 'tool-grid';
  // ensure we always render 9x9
  const rows = 9;
  const cols = 9;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      const val = (pattern && pattern[y] && pattern[y][x]) ? pattern[y][x] : 0;
      if(val) cell.classList.add('on');
      grid.appendChild(cell);
    }
  }
  return grid;
}

// Helper function to create search input for shop sections
function createSearchInput(container, dataAttributes) {
  const searchWrapper = document.createElement('div');
  searchWrapper.style.cssText = 'margin-bottom:16px;';
  
  const searchInput = document.createElement('input');
  searchInput.type = 'text';
  searchInput.placeholder = 'Search...';
  searchInput.style.cssText = 'width:100%;padding:8px 12px;background:#262626;color:#fff;border:1px solid #444;border-radius:0px;font-size:14px;box-sizing:border-box;';
  
  // dataAttributes is an array of attribute names to search (e.g., ['data-tool-name', 'data-upgrade-name'])
  searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const frames = container.querySelectorAll('[data-frame="true"]');
    frames.forEach(frame => {
      let found = false;
      for(let attr of dataAttributes) {
        const value = frame.getAttribute(attr);
        if(value && value.toLowerCase().includes(searchTerm)) {
          found = true;
          break;
        }
      }
      frame.style.display = found ? '' : 'none';
    });
  });
  
  searchWrapper.appendChild(searchInput);
  container.insertBefore(searchWrapper, container.firstChild);
  return searchInput;
}

function buildTools(){
  const toolsEl = document.getElementById("tools");
  toolsEl.innerHTML="";
  
  // Add main category title
  const categoryTitle = document.createElement('div');
  categoryTitle.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:18px;margin:0 0 12px 0;text-transform:uppercase;padding-bottom:8px;border-bottom:2px solid #444;';
  categoryTitle.textContent = 'Tools';
  toolsEl.appendChild(categoryTitle);
  
  // Add search input
  createSearchInput(toolsEl, ['data-tool-name']);
  
  // Rarity order and colors
  const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'mythic', 'ultimate'];
  const rarityColors = {
    'common': '#CD7F32',
    'rare': '#C0C0C0',
    'epic': '#FFD700',
    'legendary': '#00eeff',
    'mythic': '#9b59b6',
    'ultimate': '#ff0000'
  };
  
  // Group tools by rarity
  const toolsByRarity = {};
  rarityOrder.forEach(r => {
    toolsByRarity[r] = TOOLS.filter(t => t.rarity === r);
    // Sort tools within each rarity by price (ascending - cheapest first)
    toolsByRarity[r].sort((a, b) => {
      return (a.price || 0) - (b.price || 0);
    });
  });
  
  // Render each rarity category
  const toolsCategoryState = getCategoryState('tools');
  
  rarityOrder.forEach(rarity => {
    const toolsInRarity = toolsByRarity[rarity];
    if(toolsInRarity.length === 0) return;
    
    // Add rarity header with toggle
    const { container: headerContainer, button: toggleBtn } = createCategoryHeader(
      rarity.charAt(0).toUpperCase() + rarity.slice(1) + ' Tools',
      rarity,
      rarityColors
    );
    toolsEl.appendChild(headerContainer);
    
    // Create container for this rarity's items
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'rarity-frames-container';
    itemsContainer.setAttribute('data-rarity-container', rarity);
    
    // Check if this rarity was previously collapsed
    if(toolsCategoryState.collapsed[rarity]){
      itemsContainer.style.display = 'none';
      toggleBtn.classList.add('collapsed');
      toggleBtn.textContent = 'â–¶';
    }
    
    // Attach toggle functionality
    toggleBtn.onclick = (e) => {
      e.stopPropagation();
      toggleCategoryVisibility(toggleBtn, itemsContainer, 'tools', rarity);
    };
    
    toolsEl.appendChild(itemsContainer);
    
    // Render tools in this rarity
    toolsInRarity.forEach(t => {
      const owned = ownedTools.includes(t.id);
      const equipped = equippedToolId === t.id;

      const f = document.createElement('div');
      f.className = 'tool-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-tool-id', t.id);
      f.setAttribute('data-tool-name', t.name);
      f.setAttribute('data-rarity', t.rarity);
      
      // top-left: name + desc
      const top = document.createElement('div');
      top.className = 'tool-top';
      const nameEl = document.createElement('div'); 
      nameEl.className='tool-name'; 
      nameEl.style.fontSize='16px';
      nameEl.style.color = rarityColors[t.rarity] || '#f1c40f';
      if(t.rarity === 'ultimate') nameEl.className = 'tool-name ultimate-name';
      else if(t.rarity === 'mythic') nameEl.style.textShadow = '0 0 12px rgba(155, 89, 182, 0.8), 0 0 20px rgba(155, 89, 182, 0.8)';
      else if(t.rarity === 'legendary') nameEl.style.textShadow = `0 0 8px ${rarityColors[t.rarity]}`;
      nameEl.textContent = t.name;
      const descEl = document.createElement('div'); descEl.className='tool-desc'; descEl.style.fontSize='13px'; descEl.textContent = t.desc;
      top.appendChild(nameEl); 
      top.appendChild(descEl);
      
      // Add ability info
      if(t.ability){
        const abilityEl = document.createElement('div');
        abilityEl.className='upgrade-desc';
        abilityEl.style.color='#FFD700';
        abilityEl.style.marginTop='4px';
        abilityEl.style.fontWeight='bold';
        abilityEl.innerHTML = `<div style="margin-bottom:2px">

          * ABILITY:</div><div style="color:#AEF1C4;font-weight:normal;font-size:12px">${t.ability}</div>`;
        top.appendChild(abilityEl);
      }
      
      // Add stats info
      const tilesCount = (t.pattern || []).reduce((acc,row)=>acc + (row.reduce?row.reduce((a,b)=>a+b,0):0),0);
      const statsEl = document.createElement('div'); 
      statsEl.className='upgrade-desc'; 
      statsEl.style.color='#aef1c4';
      statsEl.style.marginTop='4px';
      statsEl.textContent = `${tilesCount} tiles â€¢ Pollen: +${t.pollenBonus}% â€¢ Cooldown: ${t.cooldown/1000}s`;
      top.appendChild(statsEl);
      
      f.appendChild(top);

      // top-right tool image
      if(t.img){
        const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/3'; art.style.display='flex'; art.style.flexDirection='column'; art.style.alignItems='center'; art.style.justifyContent='flex-start'; art.style.gap='4px';
        const imgEl = document.createElement('img'); imgEl.src = `images/${t.img}`; imgEl.style.width='64px'; imgEl.style.height='64px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='0px';
        imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }

      // Benefits list
      const benefitsEl = document.createElement('div');
      benefitsEl.style.fontSize = '12px';
      benefitsEl.style.marginTop = '6px';
      benefitsEl.style.padding = '4px';
      benefitsEl.style.background = 'rgba(0,0,0,0.3)';
      benefitsEl.style.borderRadius = '0px';
      let benefitsHTML = '<div style="color:#AEF1C4;font-weight:bold;margin-bottom:3px">Benefits:</div>';
      if(t.pollenBonus) benefitsHTML += `<div>â€¢ Pollen: +${t.pollenBonus}%</div>`;
      if(t.cooldown) benefitsHTML += `<div>â€¢ Cooldown: ${t.cooldown/1000}s</div>`;
      if(tilesCount) benefitsHTML += `<div>â€¢ Tiles: ${tilesCount}</div>`;
      if(t.bonuses){
        Object.entries(t.bonuses).forEach(([k,v]) => {
          const label = k.replace(/([A-Z])/g,' $1').trim();
          benefitsHTML += `<div>â€¢ ${label}: +${v}${(k.includes('bonus')||k.includes('rate'))?'%':''}</div>`;
        });
      }
      benefitsEl.innerHTML = benefitsHTML;
      f.appendChild(benefitsEl);

      // pattern area on center-right
      const patWrap = document.createElement('div'); patWrap.className='tool-pattern'; patWrap.appendChild(drawToolPatternDOM(t.pattern));
      f.appendChild(patWrap);

      // bottom row: button (left) and price (right)
      const btn = document.createElement('button'); btn.className='small-btn';
      btn.style.minWidth = '50px';
      const bottom = document.createElement('div'); bottom.className='tool-bottom';
      if(!owned){
        btn.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        btn.setAttribute('data-buy-btn', 'true');
        btn.setAttribute('data-price', t.price);
        btn.setAttribute('data-price-type', 'honey');
        
        const canAfford = stats.honey >= t.price;
        if(canAfford){
          btn.classList.add('btn-can-afford');
        } else {
          btn.classList.add('btn-cannot-afford');
          btn.disabled = true;
        }
        btn.onclick = ()=>{
          if(stats.honey < t.price) return; stats.honey -= t.price; ownedTools.push(t.id); equipTool(t.id); buildTools(); updateUI(); saveGame();
        };
      } else if(!equipped){
        btn.textContent = 'EQUIP';
        btn.classList.add('btn-purchased');
        btn.onclick = ()=>{ equipTool(t.id); buildTools(); updateUI(); saveGame(); };
      } else { 
        btn.textContent='EQUIPPED'; 
        btn.classList.add('btn-equipped');
        btn.disabled = true; 
      }

      bottom.appendChild(btn);
      f.appendChild(bottom);
      const priceWrap = document.createElement('div');
      priceWrap.className = 'tool-price-wrap';
      const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = fmt(t.price) + ' ðŸ¯';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);

      itemsContainer.appendChild(f);
    });
  });
}

function equipTool(id){
  // remove bonuses from previously equipped tool
  const prevTool = TOOLS.find(t=>t.id===equippedToolId);
  if(prevTool && prevTool.bonuses){
    for(const [k,v] of Object.entries(prevTool.bonuses)){
      stats[k] = (stats[k] || 0) - v;
    }
  }

  equippedToolId = id;
  const tool = TOOLS.find(t=>t.id===id);
  if(tool){
    equippedTool = tool.name;
    stats.cooldown = tool.cooldown;
    if(tool.bonuses){
      for(const [k,v] of Object.entries(tool.bonuses)){
        stats[k] = (stats[k] || 0) + v;
      }
    }
    showNotification(`Tool equipada: ${tool.name}`, 'success');
  }

  saveGame();
  buildTools();
  updateUI();
}

function equipBee(beeId, slot){
  if(slot === undefined) {
    if(equippedBees.length < maxSlots) {
      equippedBees.push(beeId);
      // actualizar mÃ¡ximo histÃ³rico
      maxEquippedBeesEver = Math.max(maxEquippedBeesEver, equippedBees.length);
    } else {
      return;
    }
  } else {
    equippedBees[slot] = beeId;
    maxEquippedBeesEver = Math.max(maxEquippedBeesEver, equippedBees.filter(Boolean).length);
  }
  
  recalculateAllBuffs(); // Recalculate tracking
  updateBeeAbilities(); // Update abilities
  saveGame();
  buildBeeGrid();
  updateUI();
  // Update bee counter in real-time
  const counterDiv = document.getElementById('beeCounterDiv');
  if(counterDiv) updateBeeCounter(counterDiv);
}

function unequipBee(slot){
  equippedBees.splice(slot, 1);
  recalculateAllBuffs(); // Recalculate tracking
  updateBeeAbilities(); // Update abilities
  saveGame();
  buildBeeGrid();
  updateUI();
  // Update bee counter in real-time
  const counterDiv = document.getElementById('beeCounterDiv');
  if(counterDiv) updateBeeCounter(counterDiv);
}

/* ================= ADVANCED BUFF MANAGEMENT SYSTEM ================= */

// Recalculate all active buffs from equipped bees, tools, and storage
function recalculateAllBuffs() {
  activeBeeBuffs = {};
  activeToolBuffs = {};
  activeStorageBuffs = {};
  
  // Apply bee buffs
  if(equippedBees && equippedBees.length > 0) {
    equippedBees.forEach(beeId => {
      const buffs = getBeeBuffs(beeId);
      if(buffs) applyBuffsToTracking(buffs, beeId, 'bee', activeBeeBuffs);
    });
  }
  
  // Apply special bee buffs
  if(equippedSpecialBees) {
    const specialIds = Array.isArray(equippedSpecialBees) ? equippedSpecialBees : [equippedSpecialBees];
    specialIds.forEach(specialBeeId => {
      if(specialBeeId) {
        const buffs = getBeeBuffs(specialBeeId);
        if(buffs) applyBuffsToTracking(buffs, specialBeeId, 'bee', activeBeeBuffs);
      }
    });
  }
  
  // Apply tool buffs if any
  if(equippedToolId) {
    const toolBuff = getToolBuffs(equippedToolId);
    if(toolBuff) applyBuffsToTracking(toolBuff, equippedToolId, 'tool', activeToolBuffs);
  }
  
  // Apply storage buffs if any
  if(equippedStorageId) {
    const storageBuff = getStorageBuffs(equippedStorageId);
    if(storageBuff) applyBuffsToTracking(storageBuff, equippedStorageId, 'storage', activeStorageBuffs);
  }
}

// Helper to apply buffs to tracking object
function applyBuffsToTracking(buffs, sourceId, sourceType, targetObject) {
  if(!buffs) return;
  for(const [buffType, value] of Object.entries(buffs)) {
    if(buffType === 'colorMultipliers') continue; // Handle separately
    if(!targetObject[buffType]) targetObject[buffType] = {};
    targetObject[buffType][sourceId] = value;
  }
}

// Get combined value of a specific buff from all sources
function getTotalBuff(buffType, fromBees = true, fromTools = true, fromStorage = true) {
  let total = 0;
  if(fromBees) {
    for(const [source, value] of Object.entries(activeBeeBuffs[buffType] || {})) {
      total += value;
    }
  }
  if(fromTools) {
    for(const [source, value] of Object.entries(activeToolBuffs[buffType] || {})) {
      total += value;
    }
  }
  if(fromStorage) {
    for(const [source, value] of Object.entries(activeStorageBuffs[buffType] || {})) {
      total += value;
    }
  }
  return total;
}

// Get combined multiplier for special effects (fire, dark fire, goo) from all sources
function getTotalMultiplier(multiplierType, fromBees = true, fromTools = true, fromStorage = true) {
  let multiplier = 1;
  if(fromBees) {
    for(const beeId of (equippedBees || [])) {
      const buffs = getBeeBuffs(beeId);
      if(buffs && buffs[multiplierType]) {
        multiplier *= buffs[multiplierType];
      }
    }
    // Special bees
    if(equippedSpecialBees) {
      const specialIds = Array.isArray(equippedSpecialBees) ? equippedSpecialBees : [equippedSpecialBees];
      specialIds.forEach(specialBeeId => {
        if(specialBeeId) {
          const buffs = getBeeBuffs(specialBeeId);
          if(buffs && buffs[multiplierType]) {
            multiplier *= buffs[multiplierType];
          }
        }
      });
    }
  }
  if(fromTools && equippedToolId) {
    const toolBuff = getToolBuffs(equippedToolId);
    if(toolBuff && toolBuff[multiplierType]) {
      multiplier *= toolBuff[multiplierType];
    }
  }
  if(fromStorage && equippedStorageId) {
    const storageBuff = getStorageBuffs(equippedStorageId);
    if(storageBuff && storageBuff[multiplierType]) {
      multiplier *= storageBuff[multiplierType];
    }
  }
  return multiplier;
}

// Get color multipliers from all sources
function getTotalColorMultipliers() {
  const colors = {red: 1, blue: 1, white: 1, yellow: 1, purple: 1};
  
  // From bees
  if(equippedBees && equippedBees.length > 0) {
    equippedBees.forEach(beeId => {
      const buffs = getBeeBuffs(beeId);
      if(buffs && buffs.colorMultipliers) {
        Object.entries(buffs.colorMultipliers).forEach(([color, mult]) => {
          colors[color] *= mult;
        });
      }
    });
  }
  
  // From special bees
  if(equippedSpecialBees) {
    const specialIds = Array.isArray(equippedSpecialBees) ? equippedSpecialBees : [equippedSpecialBees];
    specialIds.forEach(specialBeeId => {
      if(specialBeeId) {
        const buffs = getBeeBuffs(specialBeeId);
        if(buffs && buffs.colorMultipliers) {
          Object.entries(buffs.colorMultipliers).forEach(([color, mult]) => {
            colors[color] *= mult;
          });
        }
      }
    });
  }
  
  return colors;
}

/* ================= BUFF BREAKDOWN UI ================= */

function showBuffBreakdown() {
  const existing = document.getElementById('buffBreakdownModal');
  if(existing) existing.remove();
  
  const modal = document.createElement('div');
  modal.id = 'buffBreakdownModal';
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:4000;';
  
  const panel = document.createElement('div');
  panel.style.cssText = 'background:linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);border:2px solid #FFD700;border-radius:0px;padding:20px;max-width:600px;max-height:80vh;overflow-y:auto;color:#fff;';
  
  let html = '<h2 style="color:#FFD700;margin-top:0;border-bottom:2px solid #FFD700;padding-bottom:10px">ðŸ“Š Buff Breakdown</h2>';
  
  // Group by buff type
  const buffTypes = [
    {key: 'pollenBonus', label: 'ðŸŒ¸ Pollen Bonus'},
    {key: 'convertBonus', label: 'ðŸ¯ Convert Rate'},
    {key: 'instantConversion', label: 'âš™ï¸ Instant Conversion'},
    {key: 'criticalChance', label: 'ðŸ’¥ Critical Chance'},
    {key: 'criticalPower', label: 'âš¡ Critical Power'},
    {key: 'superCriticalChance', label: 'ðŸŒŸ Super Critical'},
    {key: 'capacityBonus', label: 'ðŸ“¦ Capacity'}
  ];
  
  buffTypes.forEach(({key, label}) => {
    const beeContributions = activeBeeBuffs[key] || {};
    const toolContributions = activeToolBuffs[key] || {};
    const storageContributions = activeStorageBuffs[key] || {};
    
    if(Object.keys(beeContributions).length === 0 && Object.keys(toolContributions).length === 0 && Object.keys(storageContributions).length === 0) return;
    
    html += `<div style="margin:15px 0;padding:10px;background:rgba(255,215,0,0.1);border-left:3px solid #FFD700;border-radius:0px">`;
    html += `<div style="color:#FFD700;font-weight:bold;margin-bottom:8px">${label}</div>`;
    
    let total = 0;
    
    // From Bees
    for(const [beeId, value] of Object.entries(beeContributions)) {
      const bee = BEES.find(b => b.id === beeId) || SPECIAL_BEES.find(b => b.id === beeId);
      const beeName = bee ? bee.name : beeId;
      const displayValue = key === 'criticalPower' ? `+${(value * 100).toFixed(0)}%` : `+${value}%`;
      html += `<div style="margin:4px 0;color:#90EE90;font-size:12px">ðŸ ${beeName}: ${displayValue}</div>`;
      total += value;
    }
    
    // From Tools
    for(const [toolId, value] of Object.entries(toolContributions)) {
      const tool = TOOLS.find(t => t.id === toolId);
      const toolName = tool ? tool.name : toolId;
      const displayValue = key === 'criticalPower' ? `+${(value * 100).toFixed(0)}%` : `+${value}%`;
      html += `<div style="margin:4px 0;color:#87CEEB;font-size:12px">ðŸ”¨ ${toolName}: ${displayValue}</div>`;
      total += value;
    }
    
    // From Storage
    for(const [storageId, value] of Object.entries(storageContributions)) {
      const storage = STORAGES && STORAGES.find(s => s.id === storageId);
      const storageName = storage ? storage.name : storageId;
      const displayValue = key === 'criticalPower' ? `+${(value * 100).toFixed(0)}%` : `+${value}%`;
      html += `<div style="margin:4px 0;color:#DDA0DD;font-size:12px">ðŸ“¦ ${storageName}: ${displayValue}</div>`;
      total += value;
    }
    
    // Total
    const totalDisplay = key === 'criticalPower' ? `+${(total * 100).toFixed(0)}%` : `+${total}%`;
    html += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,215,0,0.3);color:#FFD700;font-weight:bold;font-size:13px">= ${totalDisplay}</div>`;
    html += `</div>`;
  });
  
  // Color Multipliers
  const colorMults = getTotalColorMultipliers();
  if(colorMults.red > 1 || colorMults.blue > 1 || colorMults.white > 1 || colorMults.yellow > 1 || colorMults.purple > 1) {
    html += `<div style="margin:15px 0;padding:10px;background:rgba(100,200,255,0.1);border-left:3px solid #64C8FF;border-radius:0px">`;
    html += `<div style="color:#64C8FF;font-weight:bold;margin-bottom:8px">ðŸŽ¨ Color Multipliers</div>`;
    if(colorMults.red > 1) html += `<div style="margin:4px 0;color:#FF6B6B;font-size:12px">ðŸ”´ Red: x${colorMults.red.toFixed(2)}</div>`;
    if(colorMults.blue > 1) html += `<div style="margin:4px 0;color:#4169E1;font-size:12px">ðŸ”µ Blue: x${colorMults.blue.toFixed(2)}</div>`;
    if(colorMults.white > 1) html += `<div style="margin:4px 0;color:#F8F8F8;font-size:12px">âšª White: x${colorMults.white.toFixed(2)}</div>`;
    if(colorMults.yellow > 1) html += `<div style="margin:4px 0;color:#FFD700;font-size:12px">ðŸ’› Yellow: x${colorMults.yellow.toFixed(2)}</div>`;
    if(colorMults.purple > 1) html += `<div style="margin:4px 0;color:#9D4EDD;font-size:12px">ðŸ’œ Purple: x${colorMults.purple.toFixed(2)}</div>`;
    html += `</div>`;
  }
  
  html += `<button onclick="document.getElementById('buffBreakdownModal').remove()" style="margin-top:15px;padding:10px 20px;background:#FFD700;color:#000;border:none;border-radius:0px;cursor:pointer;font-weight:bold">Close</button>`;
  
  panel.innerHTML = html;
  modal.appendChild(panel);
  modal.onclick = (e) => { if(e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
}

/* ================= TILE EFFECT REMOVAL SYSTEM ================= */

function showTileEffectMenu(tileIdx, x, y) {
  // Remove existing menu if any
  const existing = document.getElementById('tileEffectMenu');
  if(existing) existing.remove();
  
  const effects = tileEffectsSystem.getEffects(tileIdx);
  
  if(effects.length === 0) {
    showNotification('No effects on this tile', 'info');
    return;
  }
  
  const menu = document.createElement('div');
  menu.id = 'tileEffectMenu';
  menu.style.cssText = `position:fixed;top:${y}px;left:${x}px;background:#1a1a1a;border:2px solid #FFD700;border-radius:0px;z-index:5000;min-width:200px;box-shadow:0 4px 8px rgba(0,0,0,0.5)`;
  
  let html = '<div style="padding:8px;color:#fff">';
  html += '<div style="color:#FFD700;font-weight:bold;font-size:12px;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid #FFD700">Remove Effects</div>';
  
  effects.forEach((effect, idx) => {
    const label = `${effect.type.toUpperCase()} (${effect.source})`;
    html += `<div style="padding:6px 8px;background:rgba(255,215,0,0.1);margin:4px 0;border-radius:0px;cursor:pointer;color:#90EE90;font-size:11px;transition:all 0.2s" onmouseover="this.style.background='rgba(255,215,0,0.3)';this.style.color='#FFD700'" onmouseout="this.style.background='rgba(255,215,0,0.1)';this.style.color='#90EE90'" onclick="tileEffectsSystem.removeEffect(${tileIdx}, '${effect.type}', '${effect.source}');document.getElementById('tileEffectMenu').remove();renderTile(document.querySelector('[data-idx=\'${tileIdx}\']'), fieldData[currentField][${tileIdx}])">âœ• ${label}</div>`;
  });
  
  html += '<div style="padding:6px 8px;background:rgba(255,100,100,0.1);margin:4px 0 0 0;border-radius:0px;cursor:pointer;color:#FF6B6B;font-size:11px;transition:all 0.2s" onmouseover="this.style.background=\'rgba(255,100,100,0.3)\'" onmouseout="this.style.background=\'rgba(255,100,100,0.1)\'" onclick="tileEffectsSystem.clearTile(${tileIdx});document.getElementById(\'tileEffectMenu\').remove();renderTile(document.querySelector(\'[data-idx=\\\'${tileIdx}\\\']\'), fieldData[currentField][${tileIdx}])">ðŸ—‘ï¸ Clear All</div>';
  
  html += '</div>';
  
  menu.innerHTML = html;
  document.body.appendChild(menu);
  
  // Close menu when clicking elsewhere
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if(e.target !== menu && !menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 100);
}

/* ================= BEE BUFFS SYSTEM ================= */
/**
 * COMO AGREGAR UNA NUEVA BEE:
 * 1. Agregar la bee en el array BEES con: {id, name, rarity, color, colorType, img, desc, ability, value, synergies, tier}
 * 2. Agregar los buffs de la bee en la funciÃ³n getBeeBuffs() con un case para el id de la bee
 * 3. Si la bee tiene habilidades especiales, agregarlas en updateBeeAbilities() o crear una funciÃ³n nueva
 * 
 * ESTRUCTURA DE BUFFS:
 * - pollenBonus: % adicional al pollen recolectado
 * - convertBonus: % adicional al conversion rate
 * - criticalChance: % adicional a critical chance
 * - criticalPower: valor adicional a critical power (ej: 0.05 = +5%)
 * - instantConversion: % adicional al instant conversion
 * - capacityBonus: cantidad adicional a la capacidad
 * - colorMultipliers: {red, blue, white, yellow, purple} para buffs de colores especÃ­ficos
 */

function getBeeBuffs(beeId) {
  // Get buffs from the BUFFS_MAP loaded from configs/bees.js
  // Supported buff properties:
  // - pollenBonus: adds to total pollen
  // - convertBonus: adds to conversion rate
  // - instantConversion: adds to instant conversion
  // - criticalChance: adds to critical chance
  // - criticalPower: adds to critical power (as multiplier: 2 = +200%, 0.05 = +5%)
  // - superCriticalChance: adds to super critical chance
  // - capacityBonus: adds to max capacity
  // - toolCooldownReduction: reduces tool cooldown (0.05 = -5%)
  // - gooMultiplier: multiplier for goo effects
  // - fireMultiplier: multiplier for fire effects
  // - darkFireMultiplier: multiplier for dark fire effects
  // - colorMultipliers: multipliers per specific color
  
  let buffs = BUFFS_MAP[beeId] || {};
  
  // Parse additional buffs from bee description
  const bee = BEES.find(b => b.id === beeId) || SPECIAL_BEES.find(b => b.id === beeId);
  if (bee && bee.desc) {
    const parsedBuffs = parseBuffsFromDescription(bee.desc);
    buffs = mergeBuffs(buffs, parsedBuffs);
  }
  
  return buffs;
}

function getGoldenBeeBuffs(count) {
  // Retorna los buffs de la Golden Bee multiplicados por la cantidad equipada
  if (count <= 0) return {};
  return {
    instantConversion: 5 * count,
    convertBonus: 100 * count,
    capacityBonus: 100000 * count
  };
}

function getLionBeeBuffs(count) {
  // Retorna los buffs de la Lion Bee multiplicados por la cantidad equipada
  if (count <= 0) return {};
  return {
    pollenBonus: 20 * count,
    criticalPower: 10 * count,
    // Lion Bee tambiÃ©n aplica yellowPollenMultiplier x2 (manejado separadamente en updateBeeAbilities)
  };
}

function getMoonBeeBuffs(count) {
  // Retorna los buffs de la Moon Bee multiplicados por la cantidad equipada
  if (count <= 0) return {};
  return {
    colorMultipliers: { blue: 2 * count, purple: 2 * count }
  };
}

function mergeBuffs(buff1, buff2) {
  // Combina dos objetos de buffs, sumando valores numÃ©ricos
  const result = { ...buff1 };
  
  for (let key in buff2) {
    if (key === 'colorMultipliers') {
      result.colorMultipliers = result.colorMultipliers || {};
      for (let color in buff2.colorMultipliers) {
        result.colorMultipliers[color] = (result.colorMultipliers[color] || 1) * buff2.colorMultipliers[color];
      }
    } else {
      result[key] = (result[key] || 0) + buff2[key];
    }
  }
  
  return result;
}

function parseBuffsFromDescription(desc) {
  // Parsea buffs desde la descripciÃ³n de una bee
  // Busca patrones como "Pollen:+10%" o "CriticalPower:0.05" o "Blue:x1.5"
  if (!desc) return {};
  
  const buffs = {};
  const patterns = [
  ];
  
  patterns.forEach(pattern => {
    const match = desc.match(pattern.regex);
    if (match) {
      const value = parseFloat(match[2] || match[1]);
      if (!isNaN(value)) {
        if (pattern.isMult) {
          // Color multiplier
          if (!buffs.colorMultipliers) buffs.colorMultipliers = {};
          buffs.colorMultipliers[pattern.key] = value;
        } else {
          // Regular buff
          buffs[pattern.key] = value;
        }
      }
    }
  });
  
  return buffs;
}

function applyBeeBuffs(beeBonus, buffs) {
  // Aplica los buffs calculados al objeto beeBonus
  // Soporta todas las estadÃ­sticas del jugador
  if (!buffs) return;
  
  // Basic pollen and conversion stats
  beeBonus.pollenBonus = (beeBonus.pollenBonus || 0) + (buffs.pollenBonus || 0);
  beeBonus.convertBonus = (beeBonus.convertBonus || 0) + (buffs.convertBonus || 0);
  beeBonus.instantConversion = (beeBonus.instantConversion || 0) + (buffs.instantConversion || 0);
  
  // Critical stats
  beeBonus.criticalChance = (beeBonus.criticalChance || 0) + (buffs.criticalChance || 0);
  beeBonus.criticalPower = (beeBonus.criticalPower || 0) + (buffs.criticalPower || 0);
  beeBonus.superCriticalChance = (beeBonus.superCriticalChance || 0) + (buffs.superCriticalChance || 0);
  
  // Capacity and backpack
  beeBonus.capacityBonus = (beeBonus.capacityBonus || 0) + (buffs.capacityBonus || 0);
  beeBonus.backpackBonus = (beeBonus.backpackBonus || 0) + (buffs.backpackBonus || 0);
  
  // Cooldown and special effect multipliers - SUMAMOS en lugar de multiplicar
  beeBonus.toolCooldownReduction = (beeBonus.toolCooldownReduction || 0) + (buffs.toolCooldownReduction || 0);
  beeBonus.fireMultiplier = (beeBonus.fireMultiplier || 1) + ((buffs.fireMultiplier || 1) - 1);
  beeBonus.darkFireMultiplier = (beeBonus.darkFireMultiplier || 1) + ((buffs.darkFireMultiplier || 1) - 1);
  beeBonus.gooMultiplier = (beeBonus.gooMultiplier || 1) + ((buffs.gooMultiplier || 1) - 1);
  
  // Goo and honey bonuses
  beeBonus.gooPollenCollected = (beeBonus.gooPollenCollected || 0) + (buffs.gooPollenCollected || 0);
  beeBonus.honeyBonus = (beeBonus.honeyBonus || 0) + (buffs.honeyBonus || 0);
  
  // Bee-specific bonuses
  beeBonus.beePollenBonus = (beeBonus.beePollenBonus || 0) + (buffs.beePollenBonus || 0);
  beeBonus.beeConvertBonus = (beeBonus.beeConvertBonus || 0) + (buffs.beeConvertBonus || 0);
  beeBonus.beeCriticalChance = (beeBonus.beeCriticalChance || 0) + (buffs.beeCriticalChance || 0);
  beeBonus.beeCriticalPower = (beeBonus.beeCriticalPower || 0) + (buffs.beeCriticalPower || 0);
  beeBonus.beeInstantConversion = (beeBonus.beeInstantConversion || 0) + (buffs.beeInstantConversion || 0);
  beeBonus.beeHoneyBonus = (beeBonus.beeHoneyBonus || 0) + (buffs.beeHoneyBonus || 0);
  
  // Color multipliers - SUMAMOS los bonos en lugar de multiplicar
  if (buffs.colorMultipliers) {
    beeBonus.colorMultipliers = beeBonus.colorMultipliers || {};
    for (let color in buffs.colorMultipliers) {
      beeBonus.colorMultipliers[color] = (beeBonus.colorMultipliers[color] || 1) + ((buffs.colorMultipliers[color] || 1) - 1);
    }
  }
}

function getToolBuffs(toolId) {
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF

  // TOOL BUFF
  // TOOL BUFF
  // TOOL BUFF

  // Returns buffs provided by tools from TOOL_BUFFS_MAP loaded from configs/tools.js
  // Tools provide passive bonuses that enhance gameplay, including cooldown reduction
  return TOOL_BUFFS_MAP[toolId] || {};
}

function getStorageBuffs(storageId) {
  // Returns buffs provided by storage containers from STORAGE_BUFFS_MAP loaded from configs/storage.js
  // Storage containers provide capacity bonuses, pollen modifiers, and various multipliers
  return STORAGE_BUFFS_MAP[storageId] || {};
}

function updateBeeAbilities(){
  // Check if equipped items have changed
  const equippedBeesChanged = JSON.stringify(equippedBees) !== JSON.stringify(previousEquippedBees);
  const equippedSpecialBeesChanged = JSON.stringify(equippedSpecialBees) !== JSON.stringify(previousEquippedSpecialBees);
  const toolChanged = equippedToolId !== previousEquippedToolId;
  const storageChanged = equippedStorageId !== previousEquippedStorageId;
  
  // Only recalculate buffs if something changed
  if(equippedBeesChanged || equippedSpecialBeesChanged || toolChanged || storageChanged) {
    recalculateAllBuffs();
    previousEquippedBees = [...(equippedBees || [])];
    previousEquippedSpecialBees = [...(equippedSpecialBees || [])];
    previousEquippedToolId = equippedToolId;
    previousEquippedStorageId = equippedStorageId;
  }
  
  const beeBonus = {pollenBonus:0,convertBonus:0,criticalChance:0,criticalPower:0,instantConversion:0,honeyBonus:0,capacityBonus:0};
  
  // Reset player rank buff stats to prevent accumulation each tick
  // These will be recalculated fresh based on playerRankBuffs
  stats.pollenBonus = 0;
  stats.convertBonus = 0;
  stats.criticalChance = 0;
  stats.criticalPower = 0;
  stats.instantConversion = 0;
  stats.honeyBonus = 0;
  stats.superCriticalChance = 3; // Reset to base value (3%)
  
  // Recalculate tile upgrade bonuses from tileUpgradeLevels
  if(typeof TILE_UPGRADES !== 'undefined' && TILE_UPGRADES.length > 0){
    TILE_UPGRADES.forEach(upgrade => {
      const level = tileUpgradeLevels[upgrade.id] || 0;
      if(level > 0 && upgrade.levels && upgrade.levels[level - 1]){
        const levelData = upgrade.levels[level - 1];
        const bonusValue = levelData.percent !== undefined ? levelData.percent : (levelData.amount !== undefined ? levelData.amount : 0);
        
        // Calculate cumulative bonus from all previous levels
        let totalBonus = 0;
        for(let i = 0; i < level; i++){
          if(upgrade.levels[i]){
            totalBonus += (upgrade.levels[i].percent !== undefined ? upgrade.levels[i].percent : (upgrade.levels[i].amount !== undefined ? upgrade.levels[i].amount : 0));
          }
        }
        
        // Apply the cumulative bonus to the appropriate stat
        if(upgrade.stat === 'criticalChance'){
          stats.criticalChance = totalBonus;
        } else if(upgrade.stat === 'criticalPower'){
          stats.criticalPower = totalBonus;
        } else if(upgrade.stat === 'instantConversion'){
          stats.instantConversion = totalBonus;
        } else if(upgrade.stat === 'pollenBonus'){
          stats.pollenBonus = totalBonus;
        } else if(upgrade.stat === 'convertBonus'){
          stats.convertBonus = totalBonus;
        }
      }
    });
  }
  
  // Reset color multipliers
  redPollenMultiplier = 1.0;
  bluePollenMultiplier = 1.0;
  whitePollenMultiplier = 1.0;
  yellowPollenMultiplier = 1.0;
  purplePollenMultiplier = 1.0;
  
  // Apply pollen color upgrades as additivos bonos - SUMAMOS en lugar de multiplicar
  if(typeof POLLEN_COLOR_UPGRADES !== 'undefined' && POLLEN_COLOR_UPGRADES.length > 0){
    POLLEN_COLOR_UPGRADES.forEach(upgrade => {
      const level = upgradeLevels[upgrade.id] || 0;
      if(level > 0){
        // Calculate cumulative bonus from all levels - SUMAMOS en lugar de multiplicar
        let totalBonus = 0;
        for(let i = 0; i < level; i++){
          if(upgrade.levels[i]){
            const percentBonus = upgrade.levels[i].percent || 0;
            totalBonus += (percentBonus / 100);
          }
        }
        
        // Apply bonus to the appropriate color (sume a los multiplicadores)
        if(upgrade.stat === 'redBonus'){
          redPollenMultiplier += totalBonus;
        } else if(upgrade.stat === 'whiteBonus'){
          whitePollenMultiplier += totalBonus;
        } else if(upgrade.stat === 'blueBonus'){
          bluePollenMultiplier += totalBonus;
        } else if(upgrade.stat === 'yellowBonus'){
          yellowPollenMultiplier += totalBonus;
        } else if(upgrade.stat === 'purpleBonus'){
          purplePollenMultiplier *= totalMultiplier;
        }
      }
    });
  }
  
  // Apply tool color multipliers from buffs - SUMAMOS en lugar de multiplicar
  if(equippedToolId) {
    const toolBuff = getToolBuffs(equippedToolId);
    if(toolBuff && toolBuff.colorMultipliers) {
      if(toolBuff.colorMultipliers.red) redPollenMultiplier += (toolBuff.colorMultipliers.red - 1);
      if(toolBuff.colorMultipliers.blue) bluePollenMultiplier += (toolBuff.colorMultipliers.blue - 1);
      if(toolBuff.colorMultipliers.white) whitePollenMultiplier += (toolBuff.colorMultipliers.white - 1);
      if(toolBuff.colorMultipliers.yellow) yellowPollenMultiplier += (toolBuff.colorMultipliers.yellow - 1);
      if(toolBuff.colorMultipliers.purple) purplePollenMultiplier += (toolBuff.colorMultipliers.purple - 1);
    }
  }
  
  // Apply storage color multipliers from buffs - SUMAMOS en lugar de multiplicar
  if(equippedStorageId) {
    const storageBuff = getStorageBuffs(equippedStorageId);
    if(storageBuff && storageBuff.colorMultipliers) {
      if(storageBuff.colorMultipliers.red) redPollenMultiplier += (storageBuff.colorMultipliers.red - 1);
      if(storageBuff.colorMultipliers.blue) bluePollenMultiplier += (storageBuff.colorMultipliers.blue - 1);
      if(storageBuff.colorMultipliers.white) whitePollenMultiplier += (storageBuff.colorMultipliers.white - 1);
      if(storageBuff.colorMultipliers.yellow) yellowPollenMultiplier += (storageBuff.colorMultipliers.yellow - 1);
      if(storageBuff.colorMultipliers.purple) purplePollenMultiplier += (storageBuff.colorMultipliers.purple - 1);
    }
  }
  
  // Aplicar buffs de bees normales usando el sistema centralizado
  if(equippedBees && equippedBees.length > 0){
    equippedBees.forEach(beeId => {
      const bee = BEES.find(b => b.id === beeId);
      if(bee) {
        // Obtener buffs centralizados de la bee
        const buffs = getBeeBuffs(beeId);
        applyBeeBuffs(beeBonus, buffs);
        
        // Aplicar multiplicadores de color desde los buffs - SUMAMOS en lugar de multiplicar
        if(buffs.colorMultipliers) {
          if(buffs.colorMultipliers.red) redPollenMultiplier += (buffs.colorMultipliers.red - 1);
          if(buffs.colorMultipliers.blue) bluePollenMultiplier += (buffs.colorMultipliers.blue - 1);
          if(buffs.colorMultipliers.white) whitePollenMultiplier += (buffs.colorMultipliers.white - 1);
          if(buffs.colorMultipliers.yellow) yellowPollenMultiplier += (buffs.colorMultipliers.yellow - 1);
          if(buffs.colorMultipliers.purple) purplePollenMultiplier += (buffs.colorMultipliers.purple - 1);
        }
        
        // Apply special bee bonusMultipliers to this bee
        if(equippedSpecialBees && equippedSpecialBees.length > 0){
          equippedSpecialBees.forEach(specialBeeId => {
            const specialBee = SPECIAL_BEES.find(sb => sb.id === specialBeeId);
            if(specialBee && specialBee.bonusMultipliers && specialBee.bonusMultipliers[beeId]){
              // Multiplicar todos los buffs de esta bee por el multiplicador
              const multiplier = specialBee.bonusMultipliers[beeId];
              
              // Aplicar el multiplicador a TODOS los buffs de forma dinÃ¡mica
              Object.keys(buffs).forEach(buffKey => {
                const buffValue = buffs[buffKey];
                
                // Skip color multipliers - they need special handling
                if(buffKey === 'colorMultipliers') return;
                
                // Apply multiplicative bonus for multiplier-type buffs
                if(buffKey === 'fireMultiplier' || buffKey === 'darkFireMultiplier' || 
                   buffKey === 'gooMultiplier' || buffKey === 'bubbleMultiplier') {
                  beeBonus[buffKey] = (beeBonus[buffKey] || 1) * (1 + (multiplier - 1) * (buffValue - 1));
                } 
                // Apply additive bonus for stat-type buffs
                else if(typeof buffValue === 'number') {
                  beeBonus[buffKey] = (beeBonus[buffKey] || 0) + (buffValue * (multiplier - 1));
                }
              });
              
              console.log(`âœ… ${bee.name} (${beeId}) boosted by ${specialBee.name} (x${multiplier})`);
            }
          });
        }
      }
    });
  }
  
  // Check for special ability bees in equippedBees
  const hasFireBee = equippedBees && equippedBees.includes('bee6');
  const hasBouyanbee = equippedBees && equippedBees.includes('bee7');
  const hasSpicyBee = equippedBees && equippedBees.includes('bee8');
  const hasBubbleBee = equippedBees && equippedBees.includes('bee12');
  
  if(hasFireBee){
    abilityQueue.addAbility('fireBeeTick', 'bee6', 1);
  }
  if(hasSpicyBee){
    abilityQueue.addAbility('spicyBeeTick', 'bee8', 1);
  }
  if(hasBubbleBee){
    abilityQueue.addAbility('bubbleBeeTick', 'bee12', 1);
  }
  
  // Check for Ticket Bee
  const hasTicketBee = equippedBees && equippedBees.includes('bee18');
  
  // Check for Golden Bee
  const goldenBeeCount = equippedBees ? equippedBees.filter(id => id === 'bee19').length : 0;
  if(goldenBeeCount > 0){
    abilityQueue.addAbility('goldenBeeAbility', 'bee19', 1);
    tileTicketProbBonus = 0.05;
    // Aplicar buffs de Golden Bee multiplicados por cantidad
    const goldenBuffs = getGoldenBeeBuffs(goldenBeeCount);
    applyBeeBuffs(beeBonus, goldenBuffs);
  } else {
    tileTicketProbBonus = 0;
  }
  
  if(hasTicketBee){
    abilityQueue.addAbility('ticketBeeAbility', 'bee18', 1);
  }
  
  // Check for Lion Bee
  const lionBeeCount = equippedBees && equippedBees.filter(id => id === 'bee20').length || 0;
  if(lionBeeCount > 0){
    abilityQueue.addAbility('lionBeeAbility', 'bee20', 2);
    abilityQueue.addAbility('lionBeeAutoDestruct', 'bee20', 2);
    const lionBuffs = getLionBeeBuffs(lionBeeCount);
    applyBeeBuffs(beeBonus, lionBuffs);
  }
  
  // Check for Moon Bee
  const moonBeeCount = equippedBees && equippedBees.filter(id => id === 'bee23').length || 0;
  if(moonBeeCount > 0){
    abilityQueue.addAbility('moonBeeAbility', 'bee23', 2);
    const moonBuffs = getMoonBeeBuffs(moonBeeCount);
    applyBeeBuffs(beeBonus, moonBuffs);
  }
  
  // Handle other special bees
  const hasDemonBee = equippedBees && equippedBees.includes('bee14');
  const hasDiamondBee = equippedBees && equippedBees.includes('bee15');
  const hasLaserBee = equippedBees && equippedBees.includes('bee16');
  const hasThunderBee = equippedBees && equippedBees.includes('bee17');
  const hasDevilBee = equippedBees && equippedBees.includes('bee24');
  
  if(hasDemonBee){
    abilityQueue.addAbility('demonBeeTick', 'bee14', 1);
  }
  if(hasLaserBee){
    abilityQueue.addAbility('laserBeeTick', 'bee16', 1);
  }
  if(hasThunderBee){
    abilityQueue.addAbility('thunderBeeTick', 'bee17', 1);
  }
  if(hasDevilBee){
    redPollenMultiplier *= 1.5;
  }
  
  // King Crimson Bee ability (only if equipped)
  if(equippedSpecialBees && equippedSpecialBees.includes('special_bee7')){
    abilityQueue.addAbility('kingCrimsonBeeTick', 'special_bee7', 3);
  }
  
  // Crimson Guard Synergy (Royal Guard + King Crimson)
  if(equippedSpecialBees && equippedSpecialBees.includes('special_bee2') && equippedSpecialBees.includes('special_bee7')){
    abilityQueue.addAbility('crimsonGuardSynergyTick', 'special_bee2', 3);
  }
  
  // Update energy tiles and spicy tiles
  updateEnergyTiles();
  updateFireBeeTiles();
  updateSpicyBeeTiles();
  updateBubbleBeeTiles();
  
  // Stop abilities if neither special bees nor ability bees are equipped
  if((!equippedSpecialBees || equippedSpecialBees.length === 0) && !hasFireBee && !hasBouyanbee && !hasSpicyBee && !hasDemonBee && !hasDiamondBee && !hasLaserBee && !hasThunderBee){
    stopSpecialBeeAbilities();
  }
  
  updateSynergies(beeBonus);
  
  // rarity-based convert bonuses (per equipped bee)
  const rarityConvertMap = {common:10, rare:50, epic:100, legendary:150, mythic:200, ultimate:250};
  let rarityConvertBonus = 0;
  if(equippedBees && equippedBees.length > 0){
    equippedBees.forEach(beeId => {
      const bee = BEES.find(b => b.id === beeId);
      if(bee && bee.rarity){
        rarityConvertBonus += (rarityConvertMap[bee.rarity] || 0);
      }
    });
  }
  
  // Add special bees abilities if equipped
  if(equippedSpecialBees && equippedSpecialBees.length > 0){
    equippedSpecialBees.forEach(specialBeeId => {
      const specialBee = SPECIAL_BEES.find(b => b.id === specialBeeId);
      if(specialBee){
        // Apply special bee buffs from the centralized BUFFS_MAP
        const specialBeeBuffs = getBeeBuffs(specialBeeId);
        applyBeeBuffs(beeBonus, specialBeeBuffs);
        
        // Apply color multipliers from special bee buffs - SUMAMOS en lugar de multiplicar
        if(specialBeeBuffs.colorMultipliers) {
          if(specialBeeBuffs.colorMultipliers.red) redPollenMultiplier += (specialBeeBuffs.colorMultipliers.red - 1);
          if(specialBeeBuffs.colorMultipliers.blue) bluePollenMultiplier += (specialBeeBuffs.colorMultipliers.blue - 1);
          if(specialBeeBuffs.colorMultipliers.white) whitePollenMultiplier += (specialBeeBuffs.colorMultipliers.white - 1);
          if(specialBeeBuffs.colorMultipliers.yellow) yellowPollenMultiplier += (specialBeeBuffs.colorMultipliers.yellow - 1);
          if(specialBeeBuffs.colorMultipliers.purple) purplePollenMultiplier += (specialBeeBuffs.colorMultipliers.purple - 1);
        }
        
        if(specialBee.id === 'special_bee1'){ // Golden Queen - 5+ Basic Bees
          const basicBeeCount = (equippedBees || []).filter(id => id === 'bee1').length;
          if(basicBeeCount >= 5){
            // +10000% convert bonus (100x multiplier) + 100% instant conversion
            beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 10000;
            beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 100;
            // Debug log
            console.log(`ðŸ‘‘ Golden Queen Buff Applied! Basic Bees: ${basicBeeCount}, Convert Bonus: +10000%, Instant: +100%`);
          } else {
            console.log(`ðŸ‘‘ Golden Queen - Need 5 basic bees (Have: ${basicBeeCount})`);
          }
        } else if(specialBee.id === 'special_bee2'){ // Royal Guard Bee
          console.log(`ðŸ”´ Royal Guard Bee Equipped! Bonus Multipliers: bee3 x11, bee4 x11`);
        } else if(specialBee.id === 'special_bee3'){ // Gummy Bee
          startGummyBeeSystem();
          gummyBeeTick();
          console.log(`ðŸ¬ Gummy Bee Buff Applied!`);
        } else if(specialBee.id === 'special_bee4'){ // Tesla Bee
          beeBonus.convertBonus = (beeBonus.convertBonus || 0) + 50;
          beeBonus.instantConversion = (beeBonus.instantConversion || 0) + 30;
          bluePollenMultiplier = (bluePollenMultiplier || 1) * 2;
          console.log(`âš¡ Tesla Bee Buff Applied! Convert: +50%, Instant: +30%, Blue Pollen: x2`);
        } else if(specialBee.id === 'special_bee5'){ // Photon Bee
          console.log(`ðŸ’› Photon Bee Equipped! Bonus Multiplier: bee20 x3`);
        } else if(specialBee.id === 'special_bee6'){ // Digital Bee
          console.log(`ðŸ’» Digital Bee Equipped!`);
        } else if(specialBee.id === 'special_bee7'){ // King Crimson Bee
          console.log(`ðŸ‘‘ King Crimson Bee Equipped!`);
        } else {
          console.log(`âœ¨ Special Bee Applied: ${specialBee.name} (${specialBee.id})`);
        }
        beeBonus[specialBee.ability] = (beeBonus[specialBee.ability] || 0) + specialBee.value;
      }
    });
  }
  
  
  // Check for Tesla Bee ability
  const hasTeslaBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee4');
  if(hasTeslaBee){
    abilityQueue.addAbility('teslaBeeAbility', 'special_bee4', 2);
  }
  
  // Check for Four Bee (bee25) - special crit buffs via stats
  const hasFourBee = equippedBees && equippedBees.includes('bee25');
  if(hasFourBee){
    abilityQueue.addAbility('fourBeeAbility', 'bee25', 2);
  }
  
  // Check for Photon Bee
  const hasPhotonBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee5');
  if(hasPhotonBee){
    abilityQueue.addAbility('photonBeeAbility', 'special_bee5', 2);
    
  }
  
  // Check for Digital Bee
  const hasDigitalBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee6');
  if(hasDigitalBee){
    abilityQueue.addAbility('digitalBeeAbility', 'special_bee6', 2);
  }
  
  stats.beePollenBonus = beeBonus.pollenBonus;
  // combine ability-based convert bonus with rarity bonuses
  stats.beeConvertBonus = (beeBonus.convertBonus || 0) + rarityConvertBonus;
  
  // Apply Royal Guard temporary buff and cooldown system
  let royalGuardBonus = 0;
  if(equippedSpecialBees && equippedSpecialBees.includes('special_bee2')){
    const now = Date.now();
    
    // Check cooldown first
    if(royalGuardCooldownActive){
      const cooldownElapsedTime = now - royalGuardCooldownStartTime;
      if(cooldownElapsedTime < 5000){ // 5 second cooldown
        // Still in cooldown, don't count crits
      } else {
        royalGuardCooldownActive = false; // Cooldown expired
      }
    }
    
    // Check buff
    if(royalGuardBuffActive){
      const buffElapsedTime = now - royalGuardBuffStartTime;
      if(buffElapsedTime < 2500){ // 2 second buff duration
        royalGuardBonus = 1000; // +1000% critical chance
      } else {
        royalGuardBuffActive = false; // Buff expired
        royalGuardCooldownActive = true; // Start cooldown
        royalGuardCooldownStartTime = now;
        console.log('â³ Royal Guard cooldown started (5s) - crits won\'t count');
      }
    }
  }
  
  stats.beeCriticalChance = beeBonus.criticalChance + royalGuardBonus;
  stats.beeCriticalPower = beeBonus.criticalPower;
  stats.beeInstantConversion = beeBonus.instantConversion;
  stats.beeHoneyBonus = beeBonus.honeyBonus;
  stats.beeCapacityBonus = beeBonus.capacityBonus;
  stats.superCriticalChance += (beeBonus.superCriticalChance || 0); // Suma al valor reseteado (3%)
  
  // IMPORTANTE: Resetear multiplicadores a 1.0 antes de recalcular
  // Esto previene que se acumulen infinitamente
  stats.fireMultiplier = 1.0;
  stats.darkFireMultiplier = 1.0;
  stats.gooMultiplier = 1.0;
  stats.bubbleMultiplier = 1.0;
  
  // Apply special multipliers from bees - SUMAMOS los bonos en lugar de multiplicar
  // AsÃ­ x1.5 + x1.2 = x2.7 en lugar de x1.8
  if(beeBonus.fireMultiplier && beeBonus.fireMultiplier !== 1) {
    stats.fireMultiplier += (beeBonus.fireMultiplier - 1);
  }
  if(beeBonus.darkFireMultiplier && beeBonus.darkFireMultiplier !== 1) {
    stats.darkFireMultiplier += (beeBonus.darkFireMultiplier - 1);
  }
  if(beeBonus.gooMultiplier && beeBonus.gooMultiplier !== 1) {
    stats.gooMultiplier += (beeBonus.gooMultiplier - 1);
  }
  if(beeBonus.bubbleMultiplier && beeBonus.bubbleMultiplier !== 1) {
    stats.bubbleMultiplier += (beeBonus.bubbleMultiplier - 1);
  }
  
  // Apply tool and storage multipliers - SUMAMOS en lugar de multiplicar
  if(equippedToolId) {
    const toolBuff = getToolBuffs(equippedToolId);
    if(toolBuff) {
      if(toolBuff.fireMultiplier && toolBuff.fireMultiplier !== 1) {
        stats.fireMultiplier += (toolBuff.fireMultiplier - 1);
      }
      if(toolBuff.darkFireMultiplier && toolBuff.darkFireMultiplier !== 1) {
        stats.darkFireMultiplier += (toolBuff.darkFireMultiplier - 1);
      }
      if(toolBuff.gooMultiplier && toolBuff.gooMultiplier !== 1) {
        stats.gooMultiplier += (toolBuff.gooMultiplier - 1);
      }
      if(toolBuff.bubbleMultiplier && toolBuff.bubbleMultiplier !== 1) {
        stats.bubbleMultiplier += (toolBuff.bubbleMultiplier - 1);
      }
    }
  }
  
  if(equippedStorageId) {
    const storageBuff = getStorageBuffs(equippedStorageId);
    if(storageBuff) {
      if(storageBuff.fireMultiplier && storageBuff.fireMultiplier !== 1) {
        stats.fireMultiplier += (storageBuff.fireMultiplier - 1);
      }
      if(storageBuff.darkFireMultiplier && storageBuff.darkFireMultiplier !== 1) {
        stats.darkFireMultiplier += (storageBuff.darkFireMultiplier - 1);
      }
      if(storageBuff.gooMultiplier && storageBuff.gooMultiplier !== 1) {
        stats.gooMultiplier += (storageBuff.gooMultiplier - 1);
      }
      if(storageBuff.bubbleMultiplier && storageBuff.bubbleMultiplier !== 1) {
        stats.bubbleMultiplier += (storageBuff.bubbleMultiplier - 1);
      }
    }
  }
  
  // Apply Player Rank buffs
  applyPlayerRankBuffs();
  
  // Add system abilities to queue
  const hasGummyBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee3');
  if(hasGummyBee) {
    abilityQueue.addAbility('gummyBeeTick', 'special_bee3', 0);
  }
  
  abilityQueue.addAbility('gooTileSystemTick', 'system', 0); // Always run system
  
  // Process ability queue
  abilityQueue.processNext();
}

function updateSynergies(beeBonus){
  SYNERGIES.forEach(synergy => {
    const hasAllRequired = synergy.requirement.every(req => equippedBees.includes(req));
    if(hasAllRequired) {
      for(const [stat, value] of Object.entries(synergy.bonus)) {
        beeBonus[stat] = (beeBonus[stat] || 0) + value;
      }
    }
  });
}


/**
 * Renderiza partÃ­culas decorativas para efectos de abilities
 * @param {number} tileIndex - Ãndice del tile donde renderizar
 * @param {object} config - ConfiguraciÃ³n: {side, quantity, speed, spread, img, duration, scale}
 */
function spawnParticles(tileIndex, config = {}) {
  if(!config || !config.img) return;
  
  // Valores por defecto
  const {
    side = 'all',
    quantity = 4,
    speed = 100,
    spread = 180,
    img = 'âœ¨',
    duration = 800,
    scale = 0.8,
    loopInterval = 300 // tiempo entre cada generaciÃ³n de partÃ­culas
  } = config;
  
  const GRID_W = 30;
  const row = Math.floor(tileIndex / GRID_W);
  const col = tileIndex % GRID_W;
  
  const tileEl = document.querySelector(`[data-tile="${tileIndex}"]`);
  if(!tileEl) return;
  
  // Determinar posiciones iniciales segÃºn 'side'
  let positions = [];
  if(side === 'all') {
    for(let i = 0; i < quantity; i++) {
      const angle = (i / quantity) * 360;
      positions.push({angle, distance: 5});
    }
  } else if(side === 'top') {
    for(let i = 0; i < quantity; i++) {
      const angle = ((i / quantity) * spread) - spread/2;
      positions.push({angle: angle - 90, distance: 3});
    }
  } else if(side === 'bottom') {
    for(let i = 0; i < quantity; i++) {
      const angle = ((i / quantity) * spread) - spread/2;
      positions.push({angle: angle + 90, distance: 3});
    }
  } else if(side === 'left') {
    for(let i = 0; i < quantity; i++) {
      const angle = ((i / quantity) * spread) - spread/2;
      positions.push({angle: angle + 180, distance: 3});
    }
  } else if(side === 'right') {
    for(let i = 0; i < quantity; i++) {
      const angle = ((i / quantity) * spread) - spread/2;
      positions.push({angle, distance: 3});
    }
  } else if(side === 'corners') {
    const corners = [45, 135, 225, 315];
    for(let i = 0; i < quantity; i++) {
      positions.push({angle: corners[i % 4], distance: 5});
    }
  }
  
  // FunciÃ³n para crear una ronda de partÃ­culas
  function spawnOneRound() {
    // Verificar si la tile todavÃ­a tiene el efecto
    if(!currentField || !fieldData[currentField]) return false;
    
    const rect = tileEl.getBoundingClientRect();
    const startX = rect.left + rect.width / 2;
    const startY = rect.top + rect.height / 2;
    
    // Crear partÃ­culas
    positions.forEach((pos, idx) => {
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.className = 'particle-effect';
        particle.textContent = img;
        particle.style.cssText = `
          position: fixed;
          left: ${startX}px;
          top: ${startY}px;
          font-size: ${16 * scale}px;
          pointer-events: none;
          z-index: 999;
          animation: particle-drift 0.${duration}s ease-out forwards;
          --drift-x: ${Math.cos(pos.angle * Math.PI / 180) * speed}px;
          --drift-y: ${Math.sin(pos.angle * Math.PI / 180) * speed}px;
          opacity: 1;
        `;
        document.body.appendChild(particle);
        
        setTimeout(() => particle.remove(), duration + 50);
      }, idx * 30);
    });
    
    return true; // Round completed successfully
  }
  
  // Generar la primera ronda inmediatamente
  spawnOneRound();
  
  // Iniciar bucle para generar partÃ­culas continuamente
  if(activeParticleLoops[tileIndex]) {
    clearInterval(activeParticleLoops[tileIndex].intervalId);
  }
  
  const intervalId = setInterval(() => {
    if(!spawnOneRound()) {
      // Si la tile ya no tiene efecto, detener el bucle
      clearInterval(intervalId);
      delete activeParticleLoops[tileIndex];
    }
  }, loopInterval);
  
  activeParticleLoops[tileIndex] = {intervalId, config};
}

// FunciÃ³n para detener partÃ­culas de una tile
function stopParticles(tileIndex) {
  if(activeParticleLoops[tileIndex]) {
    clearInterval(activeParticleLoops[tileIndex].intervalId);
    delete activeParticleLoops[tileIndex];
  }
}

function fireBeeTick(){
  if(!equippedBees || !equippedBees.length) return;
  
  const now = Date.now();
  const minInterval = 20000; // 20s
  const maxInterval = 92000; // 1.2min
  
  // Encontrar TODAS las fire bees equipadas (puede haber mÃºltiples)
  const fireBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee6') fireBeeIndices.push(index);
  });
  
  if(fireBeeIndices.length === 0) return;
  
  // Procesar cada fire bee individualmente con su propio temporizador
  fireBeeIndices.forEach(fireBeeIndex => {
    const timer = getBeeInstanceTimer('bee6', fireBeeIndex);
    const randomDelay = minInterval + Math.random() * (maxInterval - minInterval);
    
    // Si es la primera vez o si ya pasÃ³ el delay, ejecutar
    if(timer.lastAbilityTime === 0) {
      timer.lastAbilityScheduledTime = now + randomDelay;
      return;
    }
    
    if(now < timer.lastAbilityScheduledTime) return;
    
    // Actualizar timer para la prÃ³xima ejecuciÃ³n
    timer.lastAbilityTime = now;
    timer.lastAbilityScheduledTime = now + randomDelay;
    registerAbilityExecution('fireBeeAbility');
    
    const GRID_W = 30;
    const GRID_H = 15;
    const totalTiles = GRID_W * GRID_H;
    const tilesToBurn = Math.floor(Math.random() * 5) + 1; // 1-5 casillas
    
  for(let i = 0; i < tilesToBurn; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    if(currentField && fieldData[currentField]){
      const tile = fieldData[currentField][idx];
      if(tile && tile.ty > 0){ // casilla no vacÃ­a
        // Remove any existing buff (only 1 buff per tile)
        delete spicyTilesActive[idx];
        delete gooTiles[idx];
        delete energyTiles[idx];
        
        // Mark tile with fire overlay (10 second duration)
        fireBeeTilesActive[idx] = {
          createdAt: now,
          durationMs: 10000,
          basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
          tileColor: tile.c || ''
        };
        
        // Visual effect: add border and particles
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          // Add fire effect class
          tileEl.classList.add("fire-effect");
          
          // Spawn particles using configurable system
          const bee = BEES.find(b => b.id === 'bee6');
          if(bee && bee.particles) {
            spawnParticles(idx, bee.particles);
          } else {
            // Default fire particles
            spawnParticles(idx, {side:'all', quantity:6, speed:120, spread:180, img:'ðŸ”¥', duration:800, scale:0.8});
          }
        }
      }
    }
  }
  });
}

function bubbleBeeTick(){
  if(!equippedBees) return;
  
  // Find ALL bubble bees equipped
  const bubbleBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee12') bubbleBeeIndices.push(index);
  });
  
  if(bubbleBeeIndices.length === 0) return;
  
  const now = Date.now();
  
  // Process EACH bubble bee with its own timer
  bubbleBeeIndices.forEach(bubbleBeeIndex => {
    const timer = getBeeInstanceTimer('bee12', bubbleBeeIndex);
    
    // Random delay between 30s and 60s for this instance
    const minDelay = 30000, maxDelay = 60000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('bubbleBeeAbility');
      
      const GRID_W = 30;
      const GRID_H = 15;
      const totalTiles = GRID_W * GRID_H;
      const tilesToBubble = Math.floor(Math.random() * 3) + 2; // 2-4 tiles
      
      for(let i = 0; i < tilesToBubble; i++){
        let idx = Math.floor(Math.random() * totalTiles);
        if(currentField && fieldData[currentField]){
          const tile = fieldData[currentField][idx];
          if(tile && tile.ty > 0){ // casilla no vacÃ­a
            // Remove any existing buff (only 1 buff per tile)
            delete fireBeeTilesActive[idx];
            delete spicyTilesActive[idx];
            delete gooTiles[idx];
            delete energyTiles[idx];
            
            // Mark tile with bubble overlay (10 second duration, x2 pollen multiplier)
            bubbleTilesActive[idx] = {
              createdAt: now,
              durationMs: 10000,
              basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
              tileColor: tile.c || ''
            };
            
            // Visual effect: add bubble border and particles
            const gridEl = document.getElementById("grid");
            const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tileEl){
              // Add bubble effect class
              tileEl.classList.add("bubble-effect");
              
              // Spawn particles using configurable system
              spawnParticles(idx, {side:'all', quantity:4, speed:80, spread:180, img:'ðŸ«§', duration:600, scale:0.7, loopInterval:400});
            }
          }
        }
      }
    }
  });
}

function kingCrimsonBeeTick(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee7')) return;
  
  const now = Date.now();
  const minInterval = 40000; // 40s
  const maxInterval = 60000; // 1min
  const randomDelay = minInterval + Math.random() * (maxInterval - minInterval);
  if(now < lastKingCrimsonAbility + randomDelay) return;
  
  lastKingCrimsonAbility = now;
  registerAbilityExecution('kingCrimsonBee');
  
  const GRID_W = 30;
  const GRID_H = 15;
  
  // Seleccionar un tile aleatorio como centro del 3x3
  let centerIdx = Math.floor(Math.random() * (GRID_W * GRID_H));
  let centerRow = Math.floor(centerIdx / GRID_W);
  let centerCol = centerIdx % GRID_W;
  
  // Destruir 3x3 alrededor del centro
  for(let r = centerRow - 1; r <= centerRow + 1; r++){
    for(let c = centerCol - 1; c <= centerCol + 1; c++){
      if(r >= 0 && r < GRID_H && c >= 0 && c < GRID_W){
        const idx = r * GRID_W + c;
        if(currentField && fieldData[currentField]){
          const tile = fieldData[currentField][idx];
          if(tile && tile.ty > 0){
            // Remover otros buffs
            delete fireBeeTilesActive[idx];
            delete spicyTilesActive[idx];
            delete gooTiles[idx];
            delete energyTiles[idx];
            
            // Marcar con crimson effect (30 segundo duration)
            crimsonTilesActive[idx] = {
              createdAt: now,
              durationMs: 30000,
              basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
              tileColor: tile.c || ''
            };
            
            // Visual effect: add crimson effect class
            const gridEl = document.getElementById("grid");
            const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tileEl){
              tileEl.classList.add("crimson-effect");
            }
          }
        }
      }
    }
  }
}

function crimsonGuardSynergyTick(){
  // Check if both Royal Guard and King Crimson are equipped
  const hasRoyalGuard = equippedSpecialBees && equippedSpecialBees.includes('special_bee2');
  const hasKingCrimson = equippedSpecialBees && equippedSpecialBees.includes('special_bee7');
  
  if(!hasRoyalGuard || !hasKingCrimson) return;
  
  const now = Date.now();
  if(now < lastCrimsonGuardSynergy + 60000) return; // Ejecutar cada 1min
  
  lastCrimsonGuardSynergy = now;
  registerAbilityExecution('crimsonGuardSynergy');
  
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Generar 6 tiles aleatorios con efectos (60% fire, 30% dark-fire, 10% crimson)
  const selectedTiles = [];
  for(let i = 0; i < 6; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    while(selectedTiles.includes(idx)){
      idx = Math.floor(Math.random() * totalTiles);
    }
    selectedTiles.push(idx);
  }
  
  selectedTiles.forEach(idx => {
    if(!currentField || !fieldData[currentField]) return;
    const tile = fieldData[currentField][idx];
    if(!tile || !tile.ty) return;
    
    // Remover otros buffs
    delete fireBeeTilesActive[idx];
    delete spicyTilesActive[idx];
    delete gooTiles[idx];
    delete energyTiles[idx];
    delete crimsonTilesActive[idx];
    
    const rand = Math.random() * 100;
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    
    if(rand < 60){
      // 60% Fire
      fireBeeTilesActive[idx] = {
        createdAt: now,
        durationMs: 10000,
        basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
        tileColor: tile.c || ''
      };
      if(tileEl) tileEl.classList.add("fire-effect");
    } else if(rand < 90){
      // 30% Dark Fire
      spicyTilesActive[idx] = {
        createdAt: now,
        durationMs: 20000,
        basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
        tileColor: tile.c || ''
      };
      if(tileEl) tileEl.classList.add("dark-fire-effect");
    } else {
      // 10% Crimson
      crimsonTilesActive[idx] = {
        createdAt: now,
        durationMs: 30000,
        basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
        tileColor: tile.c || ''
      };
      if(tileEl) tileEl.classList.add("crimson-effect");
    }
  });
}

function spicyBeeTick(){
  if(!equippedBees) return;
  
  // Find ALL spicy bees equipped
  const spicyBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee8') spicyBeeIndices.push(index);
  });
  
  if(spicyBeeIndices.length === 0) return;
  
  const now = Date.now();
  
  // Process EACH spicy bee with its own timer
  spicyBeeIndices.forEach(spicyBeeIndex => {
    const timer = getBeeInstanceTimer('bee8', spicyBeeIndex);
    
    // Random delay between 30s and 120s for this instance
    const minDelay = 30000, maxDelay = 120000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('spicyAbility');
      
      const GRID_W = 30;
      const GRID_H = 15;
      const totalTiles = GRID_W * GRID_H;
      
      // Seleccionar 1-5 casillas aleatorias (sin patrÃ³n)
      const tileCount = Math.floor(Math.random() * 5) + 1;
      const burnedTiles = [];
      
      for(let i = 0; i < tileCount; i++){
        let idx = Math.floor(Math.random() * totalTiles);
        if(!burnedTiles.includes(idx)) burnedTiles.push(idx);
      }
      
      // Mark tiles with dark fire overlay (10 second duration, destroyed on click = x7 pollen)
      burnedTiles.forEach(idx => {
        if(!currentField || !fieldData[currentField]) return;
        const tile = fieldData[currentField][idx];
        if(!tile || !tile.ty) return;
        // Remove any existing buff (only 1 buff per tile)
        delete fireBeeTilesActive[idx];
        delete gooTiles[idx];
        delete energyTiles[idx];
        spicyTilesActive[idx] = {
          createdAt: now,
          durationMs: 20000,
          basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
          tileColor: tile.c || ''
        };
        // Visual effect: dark fire border with particles
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.add("dark-fire-effect");
          
          // Spawn particles using configurable system
          spawnParticles(idx, {side:'all', quantity:5, speed:140, spread:200, img:'ðŸ’œ', duration:900, scale:0.7, loopInterval:450});
        }
      });
    }
  });
}

function demonBeeTick(){
  if(!equippedBees) return;
  
  // Find ALL demon bees equipped
  const demonBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee14') demonBeeIndices.push(index);
  });
  
  if(demonBeeIndices.length === 0) return;
  
  const now = Date.now();
  
  // Process EACH demon bee with its own timer
  demonBeeIndices.forEach(demonBeeIndex => {
    const timer = getBeeInstanceTimer('bee14', demonBeeIndex);
    
    // Random delay between 40s and 110s for this instance
    const minDelay = 40000, maxDelay = 110000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('demonBeeAbility');
      
      const GRID_W = 30;
      const GRID_H = 15;
      const totalTiles = GRID_W * GRID_H;
      
      // Seleccionar 1-3 casillas aleatorias
      const tileCount = Math.floor(Math.random() * 3) + 1;
      const burnedTiles = [];
      
      for(let i = 0; i < tileCount; i++){
        let idx = Math.floor(Math.random() * totalTiles);
        if(!burnedTiles.includes(idx)) burnedTiles.push(idx);
      }
      
      // Mark tiles (80% fire, 20% dark fire)
      burnedTiles.forEach(idx => {
        if(!currentField || !fieldData[currentField]) return;
        const tile = fieldData[currentField][idx];
        if(!tile || !tile.ty) return;
        
        const isFireTile = Math.random() * 100 < 80;
        
        if(isFireTile){
          // Fire tile
          fireBeeTilesActive[idx] = {
            createdAt: now,
            durationMs: 10000,
            basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
            tileColor: tile.c || ''
          };

          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            tileEl.classList.add("fire-effect");
          }
        } else {
          // Dark fire tile
          spicyTilesActive[idx] = {
            createdAt: now,
            durationMs: 20000,
            basePollenValue: tile.ty ? Math.floor(Math.random() * (flowerTypes[tile.ty].pollen.max - flowerTypes[tile.ty].pollen.min + 1)) + flowerTypes[tile.ty].pollen.min : 0,
            tileColor: tile.c || ''
          };

          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            tileEl.classList.add("dark-fire-effect");
          }
        }
      });
    }
  });
}

function laserBeeTick(){
  if(!equippedBees || !currentField || !fieldData[currentField]) return;
  
  // Find ALL laser bees equipped
  const laserBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee16') laserBeeIndices.push(index);
  });
  
  if(laserBeeIndices.length === 0) return;
  
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Process EACH laser bee with its own timer
  laserBeeIndices.forEach(laserBeeIndex => {
    const timer = getBeeInstanceTimer('bee16', laserBeeIndex);
    
    // Random delay between 30s and 60s for this instance
    const minDelay = 30000, maxDelay = 60000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('laserBeeAbility');
      
      const GRID_W = 30, GRID_H = 15;
      
      const isVertical = Math.random() < 0.5;
      const lineIdx = isVertical ? Math.floor(Math.random() * GRID_W) : Math.floor(Math.random() * GRID_H);
      const tiles = [];
      
      // Recopilar todas las tiles en la lÃ­nea
      for(let i = 0; i < (isVertical ? GRID_H : GRID_W); i++){
        const idx = isVertical ? (i * GRID_W + lineIdx) : (lineIdx * GRID_W + i);
        if(fieldData[currentField][idx]) tiles.push(idx);
      }
      
      if(tiles.length === 0) { /* no tiles to destroy */ }
      else {
        // Crear lÃ¡ser visual - posicionado directamente sobre la grid
        const laserEl = document.createElement('div');
        laserEl.style.cssText = `position:absolute;pointer-events:none;z-index:100;background:${isVertical ? 'linear-gradient(180deg,rgba(255,0,0,.9),rgba(255,100,0,.9),rgba(255,0,0,.9))' : 'linear-gradient(90deg,rgba(255,0,0,.9),rgba(255,100,0,.9),rgba(255,0,0,.9))'}`;
        laserEl.style.boxShadow = '0 0 20px rgba(255,0,0,0.9), 0 0 10px rgba(255,69,0,0.7)';
        
        // Grid layout: 30 cols x 15 rows, each 24px per cell
        const gridRect = gridEl.getBoundingClientRect();
        const gridStartX = gridRect.left - gridRect.left;
        const gridStartY = gridRect.top - gridRect.top;
        const cellW = 24, cellH = 24;
        const gridPadding = 0;
        
        if(isVertical){
          // Vertical laser at column lineIdx
          const x = gridPadding + lineIdx * cellW + 12; // center of tile
          laserEl.style.left = (x - 2) + 'px'; // -2 for 4px width center
          laserEl.style.top = gridPadding + 'px';
          laserEl.style.width = '4px';
          laserEl.style.height = (GRID_H * cellH - gridPadding) + 'px';
        } else {
          // Horizontal laser at row lineIdx
          const y = gridPadding + lineIdx * cellH + 12; // center of tile
          laserEl.style.left = gridPadding + 'px';
          laserEl.style.top = (y - 2) + 'px'; // -2 for 4px height center
          laserEl.style.width = (GRID_W * cellW - gridPadding) + 'px';
          laserEl.style.height = '4px';
        }
        
        gridEl.appendChild(laserEl);
        
        // Procesar destrucciÃ³n despuÃ©s de 600ms
        setTimeout(() => {
          tiles.forEach(idx => {
            const tile = fieldData[currentField][idx];
            if(!tile) return;
            
            let gain = 0;
            if(tile.ty > 0){
              const range = flowerTypes[tile.ty].pollen;
              gain = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
              gain *= 2; // x2 base laser
              
              // CrÃ­ticos
              const totalCrit = stats.criticalChance + stats.beeCriticalChance;
              let isCrit = Math.random() * 100 < totalCrit;
              let isSuperCrit = false;
              if(isCrit && Math.random() * 100 < stats.superCriticalChance){
                isSuperCrit = true;
                isCrit = false;
              }
              const critMult = isSuperCrit ? 10 : (isCrit ? stats.criticalPower + stats.beeCriticalPower : 1);
              gain *= critMult;
              
              // Goo
              if(gooTiles[idx]){ gain *= 3.75; delete gooTiles[idx]; }
              
              // Color bonuses
              if(tile.c === 'red'){ gain *= redPollenMultiplier * 2; stats.redTotal += gain; }
              else if(tile.c === 'blue'){ gain *= bluePollenMultiplier; stats.blueTotal += gain; }
              else if(tile.c === 'white'){ gain *= whitePollenMultiplier; stats.whiteTotal += gain; }
              else if(tile.c === 'yellow'){ gain *= yellowPollenMultiplier; stats.yellowTotal = (stats.yellowTotal||0) + gain; }
              else if(tile.c === 'purple'){ gain *= purplePollenMultiplier; stats.purpleTotal = (stats.purpleTotal||0) + gain; }
              
              const capacity = calculateCapacity();
              const add = Math.min(capacity - stats.pollen, gain);
              stats.pollen += add;
              stats.honey += add;
              stats.totalHoney += add;
              pollenThisSec += add;
              
              // Float number
              const tEl = gridEl.querySelector(`[data-idx="${idx}"]`);
              if(tEl){
                const r = tEl.getBoundingClientRect();
                floating(r.left + r.width/2, r.top, add, isCrit, false, false, true, false, isSuperCrit);
              }
            }
            
            // Destruir visualmente
            const tEl = gridEl.querySelector(`[data-idx="${idx}"]`);
            if(tEl){ tEl.style.opacity = '0'; }
            
            fieldData[currentField][idx] = {c:'',ty:0,transparent:true};
            energyTiles[idx] = {createdAt: now, fieldKey: currentField, durationMs: 20000};
            
            // Regenerar en 20s
            setTimeout(() => {
              if(fieldData[currentField] && fieldData[currentField][idx]){
                delete energyTiles[idx];
                fieldData[currentField][idx] = createTile(currentField);
                const t = gridEl.querySelector(`[data-idx="${idx}"]`);
                if(t) renderTile(t, fieldData[currentField][idx]);
                saveGame();
              }
            }, 20000);
          });
          
          // Fade out laser
          laserEl.style.opacity = '0';
          setTimeout(() => laserEl.remove(), 300);
        }, 600);
      }
    }
  });
}

function teslaBeeAbility(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee4')) return;
  if(!currentField || !fieldData[currentField]) return;
  
  const now = Date.now();
  const minInterval = 30000; // 30 seconds
  const maxInterval = 120000; // 2 minutes
  const randomDelay = minInterval + Math.random() * (maxInterval - minInterval);
  
  if(now < lastTeslaBeeAbility + randomDelay) return;
  
  lastTeslaBeeAbility = now;
  registerAbilityExecution('teslaBeeAbility');
  
  const GRID_W = 30;
  const GRID_H = 15;
  const tileSize = 24;
  const gap = 0;
  const cellSize = tileSize + gap;
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Generate 5 lasers
  for(let laserIdx = 0; laserIdx < 5; laserIdx++){
    // Random direction
    const isVertical = Math.random() < 0.5;
    let laserTiles = [];
    let lineIdx;
    
    if(isVertical){
      // Vertical laser: columna aleatoria
      lineIdx = Math.floor(Math.random() * GRID_W);
      for(let y = 0; y < GRID_H; y++){
        const idx = y * GRID_W + lineIdx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx});
        }
      }
    } else {
      // Horizontal laser: fila aleatoria
      lineIdx = Math.floor(Math.random() * GRID_H);
      for(let x = 0; x < GRID_W; x++){
        const idx = lineIdx * GRID_W + x;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          laserTiles.push({idx: idx});
        }
      }
    }
    
    // Create visual laser (blue/purple)
    const laserId = 'tesla_laser_' + Math.random();
    const laserEl = document.createElement('div');
    laserEl.id = laserId;
    laserEl.style.position = 'absolute';
    laserEl.style.pointerEvents = 'none';
    laserEl.style.zIndex = '100';
    
    const gridPadding = 0;
    const startPos = gridPadding;
    
    if(isVertical){
      laserEl.style.left = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.top = startPos + 'px';
      laserEl.style.width = '4px';
      laserEl.style.height = (GRID_H * cellSize) + 'px';
      laserEl.style.background = 'linear-gradient(180deg, rgba(65,105,225,0.9), rgba(75,0,130,0.9), rgba(65,105,225,0.9))';
    } else {
      laserEl.style.left = startPos + 'px';
      laserEl.style.top = (lineIdx * cellSize + gridPadding + tileSize/2 - 2) + 'px';
      laserEl.style.width = (GRID_W * cellSize) + 'px';
      laserEl.style.height = '4px';
      laserEl.style.background = 'linear-gradient(90deg, rgba(65,105,225,0.9), rgba(75,0,130,0.9), rgba(65,105,225,0.9))';
    }
    
    laserEl.style.boxShadow = '0 0 20px rgba(65,105,225,0.9), 0 0 10px rgba(75,0,130,0.6)';
    laserEl.style.borderRadius = '0px';
    laserEl.style.animation = 'pulse 0.5s ease-in-out infinite';
    gridEl.appendChild(laserEl);
    
    // Destroy tiles after 0.5s
    setTimeout(() => {
      laserTiles.forEach(tileInfo => {
        const idx = tileInfo.idx;
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0){
          // Remove any existing buff on this tile
          delete fireBeeTilesActive[idx];
          delete spicyTilesActive[idx];
          delete gooTiles[idx];
          
          // Calculate pollen
          const pollenRange = flowerTypes[tile.ty].pollen;
          const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          
          // Check for crits
          const totalCritChance = stats.criticalChance + stats.beeCriticalChance;
          let isCritical = Math.random() * 100 < totalCritChance;
          let isSuperCritical = false;
          if(isCritical && Math.random() * 100 < stats.superCriticalChance){
            isSuperCritical = true;
            isCritical = false;
          }
          
          const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
          const critMultiplier = isSuperCritical ? 10 : (isCritical ? totalCritPower : 1);
          const finalPollenValue = pollenValue * critMultiplier;
          let gain = finalPollenValue * 2; // x2 from tesla/laser
          
          // Apply color multipliers
          if(tile.c === 'red'){
            gain *= redPollenMultiplier;
            stats.redTotal += gain;
          } else if(tile.c === 'blue'){
            gain *= bluePollenMultiplier * 5; // x5 blue pollen for energy buff
            stats.blueTotal += gain;
          } else if(tile.c === 'white'){
            gain *= whitePollenMultiplier;
            stats.whiteTotal += gain;
          } else if(tile.c === 'yellow'){
            gain *= yellowPollenMultiplier;
            stats.yellowTotal = (stats.yellowTotal || 0) + gain;
          } else if(tile.c === 'purple'){
            gain *= purplePollenMultiplier;
            stats.purpleTotal = (stats.purpleTotal || 0) + gain;
          }
          
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          // 100% instant conversion from energy buff
          const honeyAmount = gain * 0.5;
          stats.honey += honeyAmount;
          stats.totalHoney += honeyAmount;
          
          // Show floating number
          const gridEl = document.getElementById("grid");
          const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(tileEl){
            const r = tileEl.getBoundingClientRect();
            floating(r.left + r.width / 2, r.top, gain, isCritical, false, true, false, false, isSuperCritical);
            tileEl.style.transition = "opacity 0.3s ease-out";
            tileEl.style.opacity = "0";
          }
          
          // Apply energy buff to this tile AFTER destroying it
          energyTiles[idx] = {createdAt: Date.now(), fieldKey: currentField};
          
          // Reset tile to empty
          fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
          
          // Apply regeneration timer using tileRegenerationRange
          const capturedIdx = idx;
          const capturedFieldKey = currentField;
          const regenerationTime = tileRegenerationRange.min + Math.random() * (tileRegenerationRange.max - tileRegenerationRange.min);
          const regenerationTimer = setTimeout(() => {
            if(fieldData[capturedFieldKey] && fieldData[capturedFieldKey][capturedIdx]){
              fieldData[capturedFieldKey][capturedIdx] = createTile(capturedFieldKey);
              if(currentField === capturedFieldKey){
                const gridEl = document.getElementById("grid");
                const tileEl = gridEl.querySelector(`[data-idx="${capturedIdx}"]`);
                if(tileEl){
                  renderTile(tileEl, fieldData[capturedFieldKey][capturedIdx]);
                  
                  // Aplica el efecto visual de energy si la tile tiene energy
                  if(energyTiles[capturedIdx]){
                    tileEl.classList.add("energy-effect");
                  }

                  // Fade in animation
                  tileEl.style.transition = "opacity 0.8s ease-in";
                  tileEl.style.opacity = "0";
                  void tileEl.offsetWidth;
                  tileEl.style.opacity = "1";
                }
              }
              saveGame();
            }
          }, regenerationTime);
        }
      });
      
      // Remove laser visual
      laserEl.style.transition = 'all 0.4s ease-out';
      laserEl.style.opacity = '0';
      setTimeout(() => {
        laserEl.remove();
      }, 400);
    }, 500);
  }
}

function ticketBeeAbility(){
  if(!equippedBees || !equippedBees.includes('bee18')) return;
  
  const now = Date.now();
  const abilityInterval = 60000; // 1 minute
  
  if(now - ticketBeeAbilityTime < abilityInterval) return;
  
  ticketBeeAbilityTime = now;
  
  // 5% chance to get +1 ticket
  if(Math.random() < 0.05){
    tickets += 1;
    showFloatingText(window.innerWidth / 2, 100, 'ðŸŽ« +1 Ticket', '#9370DB');
  }
}

function goldenBeeAbility(){
  if(!equippedBees || !equippedBees.includes('bee19')) return;
  
  const now = Date.now();
  const abilityInterval = 60000; // 1 minute
  
  if(now - goldenBeeAbilityTime < abilityInterval) return;
  
  goldenBeeAbilityTime = now;
  
  // 20% chance to get +2 tickets
  if(Math.random() < 0.20){
    tickets += 2;
    showFloatingText(window.innerWidth / 2, 100, 'ðŸŽ« +2 Tickets', '#FFD700');
  }
}

function thunderBeeTick(){
  if(!equippedBees) return;
  
  // Find ALL thunder bees equipped
  const thunderBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee17') thunderBeeIndices.push(index);
  });
  
  if(thunderBeeIndices.length === 0) return;
  if(!currentField || !fieldData[currentField]) return;
  
  const now = Date.now();
  
  // Process EACH thunder bee with its own timer
  thunderBeeIndices.forEach(thunderBeeIndex => {
    const timer = getBeeInstanceTimer('bee17', thunderBeeIndex);
    
    // Random delay between 20s and 72s for this instance
    const minDelay = 20000, maxDelay = 72000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('thunderBeeAbility');
      
      // Generate 1-5 energy tiles randomly
      const GRID_W = 30;
      const GRID_H = 15;
      const totalTiles = GRID_W * GRID_H;
      const tileCount = Math.floor(Math.random() * 5) + 1; // 1-5 tiles
      
      const selectedTiles = [];
      for(let i = 0; i < tileCount; i++){
        let idx = Math.floor(Math.random() * totalTiles);
        if(!selectedTiles.includes(idx) && fieldData[currentField][idx] && fieldData[currentField][idx].ty > 0){
          selectedTiles.push(idx);
        }
      }
      
      selectedTiles.forEach(randomIdx => {
        // Remove any existing buff
        delete fireBeeTilesActive[randomIdx];
        delete spicyTilesActive[randomIdx];
        delete gooTiles[randomIdx];
        
        // Apply energy buff with duration
        energyTiles[randomIdx] = {createdAt: Date.now(), fieldKey: currentField, durationMs: 20000};
        
        // Visual update
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${randomIdx}"]`);
        if(tileEl){
          tileEl.classList.add("energy-effect");
          // Spawn particles using configurable system
          spawnParticles(randomIdx, {side:'all', quantity:8, speed:180, spread:360, img:'âš¡', duration:700, scale:0.8, loopInterval:500});
        }
        
        console.log('âš¡ Thunder Bee created energy tile at index', randomIdx);
      });
    }
  });
}

function updateEnergyTiles(){
  // Remove expired energy buffs (after 20 seconds)
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  // Limpiar visualmente todas las tiles que ya no tengan energy
  if(gridEl) {
    for(let i=0; i<450; i++) {
      if(!energyTiles[i]) {
        const tileEl = gridEl.querySelector(`[data-idx="${i}"]`);
        if(tileEl) {
          tileEl.classList.remove("energy-effect");
        }
      }
    }
  }
  Object.keys(energyTiles).forEach(idxStr => {
    const idx = parseInt(idxStr);
    if(now - energyTiles[idx].createdAt > 20000){
      if(gridEl){
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("energy-effect");
        }
      }
      stopParticles(idx); // Stop particle loop when effect expires
      delete energyTiles[idx];
    }
  });
}

// Update Fire Bee tiles - expire after 10 seconds
function updateFireBeeTiles(){
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  Object.keys(fireBeeTilesActive).forEach(idxStr => {
    const idx = parseInt(idxStr);
    const tile = fireBeeTilesActive[idx];
    if(!tile) return;
    
    if(now - tile.createdAt > tile.durationMs){
      if(gridEl){
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("fire-effect");
        }
      }
      stopParticles(idx); // Stop particle loop when effect expires
      delete fireBeeTilesActive[idx];
    }
  });
}

// Update Spicy Bee tiles - expire after 20 seconds
function updateSpicyBeeTiles(){
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  Object.keys(spicyTilesActive).forEach(idxStr => {
    const idx = parseInt(idxStr);
    const tile = spicyTilesActive[idx];
    if(!tile) return;
    
    if(now - tile.createdAt > tile.durationMs){
      if(gridEl){
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("dark-fire-effect");
        }
      }
      stopParticles(idx); // Stop particle loop when effect expires
      delete spicyTilesActive[idx];
    }
  });
}

// Update Bubble Bee tiles - expire after 10 seconds
function updateBubbleBeeTiles(){
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  
  Object.keys(bubbleTilesActive).forEach(idxStr => {
    const idx = parseInt(idxStr);
    const tile = bubbleTilesActive[idx];
    if(!tile) return;
    
    if(now - tile.createdAt > tile.durationMs){
      if(gridEl){
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("bubble-effect");
        }
      }
      stopParticles(idx); // Stop particle loop when effect expires
      delete bubbleTilesActive[idx];
    }
  });
}


function updateGooColors(){
  // Actualizar color del Goo en tiempo real con animaciÃ³n fluida
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  Object.keys(gooTiles).forEach(idxStr => {
    const idx = parseInt(idxStr);
    if(!gooTiles[idx]) return;
    
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if(!tileEl) return;
    
    // InterpolaciÃ³n suave entre colores
    const cycleProgress = (gooColorCycle % (gooColorList.length * 100)) / (gooColorList.length * 100);
    const colorSegments = gooColorList.length;
    const currentSegment = Math.floor(cycleProgress * colorSegments);
    const nextSegment = (currentSegment + 1) % colorSegments;
    const segmentProgress = (cycleProgress * colorSegments) % 1;
    
    const color1 = gooColorList[currentSegment];
    const color2 = gooColorList[nextSegment];
    const blendedColor = blendColors(color1, color2, segmentProgress);
    
    gooTiles[idx].gooColor = blendedColor;
    tileEl.style.filter = `drop-shadow(0 0 12px ${blendedColor})`;
  });
}

function blendColors(color1, color2, progress) {
  // Convertir colores hex a RGB
  const hex2rgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
  };
  
  const rgb2hex = (r, g, b) => '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');
  
  const [r1, g1, b1] = hex2rgb(color1);
  const [r2, g2, b2] = hex2rgb(color2);
  
  const r = r1 + (r2 - r1) * progress;
  const g = g1 + (g2 - g1) * progress;
  const b = b1 + (b2 - b1) * progress;
  
  return rgb2hex(r, g, b);
}

function startGummyBeeSystem(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee3')) return;
  
  // Initialize timing on first call
  if(lastGooGeneration === 0){
    lastGooGeneration = Date.now();
  }
}

function gummyBeeTick(){
  if(!equippedSpecialBees || !equippedSpecialBees.includes('special_bee3')) return;
  if(!currentField) return;
  
  const now = Date.now();
  const nextSpawn = lastGooGeneration + Math.random() * 20000 + 20000; // 20s - 40s minimum
  if(now < nextSpawn) return;
  
  lastGooGeneration = now;
  registerAbilityExecution('gooAbility');
  
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const gooCount = Math.floor(Math.random() * 5) + 1; // 1-5 goos por ciclo
  
  for(let i = 0; i < gooCount; i++){
    let idx = Math.floor(Math.random() * totalTiles);
    // No generar Goo si ya hay en esta casilla
    if(gooTiles[idx]) continue;
    
    // Remove any existing buff (only 1 buff per tile)
    delete fireBeeTilesActive[idx];
    delete spicyTilesActive[idx];
    delete energyTiles[idx];
    
    const color = gooColorList[Math.floor(Math.random() * gooColorList.length)];
    gooTiles[idx] = {gooColor: color, createdAt: Date.now(), active: true, fieldKey: currentField};
    
    // Visual indicator with gradient border using all goo colors
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
    if(tileEl){
      tileEl.classList.add("goo-effect");
    }
    
    // Desaparecer despuÃ©s de 15-30s
    const duration = Math.random() * 15000 + 15000; // 15-30s
    setTimeout(()=>{
      if(gooTiles[idx]){
        const gridEl = document.getElementById("grid");
        const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tileEl){
          tileEl.classList.remove("goo-effect");
        }
        delete gooTiles[idx];
      }
    }, duration);
  }
}

// Tile Upgrade System - Goo Tile Generation
function gooTileSystemTick(){
  if(maxGooTiles <= 0) return;
  if(!currentField) return;
  
  const now = Date.now();
  const minInterval = 30000; // 30 seconds
  const maxInterval = 60000; // 1 minute
  const nextSpawn = lastGooTileGeneration + minInterval + Math.random() * (maxInterval - minInterval);
  if(now < nextSpawn) return;
  
  lastGooTileGeneration = now;
  
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Limit the number of active goo tiles from upgrade
  if(activeGooTileIndices.length >= maxGooTiles) return;
  
  // Generate 1 goo tile
  let idx;
  let attempts = 0;
  do {
    idx = Math.floor(Math.random() * totalTiles);
    attempts++;
  } while((gooTiles[idx] || fireBeeTilesActive[idx] || spicyTilesActive[idx] || activeGooTileIndices.includes(idx)) && attempts < 10);
  
  if(attempts >= 10) return; // Couldn't find a valid tile
  
  // Add to our tracking
  activeGooTileIndices.push(idx);
  
  // Remove any existing buff (only 1 buff per tile)
  delete fireBeeTilesActive[idx];
  delete spicyTilesActive[idx];
  delete energyTiles[idx];
  
  const color = gooColorList[Math.floor(Math.random() * gooColorList.length)];
  gooTiles[idx] = {gooColor: color, createdAt: Date.now(), active: true, fieldKey: currentField};
  
  // Visual indicator
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
  if(tileEl){
    tileEl.classList.add("goo-effect");
  }
  
  // Desaparecer despuÃ©s de 20s
  const duration = 20000; // 20 seconds
  setTimeout(()=>{
    if(gooTiles[idx]){
      const gridEl = document.getElementById("grid");
      const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tileEl){
        tileEl.classList.remove("goo-effect");
      }
      delete gooTiles[idx];
    }
    // Remove from tracking
    const index = activeGooTileIndices.indexOf(idx);
    if(index > -1){
      activeGooTileIndices.splice(index, 1);
    }
  }, duration);
}

function stopSpecialBeeAbilities(){
  // Parar Fire Bee
  lastFireBeeAbility = 0;
  fireBeeTilesActive = {};
  
  // Parar Spicy Bee
  lastSpicyAbility = 0;
  spicyTilesActive = {};
  
  // Parar Bubble Bee
  lastBubbleBeeAbility = 0;
  bubbleTilesActive = {};
  
  // Parar Gummy Bee
  gooTiles = {};
  lastGooGeneration = 0;
  gooDestroyedCount = 0;
  
  // Parar Goo Tile System (upgrade)
  lastGooTileGeneration = 0;
  activeGooTileIndices = [];
  
  // Parar Demon Bee
  lastDemonAbility = 0;
  demonTilesActive = {};
  
  // Parar Laser Bee
  lastLaserAbility = 0;
  activeLaserLines = {};
  const gridEl = document.getElementById("grid");
  if(gridEl){
    Object.keys(activeLaserLines).forEach(laserId => {
      const laserEl = gridEl.querySelector('#' + laserId);
      if(laserEl) laserEl.remove();
    });
  }
}

/* ================= LION BEE ABILITY ================= */
function lionBeeAbility(){
  const now = Date.now();
  const cooldown = 30000; // 30 seconds between activations
  
  if(now - lastLionAbility < cooldown) return;
  
  const lionBeeCount = (equippedBees || []).filter(id => id === 'bee20').length;
  if(lionBeeCount === 0) return;
  
  lastLionAbility = now;
  
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Destroy 3 random tiles
  for(let i = 0; i < 3; i++){
    const randomIdx = Math.floor(Math.random() * totalTiles);
    const tile = fieldData[currentField]?.[randomIdx];
    
    if(!tile || tile.ty === 0) continue; // Skip empty tiles
    
    // Get tile element
    const gridEl = document.getElementById("grid");
    const tileEl = gridEl?.querySelector(`[data-idx="${randomIdx}"]`);
    if(!tileEl) continue;
    
    // Get pollen value
    const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
    let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
    pollenValue *= 2; // +100% pollen bonus
    
    // Guaranteed critical
    let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
    
    // Add to stats
    stats.pollen += gain;
    stats.totalHoney = (stats.totalHoney || 0) + 0;
    pollenThisSec += gain;
    
    const r = tileEl.getBoundingClientRect();
    floating(r.left + r.width / 2, r.top, gain, true, false); // true = guaranteed crit
    
    // Destroy tile
    fieldData[currentField][randomIdx] = {c: "", ty: 0, transparent: true};
    renderTile(tileEl, fieldData[currentField][randomIdx]);
    tileEl.style.transition = "opacity 0.3s";
    tileEl.style.opacity = "0";
    
    // Regenerate
    setTimeout(() => {
      fieldData[currentField][randomIdx] = createTile(currentField);
      renderTile(tileEl, fieldData[currentField][randomIdx]);
      tileEl.style.opacity = "1";
    }, 1500);
  }
}

/* ================= PHOTON BEE ABILITY ================= */
function photonBeeAbility(){
  const now = Date.now();
  const minCooldown = 60000; // 1 minute
  const maxCooldown = 120000; // 2 minutes
  const cooldown = minCooldown + Math.random() * (maxCooldown - minCooldown);
  
  if(now - lastPhotonAbility < cooldown) return;
  
  const hasPhotonBee = equippedSpecialBees && equippedSpecialBees.includes('special_bee5');
  if(!hasPhotonBee) return;
  
  lastPhotonAbility = now;
  registerAbilityExecution('photonAbility');
  
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  const gridEl = document.getElementById("grid");
  
  // Mark 20 random tiles for destruction with golden laser effect
  const tilesToDestroy = [];
  const selectedIndices = new Set();
  
  while(tilesToDestroy.length < 20){
    const idx = Math.floor(Math.random() * totalTiles);
    if(!selectedIndices.has(idx)){
      selectedIndices.add(idx);
      const tile = fieldData[currentField]?.[idx];
      if(tile && tile.ty > 0){
        tilesToDestroy.push(idx);
      }
    }
  }
  
  // Add visual effects to tiles
  tilesToDestroy.forEach(idx => {
    const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
    if(tileEl){
      tileEl.classList.add("photon-marked");
      tileEl.style.borderRadius = "0px";
      tileEl.style.border = "3px solid #FFD700";
      tileEl.style.boxShadow = "0 0 12px #FFD700, inset 0 0 8px #FFD700";
      tileEl.style.animation = "photonGlow 0.6s ease-in-out infinite";
    }
    
    // Create laser beam effect
    const laser = document.createElement('div');
    laser.style.position = 'fixed';
    const rect = tileEl.getBoundingClientRect();
    laser.style.left = rect.left + 'px';
    laser.style.top = (rect.top - 80) + 'px';
    laser.style.width = rect.width + 'px';
    laser.style.height = '100px';
    laser.style.background = 'linear-gradient(180deg, rgba(255,215,0,0.8), rgba(255,215,0,0))';
    laser.style.pointerEvents = 'none';
    laser.style.zIndex = '9998';
    laser.style.opacity = '0';
    laser.style.transition = 'opacity 0.3s';
    laser.style.boxShadow = '0 0 20px #FFD700';
    laser.id = 'photon-laser-' + idx;
    document.body.appendChild(laser);
    
    // Fade in laser
    setTimeout(() => {
      laser.style.opacity = '0.7';
    }, 50);
  });
  
  // Destroy tiles with random delays between 0.5s-1s
  tilesToDestroy.forEach((idx) => {
    const delay = 500 + Math.random() * 500;
    setTimeout(() => {
      const tile = fieldData[currentField]?.[idx];
      if(!tile) return;
      
      const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
      if(!tileEl) return;
      
      // Get pollen value
      const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
      let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
      
      // x3 pollen, x5 for yellow
      let multiplier = 3;
      if(tile.c === 'yellow') multiplier = 5;
      pollenValue *= multiplier;
      
      let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
      
      // Respetar capacidad del jugador
      const currentCapacity = calculateCapacity();
      const added = Math.min(currentCapacity - stats.pollen, gain);
      stats.pollen += added;
      pollenThisSec += added;
      
      // 100% instant conversion for Photon Bee
      const honeyAmount = added * 0.5;
      stats.honey += honeyAmount;
      stats.totalHoney += honeyAmount;
      
      const r = tileEl.getBoundingClientRect();
      floating(r.left + r.width / 2, r.top, added, false, false, false, false, true); // isPhoton = true
      
      // Remove laser
      const laser = document.getElementById('photon-laser-' + idx);
      if(laser){
        laser.style.opacity = '0';
        setTimeout(() => laser.remove(), 300);
      }
      
      // Remove visual effects and mark as destroyed
      tileEl.style.animation = 'none';
      tileEl.style.boxShadow = 'none';
      tileEl.style.border = 'none';
      tileEl.classList.remove("photon-marked");
      tileEl.style.transition = "opacity 0.2s";
      tileEl.style.opacity = "0";
      
      // Destroy tile
      fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
      renderTile(tileEl, fieldData[currentField][idx]);
      
      // Regenerate
      setTimeout(() => {
        fieldData[currentField][idx] = createTile(currentField);
        renderTile(tileEl, fieldData[currentField][idx]);
        tileEl.style.opacity = "1";
      }, 1000);
    }, delay);
  });
}

function digitalBeeAbility(){
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  const GRID_W = 30;
  const GRID_H = 15;
  const totalTiles = GRID_W * GRID_H;
  
  // Check for random effects every 30s
  const randomEffectCooldown = 30000;
  if(now - lastDigitalRandomEffect >= randomEffectCooldown){
    lastDigitalRandomEffect = now;
    registerAbilityExecution('digitalRandomEffect');
    
    // Generate random effect on 5 tiles
    const effectTypes = ['fire', 'darkfire', 'energy', 'goo'];
    const selectedEffect = effectTypes[Math.floor(Math.random() * effectTypes.length)];
    
    const selectedIndices = new Set();
    while(selectedIndices.size < 5){
      const idx = Math.floor(Math.random() * totalTiles);
      const tile = fieldData[currentField]?.[idx];
      if(!selectedIndices.has(idx) && tile && tile.ty > 0){
        selectedIndices.add(idx);
        
        // Apply the selected effect
        switch(selectedEffect){
          case 'fire':
            fireBeeTilesActive[idx] = { createdAt: Date.now(), durationMs: 10000, basePollenValue: 10, tileColor: 'red' };
            break;
          case 'darkfire':
            spicyTilesActive[idx] = { createdAt: Date.now(), durationMs: 10000 };
            break;
          case 'energy':
            energyTiles[idx] = { createdAt: Date.now(), fieldKey: currentField };
            // Clean up energy tile after 10s
            setTimeout(() => {
              delete energyTiles[idx];
            }, 10000);
            break;
          case 'goo':
            gooTiles[idx] = { gooColor: gooColorList[Math.floor(Math.random() * gooColorList.length)], createdAt: Date.now(), active: true };
            // Clean up goo tile after 15s
            setTimeout(() => {
              delete gooTiles[idx];
            }, 15000);
            break;
        }
      }
    }
  }
  
  // Check for glitch effect every 60-120s
  const glitchMinCooldown = 60000;
  const glitchMaxCooldown = 120000;
  const glitchCooldown = glitchMinCooldown + Math.random() * (glitchMaxCooldown - glitchMinCooldown);
  
  if(now - lastDigitalGlitch >= glitchCooldown){
    lastDigitalGlitch = now;
    registerAbilityExecution('digitalGlitch');
    
    // Apply glitch to 2-4 random tiles
    const glitchCount = 2 + Math.floor(Math.random() * 3);
    const selectedIndices = new Set();
    
    while(selectedIndices.size < glitchCount){
      const idx = Math.floor(Math.random() * totalTiles);
      const tile = fieldData[currentField]?.[idx];
      if(!selectedIndices.has(idx) && tile && tile.ty > 0){
        selectedIndices.add(idx);
        
        // Apply glitch effect
        glitchedTiles[idx] = { createdAt: now, durationMs: 5000 };
        const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
        
        if(tileEl){
          // Create gradient border animation
          const glitchStyles = `
            <style id="glitch-style-${idx}">
              @keyframes glitchBorder-${idx} {
                0% { border-color: #FF0000; box-shadow: 0 0 15px #FF0000; }
                33% { border-color: #00FF00; box-shadow: 0 0 15px #00FF00; }
                66% { border-color: #000000; box-shadow: 0 0 15px #000000; }
                100% { border-color: #FF0000; box-shadow: 0 0 15px #FF0000; }
              }
            </style>
          `;
          if(!document.getElementById(`glitch-style-${idx}`)){
            document.body.insertAdjacentHTML('beforeend', glitchStyles);
          }
          
          tileEl.style.borderWidth = '3px';
          tileEl.style.animation = `glitchBorder-${idx} 0.4s linear infinite`;
          tileEl.classList.add('glitch-tile');
          
          // Create floating squares
          for(let i = 0; i < 8; i++){
            const square = document.createElement('div');
            square.style.position = 'fixed';
            const rect = tileEl.getBoundingClientRect();
            square.style.left = (rect.left + Math.random() * rect.width) + 'px';
            square.style.top = (rect.top - 30 - Math.random() * 30) + 'px';
            square.style.width = '8px';
            square.style.height = '8px';
            const colors = ['#FF0000', '#00FF00', '#000000'];
            square.style.background = colors[Math.floor(Math.random() * colors.length)];
            square.style.pointerEvents = 'none';
            square.style.zIndex = '9999';
            square.style.boxShadow = `0 0 8px ${square.style.background}`;
            square.style.animation = 'float 0.3s ease-out forwards';
            document.body.appendChild(square);
            
            setTimeout(() => square.remove(), 200);
          }
        }
        
        // Destroy the tile after 5 seconds and award pollen
        setTimeout(() => {
          const tile = fieldData[currentField]?.[idx];
          if(!tile) return;
          
          const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
          if(!tileEl) return;
          
          // Get pollen value with +3000% multiplier
          const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
          let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          pollenValue *= 30; // +3000% = x30
          
          let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
          
          // Respetar capacidad
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          const r = tileEl.getBoundingClientRect();
          floating(r.left + r.width / 2, r.top, added, false, false, false, false, true); // Amarillo neon glow
          
          // Destroy tile
          fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
          renderTile(tileEl, fieldData[currentField][idx]);
          tileEl.style.animation = 'none';
          tileEl.style.boxShadow = 'none';
          tileEl.style.borderWidth = '1px';
          tileEl.classList.remove("glitch-tile");
          const glitchStyle = document.getElementById(`glitch-style-${idx}`);
          if(glitchStyle) glitchStyle.remove();
          tileEl.style.transition = "opacity 0.2s";
          tileEl.style.opacity = "0";
          
          // Regenerate
          setTimeout(() => {
            fieldData[currentField][idx] = createTile(currentField);
            renderTile(tileEl, fieldData[currentField][idx]);
            tileEl.style.opacity = "1";
          }, 1000);
          
          delete glitchedTiles[idx];
        }, 5000);
      }
    }
  }
}

function moonBeeAbility(){
  const now = Date.now();
  if(now - lastMoonLaser < 60000) return;
  
  const hasMoonBee = equippedBees && equippedBees.includes('bee23');
  if(!hasMoonBee) return;
  
  lastMoonLaser = now;
  registerAbilityExecution('moonBeeAbility');
  
  if(!currentField || !fieldData[currentField]) return;
  
  const GRID_W = 30, GRID_H = 30;
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  const isVertical = Math.random() > 0.5;
  const lineIdx = isVertical ? Math.floor(Math.random() * GRID_W) : Math.floor(Math.random() * GRID_H);
  const tiles = [];
  
  // Recopilar tiles
  for(let i = 0; i < (isVertical ? GRID_H : GRID_W); i++){
    const idx = isVertical ? (i * GRID_W + lineIdx) : (lineIdx * GRID_W + i);
    if(fieldData[currentField][idx]) tiles.push(idx);
  }
  
  if(!tiles.length) return;
  
  // Crear lÃ¡ser visual (pÃºrpura)
  const laserEl = document.createElement('div');
  laserEl.style.cssText = `position:absolute;pointer-events:none;z-index:100;background:${isVertical ? 'linear-gradient(180deg,rgba(138,43,226,.9),rgba(75,0,130,.9),rgba(138,43,226,.9))' : 'linear-gradient(90deg,rgba(138,43,226,.9),rgba(75,0,130,.9),rgba(138,43,226,.9))'}`;
  laserEl.style.boxShadow = '0 0 20px rgba(138,43,226,0.9), 0 0 10px rgba(75,0,130,0.7)';
  
  // Grid layout: 30 cols x 15 rows, each 24px per cell
  const cellW = 24, cellH = 24;
  const gridPadding = 0;
  
  if(isVertical){
    // Vertical laser at column lineIdx
    const x = gridPadding + lineIdx * cellW + 12; // center of tile
    laserEl.style.left = (x - 2) + 'px'; // -2 for 4px width center
    laserEl.style.top = gridPadding + 'px';
    laserEl.style.width = '4px';
    laserEl.style.height = (GRID_H * cellH - gridPadding) + 'px';
  } else {
    // Horizontal laser at row lineIdx
    const y = gridPadding + lineIdx * cellH + 12; // center of tile
    laserEl.style.left = gridPadding + 'px';
    laserEl.style.top = (y - 2) + 'px'; // -2 for 4px height center
    laserEl.style.width = (GRID_W * cellW - gridPadding) + 'px';
    laserEl.style.height = '4px';
  }
  
  gridEl.appendChild(laserEl);
  
  // Procesar destrucciÃ³n en 600ms
  setTimeout(() => {
    tiles.forEach(idx => {
      const tile = fieldData[currentField][idx];
      if(!tile) return;
      
      let gain = 0;
      if(tile.ty > 0){
        const range = flowerTypes[tile.ty].pollen;
        gain = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        gain *= 2; // x2 base moon laser
        
        // CrÃ­ticos
        const totalCrit = stats.criticalChance + stats.beeCriticalChance;
        let isCrit = Math.random() * 100 < totalCrit;
        let isSuperCrit = false;
        if(isCrit && Math.random() * 100 < stats.superCriticalChance){
          isSuperCrit = true;
          isCrit = false;
        }
        const critMult = isSuperCrit ? 10 : (isCrit ? stats.criticalPower + stats.beeCriticalPower : 1);
        gain *= critMult;
        
        // Goo
        if(gooTiles[idx]){ gain *= 3.75; delete gooTiles[idx]; }
        
        // Color bonuses (Moon special: x5 blue)
        if(tile.c === 'blue'){ gain *= bluePollenMultiplier * 5; stats.blueTotal += gain; }
        else if(tile.c === 'red'){ gain *= redPollenMultiplier; stats.redTotal += gain; }
        else if(tile.c === 'white'){ gain *= whitePollenMultiplier; stats.whiteTotal += gain; }
        else if(tile.c === 'yellow'){ gain *= yellowPollenMultiplier; stats.yellowTotal = (stats.yellowTotal||0) + gain; }
        else if(tile.c === 'purple'){ gain *= purplePollenMultiplier; stats.purpleTotal = (stats.purpleTotal||0) + gain; }
        
        const capacity = calculateCapacity();
        const add = Math.min(capacity - stats.pollen, gain);
        stats.pollen += add;
        stats.honey += add;
        stats.totalHoney += add;
        pollenThisSec += add;
        
        // Float number
        const tEl = gridEl.querySelector(`[data-idx="${idx}"]`);
        if(tEl){
          const r = tEl.getBoundingClientRect();
          floating(r.left + r.width/2, r.top, add, isCrit, false, false, false, false, isSuperCrit);
        }
      }
      
      // Destruir visualmente
      const tEl = gridEl.querySelector(`[data-idx="${idx}"]`);
      if(tEl){ tEl.style.opacity = '0'; }
      
      fieldData[currentField][idx] = {c:'',ty:0,transparent:true};
      energyTiles[idx] = {createdAt: now, fieldKey: currentField, durationMs: 20000};
      
      // Regenerar en 20s
      setTimeout(() => {
        if(fieldData[currentField] && fieldData[currentField][idx]){
          delete energyTiles[idx];
          fieldData[currentField][idx] = createTile(currentField);
          const t = gridEl.querySelector(`[data-idx="${idx}"]`);
          if(t) renderTile(t, fieldData[currentField][idx]);
          saveGame();
        }
      }, 20000);
    });
    
    // Fade out laser
    laserEl.style.opacity = '0';
    setTimeout(() => laserEl.remove(), 300);
  }, 600);
}

function lionBeeAutoDestruct(){
  if(!equippedBees) return;
  
  // Find ALL lion bees equipped
  const lionBeeIndices = [];
  equippedBees.forEach((beeId, index) => {
    if(beeId === 'bee20') lionBeeIndices.push(index);
  });
  
  if(lionBeeIndices.length === 0) return;
  if(!currentField || !fieldData[currentField]) return;
  
  const now = Date.now();
  const gridEl = document.getElementById("grid");
  if(!gridEl) return;
  
  // Process EACH lion bee with its own timer
  lionBeeIndices.forEach(lionBeeIndex => {
    const timer = getBeeInstanceTimer('bee20', lionBeeIndex);
    
    // Random delay between 30s and 60s for this instance
    const minDelay = 30000, maxDelay = 60000;
    const randomDelay = minDelay + Math.floor(Math.random() * (maxDelay - minDelay));
    
    // Schedule ability execution if interval passed
    if(now >= (timer.lastAbilityScheduledTime || 0)){
      timer.lastAbilityScheduledTime = now + randomDelay;
    }
    
    // Execute ability if scheduled time reached
    if(now >= timer.lastAbilityScheduledTime && now >= (timer.lastAbilityTime || 0)){
      timer.lastAbilityTime = now;
      registerAbilityExecution('lionBeeAutoDestruct');
      
      const GRID_W = 30;
      const GRID_H = 15;
      const totalTiles = GRID_W * GRID_H;
      
      // Destroy 3 random tiles with +100% pollen and guaranteed crit
      const tilesToDestroy = [];
      let attempts = 0;
      while(tilesToDestroy.length < 3 && attempts < 20){
        const idx = Math.floor(Math.random() * totalTiles);
        const tile = fieldData[currentField][idx];
        if(tile && tile.ty > 0 && !tilesToDestroy.includes(idx)){
          tilesToDestroy.push(idx);
        }
        attempts++;
      }
      
      // Destroy each tile with staggered timing
      tilesToDestroy.forEach((idx, order) => {
        setTimeout(() => {
          const tile = fieldData[currentField][idx];
          if(!tile) return;
          
          const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
          if(!tileEl) return;
          
          // Get pollen value
          const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
          const pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
          
          // +100% pollen bonus from Lion Bee
          let gain = pollenValue * 2; // x2 from +100%
          
          // Apply color multipliers
          if(tile.c === 'red'){
            gain *= redPollenMultiplier;
            stats.redTotal += gain;
          } else if(tile.c === 'blue'){
            gain *= bluePollenMultiplier;
            stats.blueTotal += gain;
          } else if(tile.c === 'white'){
            gain *= whitePollenMultiplier;
            stats.whiteTotal += gain;
          } else if(tile.c === 'yellow'){
            gain *= yellowPollenMultiplier;
            stats.yellowTotal = (stats.yellowTotal || 0) + gain;
          } else if(tile.c === 'purple'){
            gain *= purplePollenMultiplier;
            stats.purpleTotal = (stats.purpleTotal || 0) + gain;
          }
          
          // Respeta capacidad
          const currentCapacity = calculateCapacity();
          const added = Math.min(currentCapacity - stats.pollen, gain);
          stats.pollen += added;
          pollenThisSec += added;
          
          // Guaranteed critical hit
          const totalCritPower = stats.criticalPower + stats.beeCriticalPower;
          const finalGain = added * totalCritPower;
          
          const r = tileEl.getBoundingClientRect();
          floating(r.left + r.width / 2, r.top, finalGain, true, false, false, false); // true = is critical
          
          // Destroy tile visually
          tileEl.style.transition = "opacity 0.3s ease-out";
          tileEl.style.opacity = "0";
          
          // Reset tile
          fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
          
          // Regenerate tile after 0.5-2.5s
          const regenerationTime = 500 + Math.random() * 2000;
          const regenerationTimer = setTimeout(() => {
            if(fieldData[currentField] && fieldData[currentField][idx]){
              fieldData[currentField][idx] = createTile(currentField);
              if(currentField === currentField){
                const gridEl = document.getElementById("grid");
                const tileEl = gridEl.querySelector(`[data-idx="${idx}"]`);
                if(tileEl){
                  renderTile(tileEl, fieldData[currentField][idx]);
                  // Fade in animation
                  tileEl.style.transition = "opacity 0.8s ease-in";
                  tileEl.style.opacity = "0";
                  void tileEl.offsetWidth;
                  tileEl.style.opacity = "1";
                }
              }
              saveGame();
            }
          }, regenerationTime);
        }, order * 100);
      });
    }
  });
}

function fourBeeAbility(){
  const now = Date.now();
  const cooldown = 5 * 60 * 1000; // 5 minutes
  
  if(now - lastFourFormation < cooldown) return;
  
  const hasFourBee = equippedBees && equippedBees.includes('bee25');
  if(!hasFourBee) return;
  
  lastFourFormation = now;
  registerAbilityExecution('fourFormation');
  
  const GRID_W = 30;
  const GRID_H = 15;
  const gridEl = document.getElementById("grid");
  
  // Find a random position to draw "4" shape
  // 4 shape is roughly:
  // X . .
  // X . .
  // X X X
  // . . X
  // . . X
  
  // Pick random top-left corner for the pattern
  let startRow, startCol;
  do {
    startRow = Math.floor(Math.random() * (GRID_H - 4));
    startCol = Math.floor(Math.random() * (GRID_W - 2));
  } while(startRow < 0 || startCol < 0);
  
  // Define the "4" pattern (relative positions)
  const fourPattern = [
    [0, 0], [1, 0], [2, 0], // Left vertical line
    [2, 1], [2, 2],         // Horizontal line
    [1, 2], [0, 2]          // Right vertical line (down)
  ];
  
  const tilesToDestroy = [];
  fourPattern.forEach(([row, col]) => {
    const idx = (startRow + row) * GRID_W + (startCol + col);
    const tile = fieldData[currentField]?.[idx];
    if(tile && tile.ty > 0){
      tilesToDestroy.push(idx);
    }
  });
  
  // Destroy the tiles with x1.4 pollen multiplier
  tilesToDestroy.forEach((idx, order) => {
    setTimeout(() => {
      const tile = fieldData[currentField]?.[idx];
      if(!tile) return;
      
      const tileEl = gridEl?.querySelector(`[data-idx="${idx}"]`);
      if(!tileEl) return;
      
      // Get pollen value with x1.4 multiplier
      const pollenRange = flowerTypes[tile.ty]?.pollen || {min: 1, max: 5};
      let pollenValue = Math.floor(Math.random() * (pollenRange.max - pollenRange.min + 1)) + pollenRange.min;
      pollenValue *= 1.4; // x1.4 multiplier
      
      let gain = pollenValue * (1 + (stats.pollenBonus + stats.beePollenBonus) / 100) * (1 + (TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0) / 100);
      
      // Respeta capacidad
      const currentCapacity = calculateCapacity();
      const added = Math.min(currentCapacity - stats.pollen, gain);
      stats.pollen += added;
      pollenThisSec += added;
      
      const r = tileEl.getBoundingClientRect();
      floating(r.left + r.width / 2, r.top, added, false, false, false, false);
      
      // Destroy tile
      fieldData[currentField][idx] = {c: "", ty: 0, transparent: true};
      renderTile(tileEl, fieldData[currentField][idx]);
      tileEl.style.transition = "opacity 0.2s";
      tileEl.style.opacity = "0";
      
      // Regenerate
      setTimeout(() => {
        fieldData[currentField][idx] = createTile(currentField);
        renderTile(tileEl, fieldData[currentField][idx]);
        tileEl.style.opacity = "1";
      }, 1000);
    }, order * 100);
  });
}

function buildBeeGrid(){
  const beeGridEl = document.getElementById("beeGrid");
  beeGridEl.innerHTML = "";
  
  // Mostrar special bees equipadas (hasta 3 slots especiales al inicio)
  for(let i = 0; i < 3; i++){
    if(i < equippedSpecialBees.length && equippedSpecialBees[i]){
      const specialBee = SPECIAL_BEES.find(b => b.id === equippedSpecialBees[i]);
      if(specialBee){
        const specialSlot = document.createElement("div");
        specialSlot.className = "bee-slot special-bee";
        specialSlot.style.background = `linear-gradient(90deg, rgba(76,175,80,0.4), ${specialBee.color}, rgba(76,175,80,0.4))`;
        specialSlot.style.border = "3px solid #4CAF50";
        specialSlot.innerHTML = `<img src="images/${specialBee.img}" style="width:100%;height:100%;object-fit:cover;"><div style="position:absolute;top:2px;left:2px;background:#4CAF50;color:#000;border-radius:0px;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;">${i+1}</div>`;
        specialSlot.title = specialBee.name + ' (SPECIAL)';
        specialSlot.style.cursor = "pointer";
        const slotIndex = i; // Capturar Ã­ndice
        specialSlot.onmouseenter = (ev) => {
          const tt = document.createElement('div'); tt.className='bee-tooltip';
          tt.id = 'beeTooltip';
          tt.innerHTML = `<b>${specialBee.name}</b><div style="color:#4CAF50">SPECIAL (Slot ${slotIndex+1}/3)</div><div style="margin-top:6px;color:#ddd">${specialBee.desc || ''}</div>`;
          document.body.appendChild(tt);
          try{ const bold = document.getElementById('beeTooltip').querySelector('b'); if(bold) bold.style.color = '#4CAF50'; }catch(e){}
          const move = (e)=>{ const el = document.getElementById('beeTooltip'); if(!el) return; el.style.left = (e.clientX + 12) + 'px'; el.style.top = (e.clientY + 12) + 'px'; };
          move(ev);
          specialSlot.addEventListener('mousemove', move);
          specialSlot._moveHandler = move;
        };
        specialSlot.onmouseleave = ()=>{ const el = document.getElementById('beeTooltip'); if(el) el.remove(); if(specialSlot._moveHandler) specialSlot.removeEventListener('mousemove', specialSlot._moveHandler); };
        specialSlot.onclick = () => {
          const tt = document.getElementById('beeTooltip'); if(tt) tt.remove();
          const confirmKey = `special_${slotIndex}_${specialBee.id}`;
          const now = Date.now();
          
          // Check if this is a second click within 2 seconds
          if(pendingConfirmations[confirmKey] && (now - pendingConfirmations[confirmKey]) < 2000) {
            // Second click confirmed - delete
            delete pendingConfirmations[confirmKey];
            equippedSpecialBees.splice(slotIndex, 1);
            saveGame();
            buildBeeGrid();
            updateBeeAbilities();
            updateUI();
            showNotification('Bee especial eliminada', 'success');
          } else {
            // First click - show warning
            pendingConfirmations[confirmKey] = now;
            showNotification(`${specialBee.name} is ${specialBee.rarity}. Click again to confirm deletion.`, 'warning');
            // Clear confirmation after 2 seconds
            setTimeout(() => {
              delete pendingConfirmations[confirmKey];
            }, 2000);
          }
        };
        beeGridEl.appendChild(specialSlot);
      }
    }
  }
  
  for(let i = 0; i < 50; i++){
    const slot = document.createElement("div");
    slot.className = "bee-slot";
    slot.setAttribute("data-slot", i);
    
    if(i < maxSlots){
      // unlocked slot
      if(equippedBees[i]) {
        const bee = BEES.find(b => b.id === equippedBees[i]);
        if(bee) {
          slot.style.background = bee.color;
          
          // Get frame color based on rarity
          const getRarityFrameColor = () => {
            switch(bee.rarity){
              case 'common': return '#CD7F32'; // Copper
              case 'rare': return '#C0C0C0'; // Silver
              case 'epic': return '#FFD700'; // Gold
              case 'legendary': return '#00D9FF'; // Diamond
              case 'mythic': return '#9b59b6'; // Purple
              case 'ultimate': return '#FF00FF'; // Magenta
              case 'special': return '#1CFF7C'; // Emerald
              default: return '#999';
            }
          };
          
          const frameBorderColor = getRarityFrameColor();
          const frameBorderWidth = (bee.rarity === 'mythic' || bee.rarity === 'ultimate' || bee.rarity === 'special') ? '4px' : '2px';
          
          // Add glow animation styles for legendary, mythic, ultimate, and special
          const glowColor = bee.rarity === 'legendary' ? 'rgba(0,217,255,0.6)' : 
                            bee.rarity === 'mythic' ? 'rgba(155,89,182,0.6)' :
                            bee.rarity === 'ultimate' ? 'rgba(255,0,255,0.6)' :
                            bee.rarity === 'special' ? 'rgba(28,255,124,0.6)' : 'none';
          
          if(bee.rarity === 'legendary' || bee.rarity === 'mythic' || bee.rarity === 'ultimate' || bee.rarity === 'special'){
            const styleEl = document.createElement('style');
            styleEl.id = `grid-glow-${bee.id}-${i}`;
            styleEl.textContent = `
              [data-slot="${i}"] {
                animation: grid-bee-glow-${bee.id}-${i} 2.5s ease-in-out infinite;
              }
              @keyframes grid-bee-glow-${bee.id}-${i} {
                0% { box-shadow: 0 0 12px ${glowColor}, inset 0 0 10px ${glowColor}; }
                50% { box-shadow: 0 0 20px ${glowColor}, inset 0 0 10px ${glowColor}; }
                100% { box-shadow: 0 0 12px ${glowColor}, inset 0 0 10px ${glowColor}; }
              }
            `;
            document.head.appendChild(styleEl);
          }
          
          slot.innerHTML = `<img src="images/${bee.img}" style="width:100%;height:100%;object-fit:cover;">`;
          slot.title = bee.name + ' (' + bee.rarity + ')';
          slot.style.cursor = "pointer";
          slot.style.border = `${frameBorderWidth} solid ${frameBorderColor}`;
          
          // add particle visual for legendary/mythic/ultimate bees
          if(bee.rarity === 'legendary' || bee.rarity === 'mythic' || bee.rarity === 'ultimate'){
            try{ createParticles(slot, bee.rarity === 'mythic' ? '#9b59b6' : bee.rarity === 'ultimate' ? '#FF00FF' : '#ffd166', 6); }catch(e){}
          }
          if(bee.rarity === 'mythic'){
            slot.classList.add('mythic-bee');
          } else if(bee.rarity === 'ultimate'){
            slot.classList.add('ultimate-bee');
          }
          // Only add class for ultimate bees - remove other rarity classes
          // tooltip on hover showing ability and stats
          slot.onmouseenter = (ev) => {
            const tt = document.createElement('div'); tt.className='bee-tooltip';
            tt.id = 'beeTooltip';
            const abilityLabel = bee.ability || 'N/A';
            const rarityColors = {common:'#FFD700',uncommon:'#00FF00',rare:'#00BFFF',epic:'#9370DB',legendary:'#FFD700',mythic:'#9b59b6',special:'#4CAF50'};
            const rarityColor = rarityColors[bee.rarity] || '#ccc';
            const rarityUpper = bee.rarity.toUpperCase();
            
            // Get ability description from ABILITY_TYPES if available
            const abilityDesc = bee.ability && bee.ability !== 'ninguno' ? (ABILITY_TYPES[bee.ability]?.desc || bee.ability) : null;
            const abilitySection = abilityDesc ? `<div style="margin-top:6px;color:#FFD700"><b>Ability Name:</b></div><div style="margin-left:6px;color:#AEF1C4;font-size:12px">${abilityDesc}</div>` : '';
            
            tt.innerHTML = `<b>${bee.name}</b><div style="color:${rarityColor}">${rarityUpper}</div><div style="margin-top:6px;color:#ddd">${bee.desc || ''}</div>${abilitySection}<div style="margin-top:6px;color:#CFF1D6">PatrÃ³n: ${abilityLabel} ${bee.value}</div>`;
            document.body.appendChild(tt);
            // color the name according to bee color / rarity
            try{ const bold = document.getElementById('beeTooltip').querySelector('b'); if(bold) bold.style.color = bee.color || (bee.rarity === 'mythic' ? '#9b59b6' : '#f1c40f'); }catch(e){}
            const move = (e)=>{ const el = document.getElementById('beeTooltip'); if(!el) return; el.style.left = (e.clientX + 12) + 'px'; el.style.top = (e.clientY + 12) + 'px'; };
            move(ev);
            slot.addEventListener('mousemove', move);
            slot._moveHandler = move;
          };
          slot.onmouseleave = ()=>{ const el = document.getElementById('beeTooltip'); if(el) el.remove(); if(slot._moveHandler) slot.removeEventListener('mousemove', slot._moveHandler); };
          
          slot.onclick = () => {
            // ensure tooltip is removed when deleting
            const tt = document.getElementById('beeTooltip'); if(tt) tt.remove();
            // delete equipped bee permanently (with confirmation for mythic)
            if(bee.rarity === 'ultimate' || bee.rarity === 'mythic'){

              const confirmKey = `bee_${i}_${bee.id}`;
              const now = Date.now();
              
              // Check if this is a second click within 2 seconds
              if(pendingConfirmations[confirmKey] && (now - pendingConfirmations[confirmKey]) < 2000) {
                // Second click confirmed - delete
                delete pendingConfirmations[confirmKey];
                const idxOwned = ownedBees.indexOf(bee.id);
                if(idxOwned >= 0) ownedBees.splice(idxOwned,1);
                equippedBees.splice(i,1);
                saveGame();
                buildBeeGrid();
                buildEggs();
                updateBeeAbilities();
                updateUI();
                showNotification('Bee mÃ­tica eliminada', 'success');
              } else {
                // First click - show warning
                pendingConfirmations[confirmKey] = now;
                showNotification(`${bee.name} is ${bee.rarity}. Click again to confirm deletion.`, 'warning');
                // Clear confirmation after 2 seconds
                setTimeout(() => {
                  delete pendingConfirmations[confirmKey];
                }, 2000);
              }
            } else {
              // Non-mythic bee - delete immediately
              const idxOwned = ownedBees.indexOf(bee.id);
              if(idxOwned >= 0) ownedBees.splice(idxOwned,1);
              equippedBees.splice(i,1);
              saveGame();
              buildBeeGrid();
              buildEggs();
              updateBeeAbilities();
              updateUI();
              showNotification('Bee eliminada', 'info');
            }
          };
        }
      }
    } else {
      // locked slot
      slot.style.opacity = '0.35';
      slot.title = 'Locked slot - purchasable in shop';
    }
    
    beeGridEl.appendChild(slot);
  }
}

/* ================= FIELD ================= */
function weightedPick(o){
let t=Object.values(o).reduce((a,b)=>a+b,0);
let r=Math.random()*t;
for(const k in o){r-=o[k];if(r<=0)return k;}
}
function createTile(f){
const F=fields[f];
const c=weightedPick(Object.fromEntries(Object.entries(F.colors).map(([k,v])=>[k,v.chance])));
const ty=Number(weightedPick(F.colors[c].flowers));
return{c,ty,transparent:false};
}
function buildFieldList(){
const fieldListEl = document.getElementById("fieldList");
fieldListEl.innerHTML="";
for(const k in fields){
  const req = fieldRequirements[k] || 0;
  const unlocked = (maxEquippedBeesEver >= req) || req === 0;

  const d = document.createElement("div");
  d.className = "field-item" + (k === currentField ? " active" : "") + (unlocked ? "" : " locked");

  const left = document.createElement("div");
  left.className = "left";
  const img = document.createElement("img");
  img.src = `images/${k}.png`;
  img.alt = fields[k].name;
  const name = document.createElement("div");
  name.className = "name";
  name.textContent = fields[k].name;
  left.appendChild(img);
  left.appendChild(name);

  const reqSpan = document.createElement("div");
  reqSpan.className = "req-bees";
  reqSpan.textContent = `Bees ${req}`;

  if(unlocked){
    d.onclick = () => {
      if(k === currentField) return;
      // update time for previous field
      try{
        const now = Date.now();
        const delta = Math.floor((now - lastFieldEnter)/1000);
        ensureFieldStats(currentField);
        fieldStats[currentField].timeSpentSeconds = (fieldStats[currentField].timeSpentSeconds||0) + delta;
        lastFieldEnter = now;
      }catch(e){}
      currentField = k; buildFieldList(); buildGrid(); saveGame();
    };
  } else {
    d.title = `Requiere ${req} bees para desbloquear`;
  }

  d.appendChild(left);
  d.appendChild(reqSpan);
  fieldListEl.appendChild(d);
}
}
function buildGrid(){
const gridEl = document.getElementById("grid");
gridEl.innerHTML="";
if(!fieldData[currentField]){
  const GRID_W = 30;
  const GRID_H = 15;
  fieldData[currentField]=Array.from({length:GRID_W*GRID_H},()=>createTile(currentField));
}
fieldData[currentField].forEach((d,i)=>{
const t=document.createElement("div");
t.className="tile";
t.setAttribute("data-idx", i);
renderTile(t,d);
// IMPORTANT: Don't rely on d parameter, always get fresh data from fieldData
t.onclick=()=>clickTile(t, fieldData[currentField][i], currentField, i);
// Right-click to remove effects from tile
t.oncontextmenu=(e)=>{
  e.preventDefault();
  showTileEffectMenu(i, e.pageX, e.pageY);
  return false;
};
gridEl.appendChild(t);
});
}
function renderTile(t,d){
t.innerHTML="";
t.classList.toggle("transparent", d.transparent || d.ty === 0);
// Remove all effect classes first
t.classList.remove("fire-effect", "dark-fire-effect", "goo-effect", "energy-effect", "crimson-effect", "enhanced-goo-effect", "critical-error-effect");
if(d.transparent || d.ty === 0)return;
const img=document.createElement("img");
img.src=`images/flower_${d.c}_${d.ty}.png`;
t.appendChild(img);

// Check if this tile has fire or dark fire effects
const tileIdx = parseInt(t.getAttribute("data-idx"));
if(fireBeeTilesActive[tileIdx]){
  t.classList.add("fire-effect");
}
if(spicyTilesActive[tileIdx]){
  t.classList.add("dark-fire-effect");
}
if(gooTiles[tileIdx]){
  t.classList.add("goo-effect");
}
if(energyTiles[tileIdx]){
  t.classList.add("energy-effect");
}
if(crimsonTilesActive[tileIdx]){
  t.classList.add("crimson-effect");
}
if(enhancedGooTiles[tileIdx]){
  t.classList.add("enhanced-goo-effect");
}
if(criticalErrorTiles[tileIdx]){
  t.classList.add("critical-error-effect");
}
}

/* ================= FLOATING ================= */
function calculateFloatingNumberMinimum(){
  // Calculate the minimum value for floating numbers based on player stats
  // Formula: Base pollen * multipliers from various sources
  
  const beePollencontent = stats.beePollenBonus / 100; // e.g., 0.15 for 15% bonus
  const toolBonus = TOOLS.find(t => t.id === equippedToolId)?.pollenBonus || 0;
  
  // Total multiplier from all bonuses
  let totalMultiplier = 1 + (stats.pollenBonus + stats.beePollenBonus) / 100;
  totalMultiplier += toolBonus / 100;
  
  // Add color bonuses (average of active ones)
  const colorMultipliers = [redPollenMultiplier, bluePollenMultiplier, whitePollenMultiplier];
  const avgColorBonus = colorMultipliers.reduce((a, b) => a + b, 0) / colorMultipliers.length;
  totalMultiplier *= avgColorBonus;
  
  // Add critical hit potential (average chance weighted by power)
  const critChance = Math.min(100, stats.criticalChance + stats.beeCriticalChance) / 100;
  const critPower = stats.criticalPower + stats.beeCriticalPower;
  const critMultiplier = 1 + (critChance * (critPower - 1));
  totalMultiplier *= critMultiplier;
  
  // Base minimum: account for number of bees (more bees = more consistent drops)
  const beeFactor = Math.max(1, equippedBees.length / 10);
  
  // Final minimum threshold
  // Avoid showing numbers smaller than 1% of calculated potential
  const minThreshold = Math.floor(Math.max(1, totalMultiplier * beeFactor * 0.1));
  
  return Math.max(1, minThreshold);
}

function floating(x,y,val, isCritical = false, isGoo = false, isInstantConversion = false, isLaser = false, isPhoton = false, isSuperCritical = false){
const minValue = calculateFloatingNumberMinimum();

// Don't show numbers below minimum threshold (except for critical/goo/instant/laser/photon/superCritical which always show)
if(!isCritical && !isGoo && !isInstantConversion && !isLaser && !isPhoton && !isSuperCritical && val < minValue) return;

const f=document.createElement("div");
f.className="floating";
f.textContent="+"+fmt(val);
f.style.left=x+"px";
f.style.top=y+"px";

if(isSuperCritical){
  // Estilo especial para nÃºmeros SUPER CRITICAL - reducido a tamaÃ±o moderado
  f.style.fontSize="20px";
  f.style.fontWeight="bold";
  f.style.color="#ff0000";
  f.style.textShadow="0 0 15px #ff0000, 0 0 30px #ff0000, 0 0 45px #ff8800";
  f.style.setProperty("--x",(Math.random()*80-40)+"px");
  f.style.animation="super-critical-color 0.6s ease-in-out infinite, super-critical-rotate 0.8s ease-in-out infinite, super-critical-float 3.5s ease-out forwards";
  f.style.zIndex="10000";
  
  setTimeout(()=>{ f.remove(); }, 3500);
}
else if(isLaser){
  // Estilo especial para nÃºmeros del Laser - grande y con animaciÃ³n rojo-amarillo
  f.style.fontSize="22px";
  f.style.fontWeight="bold";
  f.style.setProperty("--x",(Math.random()*40-20)+"px");
  f.style.setProperty("--r",(Math.random()*40-20)+"deg");
  f.style.animation="float 3s ease-out forwards";
  f.style.color = "#FF4500";
  f.style.textShadow = "0 0 10px #FF4500";
  
  // AnimaciÃ³n de color rojo a amarillo en bucle
  let colorPhase = 0;
  const colorInterval = setInterval(()=>{
    colorPhase += 0.05;
    // InterpolaciÃ³n entre rojo (#FF0000) y amarillo (#FFFF00)
    const progress = (Math.sin(colorPhase) + 1) / 2; // 0 a 1
    const r = Math.floor(255);
    const g = Math.floor(0 + (255 * progress)); // 0 a 255
    const b = 0;
    const color = `rgb(${r},${g},${b})`;
    f.style.color = color;
    f.style.textShadow = `0 0 12px ${color}`;
  }, 30);
  
  setTimeout(()=>{ clearInterval(colorInterval); f.remove(); }, 3000);
}
else if(isGoo){
  // Estilo especial para nÃºmeros de Goo
  const gooColors = ['#FF69B4', '#39FF14', '#9D4EDD'];
  let colorIndex = 0;
  f.style.fontSize="18px";
  f.style.fontWeight="bold";
  f.style.setProperty("--x",(Math.random()*50-25)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 4s ease-out forwards"; // MÃ¡s tiempo
  f.style.textShadow="0 0 12px " + gooColors[0];
  
  // Cambiar color cada 400ms
  const colorInterval = setInterval(()=>{
    colorIndex = (colorIndex + 1) % gooColors.length;
    f.style.color = gooColors[colorIndex];
    f.style.textShadow = "0 0 12px " + gooColors[colorIndex];
  }, 400);
  
  setTimeout(()=>{ clearInterval(colorInterval); f.remove(); }, 4000);
  f.style.color = gooColors[0];
  f.style.animation="float 4s ease-out forwards";
}
else if(isCritical){
  f.style.color="#ff1493";
  f.style.fontSize="18px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 10px #ff1493";
  f.style.setProperty("--x",(Math.random()*60-30)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 2.5s ease-out forwards";
  
  // PartÃ­culas crÃ­ticas
  for(let i=0; i<8; i++){
    const p=document.createElement("div");
    p.style.position="absolute";
    p.style.width="8px";
    p.style.height="8px";
    p.style.background="#ff1493";
    p.style.borderRadius="0";
    p.style.left=x+"px";
    p.style.top=y+"px";
    p.style.pointerEvents="none";
    p.style.animation=`particle-burst 1s ease-out forwards`;
    p.style.setProperty("--px",(Math.random()*200-100)+"px");
    p.style.setProperty("--py",(Math.random()*200-100)+"px");
    document.body.appendChild(p);
    setTimeout(()=>p.remove(),1000);
  }
}
else if(isInstantConversion){
  // Estilo especial para nÃºmeros de Instant Conversion (miel)
  f.textContent="&"+fmt(val);
  f.style.color="#FFD700";
  f.style.fontSize="16px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 8px #FFD700";
  f.style.setProperty("--x",(Math.random()*40-20)+"px");
  f.style.setProperty("--r",(Math.random()*30-15)+"deg");
  f.style.animation="float 3s ease-out forwards";
}
else if(isPhoton){
  // Estilo especial para nÃºmeros de Photon Bee - amarillo neon con glow intenso
  f.style.color="#FFFF00";
  f.style.fontSize="20px";
  f.style.fontWeight="bold";
  f.style.textShadow="0 0 15px #FFFF00, 0 0 25px #FFD700, 0 0 35px #FF8C00";
  f.style.setProperty("--x",(Math.random()*50-25)+"px");
  f.style.setProperty("--r",(Math.random()*60-30)+"deg");
  f.style.animation="float 3s ease-out forwards";
}

  // non-critical float styling depending on value with compact notation
  else if(val<1000){
    f.textContent="+"+Math.floor(val);
    f.style.color="#f1c40f";
    f.style.fontSize="11px";
    f.style.setProperty("--x","0px");
    f.style.setProperty("--r","0deg");
  } else if(val<1000000){
    const compact = (val/1000).toFixed(1) + 'K';
    f.textContent="+"+compact;
    f.style.color="#f39c12";
    f.style.fontSize="13px";
    f.style.setProperty("--x",(Math.random()*14-7)+"px");
    f.style.setProperty("--r","0deg");
  } else if(val<1000000000){
    const compact = (val/1000000).toFixed(1) + 'M';
    f.textContent="+"+compact;
    f.style.color="#9b59b6";
    f.style.fontSize="14px";
    f.style.setProperty("--x",(Math.random()*30-15)+"px");
    f.style.setProperty("--r",(Math.random()*20-10)+"deg");
  } else {
    const compact = (val/1000000000).toFixed(1) + 'B';
    f.textContent="+"+compact;
    f.style.color="#e74c3c";
    f.style.fontSize="15px";
    f.style.setProperty("--x",(Math.random()*40-20)+"px");
    f.style.setProperty("--r",(Math.random()*30-15)+"deg");
  }
  document.body.appendChild(f);
  
  // Determinar duraciÃ³n segÃºn tipo
  let duration = 1200;
  if(isGoo) duration = 4000;
  else if(isInstantConversion) duration = 2000;
  else if(isCritical) duration = 2500;
  
  if(!isGoo) setTimeout(()=>f.remove(), duration);
}

function showFloatingText(x, y, text, color){
  const f = document.createElement("div");
  f.style.position = "fixed";
  f.style.left = x + "px";
  f.style.top = y + "px";
  f.style.fontSize = "16px";
  f.style.fontWeight = "bold";
  f.style.color = color;
  f.style.textShadow = `0 0 8px ${color}`;
  f.style.pointerEvents = "none";
  f.style.zIndex = "9999";
  f.style.animation = "float 2s ease-out forwards";
  f.textContent = text;
  document.body.appendChild(f);
  setTimeout(() => f.remove(), 2000);
}

// create simple decorative particles inside a container (idempotent)
function createParticles(container, color='#f1c40f', count=6){
  if(!container || container.dataset.particlesInitialized) return;
  container.dataset.particlesInitialized = '1';
  for(let i=0;i<count;i++){
    const p = document.createElement('div');
    p.className = 'particle';
    // smaller particle visual
    p.style.width = '4px'; p.style.height = '4px';
    const left = Math.random()*80 + '%';
    const top = Math.random()*80 + '%';
    p.style.left = left; p.style.top = top;
    p.style.background = color;
    const px = (Math.random()*100-50) + 'px';
    const py = (Math.random()*100-60) + 'px';
    p.style.setProperty('--px', px);
    p.style.setProperty('--py', py);
    p.style.animationDuration = (900 + Math.random()*900) + 'ms';
    p.style.opacity = 0.95;
    container.appendChild(p);
  }
}

/* ================= CLICK ================= */
function clickTile(t, d, f, i){
  const tool = TOOLS.find(toolItem => toolItem.id === equippedToolId);
  if (!tool) return;

  // Apply Hasty Bee cooldown reduction (-20%)
  let effectiveCooldown = tool.cooldown;
  if(equippedBees.includes('bee3')){
    effectiveCooldown *= 0.8;
  }
  
  // Apply Porcelain Dipper buff cooldown reduction (-20%)
  if(porcelainBuffActive){
    effectiveCooldown *= 0.8;
  }

  if (Date.now() - lastClick < effectiveCooldown) return;
  lastClick = Date.now();

  // count click for current field
  try{ ensureFieldStats(currentField); fieldStats[currentField].clicks = (fieldStats[currentField].clicks||0) + 1; }catch(e){}
  
  applyToolPattern(i, f);
  updateUI();
}





/* ================= CONVERT ================= */
setInterval(()=>{
const totalConvertBonus = stats.convertBonus + stats.beeConvertBonus;
const rate = 0.1 * (1 + totalConvertBonus / 100);
const c = Math.min(stats.pollen, rate);
stats.pollen -= c;
stats.honey += c * 0.15;
stats.totalHoney += c * 0.15;
honeyThisSec = c * 0.15;
pollenThisSec = 0;
updateUI();
saveGame();
}, 1000);

/* ================= SPECIAL BEE ABILITIES ================= */
/* ================= UPGRADES UI ================= */
function buildUpgrades(){
  const upgradesEl = document.getElementById("upgrades");
  if(!upgradesEl) {
    console.error('âŒ upgrades element not found');
    return;
  }
  
  upgradesEl.innerHTML="";
  
  // Verificar que UPGRADES estÃ© disponible
  if(typeof UPGRADES === 'undefined' || !Array.isArray(UPGRADES)) {
    console.error('âŒ UPGRADES no estÃ¡ definido o no es un array:', UPGRADES);
    const errorMsg = document.createElement('div');
    errorMsg.style.cssText = 'color:#ff6666;padding:20px;margin:10px;background:#3c2222;border-radius:0px;';
    errorMsg.innerHTML = 'âš ï¸ <strong>Error de ConfiguraciÃ³n</strong><br>Los datos de upgrades no cargaron.<br>Abre la consola (F12) para mÃ¡s detalles.<br><br><button onclick="location.reload()">Recargar PÃ¡gina</button>';
    upgradesEl.appendChild(errorMsg);
    return;
  }
  
  // Load saved category state
  const categoryState = getCategoryState('upgrades');
  
  // Helper function to create a section with toggle
  const createUpgradeSection = (title, color, items, categoryKey) => {
    const headerContainer = document.createElement('div');
    headerContainer.style.cssText = 'display:flex;gap:12px;align-items:center;margin:18px 0 12px 0;justify-content:space-between;';
    
    const header = document.createElement('div');
    header.style.cssText = `color:${color};font-weight:bold;font-size:16px;text-transform:uppercase;padding:10px;border-left:4px solid ${color};flex:1;`;
    header.textContent = title;
    
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'rarity-toggle-btn';
    toggleBtn.textContent = 'â–¼';
    toggleBtn.setAttribute('data-category', categoryKey);
    
    headerContainer.appendChild(header);
    headerContainer.appendChild(toggleBtn);
    upgradesEl.appendChild(headerContainer);
    
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'rarity-frames-container';
    itemsContainer.setAttribute('data-category-container', categoryKey);
    
    if(categoryState.collapsed[categoryKey]){
      itemsContainer.style.display = 'none';
      toggleBtn.classList.add('collapsed');
      toggleBtn.textContent = 'â–¶';
    }
    
    toggleBtn.onclick = (e) => {
      e.stopPropagation();
      toggleCategoryVisibility(toggleBtn, itemsContainer, 'upgrades', categoryKey);
    };
    
    upgradesEl.appendChild(itemsContainer);
    return itemsContainer;
  };
  
  // 1. SPECIAL BEES section
  if(SPECIAL_BEES && SPECIAL_BEES.length > 0){
    const specialBeesContainer = createUpgradeSection('Special Bees', '#1CFF7C', [], 'special_bees');
    SPECIAL_BEES.forEach(bee => {
      const isOwned = ownedSpecialBees.includes(bee.id);
      const isEquipped = equippedSpecialBees.includes(bee.id);
      const f = document.createElement('div');
      f.className = 'upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-bee-id', bee.id);
      f.setAttribute('data-bee-name', bee.name);
      
      // Color based on rarity
      const rarityColors = {
        'common': '#CD7F32',
        'rare': '#C0C0C0',
        'epic': '#FFD700',
        'legendary': '#00D9FF',
        'mythic': '#9b59b6',
        'special': '#1CFF7C'
      };
      const beeColor = rarityColors[bee.rarity] || '#1CFF7C';
      
      const top = document.createElement('div'); top.className = 'upgrade-top';
      
      // Name with rarity indicator
      const nameEl = document.createElement('div'); 
      nameEl.style.fontWeight='bold'; 
      nameEl.style.color=beeColor; 
      nameEl.style.fontSize='16px'; 
      nameEl.textContent = bee.name + (isEquipped ? ' âœ¨' : '');
      top.appendChild(nameEl);
      
      // Rarity and price type
      const rarityEl = document.createElement('div');
      rarityEl.style.cssText = `color:${beeColor};font-size:11px;margin-top:2px;font-weight:bold;text-transform:uppercase;`;
      rarityEl.textContent = `${bee.rarity} â€¢ ${bee.priceType === 'tickets' ? 'ðŸŽ« Tickets' : 'ðŸ¯ Honey'}`;
      top.appendChild(rarityEl);
      
      // Description with better formatting
      const descEl = document.createElement('div'); 
      descEl.className='upgrade-desc'; 
      descEl.style.fontSize='13px'; 
      descEl.style.marginTop='6px';
      descEl.textContent = bee.desc || 'Special bee ability';
      top.appendChild(descEl);
      
      // Ability section with image and tooltip
      if(bee.ability && bee.ability !== 'N/A'){
        const abilitySection = document.createElement('div');
        abilitySection.style.cssText = `margin-top:8px;padding:8px;background:${beeColor}33;border-radius:0px;border-left:3px solid ${beeColor};`;
        
        const abilityTitle = document.createElement('div');
        abilityTitle.style.cssText = `color:${beeColor};font-size:12px;font-weight:bold;margin-bottom:6px;`;
        abilityTitle.textContent = `âš¡ Special Ability: ${bee.ability}`;
        abilitySection.appendChild(abilityTitle);
        
        // Get ability details if they exist
        const abilityDetails = bee.abilityDetails ? `${bee.abilityDetails}` : 'Hover for more info';
        
        const abilityDesc = document.createElement('div');
        abilityDesc.style.cssText = `color:#fff;font-size:11px;line-height:1.4;`;
        abilityDesc.textContent = abilityDetails;
        abilitySection.appendChild(abilityDesc);
        
        // Get buffs from ability
        const buffs = getBeeBuffs(bee.id);
        if(buffs && Object.keys(buffs).length > 0){
          const buffsList = document.createElement('div');
          buffsList.style.cssText = `margin-top:6px;font-size:10px;color:#ddd;`;
          const buffEntries = Object.entries(buffs).filter(([k,v]) => v && typeof v !== 'object').slice(0, 3);
          buffEntries.forEach(([k, v]) => {
            const label = k.replace(/([A-Z])/g, ' $1').trim();
            const valStr = (typeof v === 'number' && v > 1) ? `+${Math.round((v-1)*100)}%` : `${v}`;
            buffsList.innerHTML += `<div>â€¢ ${label}: ${valStr}</div>`;
          });
          // Add color multipliers separately if they exist
          if(buffs.colorMultipliers && typeof buffs.colorMultipliers === 'object'){
            const colorEntries = Object.entries(buffs.colorMultipliers).slice(0, 2);
            colorEntries.forEach(([color, mult]) => {
              buffsList.innerHTML += `<div>â€¢ ${color.charAt(0).toUpperCase() + color.slice(1)} Pollen: x${mult.toFixed(2)}</div>`;
            });
          }
          abilitySection.appendChild(buffsList);
        }
        
        top.appendChild(abilitySection);
      }
      
      f.appendChild(top);
      
      if(bee.img){
        const art = document.createElement('div'); 
        art.style.gridColumn='2/3'; 
        art.style.gridRow='1/2'; 
        art.style.display='flex'; 
        art.style.alignItems='flex-start'; 
        art.style.justifyContent='center';
        
        const imgEl = document.createElement('img'); 
        imgEl.src = `images/${bee.img}`; 
        imgEl.style.width='64px'; 
        imgEl.style.height='64px'; 
        imgEl.style.objectFit='contain'; 
        imgEl.style.borderRadius='0px'; 
        imgEl.style.boxShadow=`0 0 12px ${beeColor}88`;
        imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }
      
      const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
      const btn = document.createElement('button'); btn.className='small-btn';
      btn.style.minWidth = '50px';
      
      if(!isOwned){
        btn.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        btn.setAttribute('data-buy-btn', 'true');
        btn.setAttribute('data-price', bee.price);
        btn.setAttribute('data-price-type', bee.priceType || 'honey');
        
        // Check affordability based on price type
        let canAfford = false;
        if(bee.priceType === 'tickets'){
          canAfford = tickets >= bee.price;
        } else {
          canAfford = stats.honey >= bee.price;
        }
        
        if(canAfford){
          btn.classList.add('btn-can-afford');
        } else {
          btn.classList.add('btn-cannot-afford');
          btn.disabled = true;
        }
        
        btn.onclick = () => {
          if(bee.priceType === 'tickets'){
            if(tickets < bee.price) {
              showNotification('No tienes suficientes tickets', 'error');
              return;
            }
            tickets -= bee.price;
          } else {
            if(stats.honey < bee.price) {
              showNotification('No tienes suficiente miel', 'error');
              return;
            }
            stats.honey -= bee.price;
          }
          ownedSpecialBees.push(bee.id);
          discoveredBees.push(bee.id);
          showNotification(`ðŸ Abeja especial desbloqueada: ${bee.name}`, 'success', 5000);
          // Auto-equip if less than 3 are equipped
          if(equippedSpecialBees.length < 3){
            equippedSpecialBees.push(bee.id);
          } else {
            // Replace the oldest one if all 3 slots are full
            equippedSpecialBees.shift();
            equippedSpecialBees.push(bee.id);
          }
          saveGame();
          buildUpgrades();
          buildBeeGrid();
          updateBeeAbilities();
          updateUI();
        };
      } else if(isEquipped){
        btn.textContent = 'âœ“ EQUIPPED';
        btn.classList.add('btn-equipped');
        btn.disabled = true;
      } else {
        btn.textContent = 'SWAP';
        btn.classList.add('btn-purchased');
        btn.onclick = () => {
          if(equippedSpecialBees.length < 3){
            equippedSpecialBees.push(bee.id);
          } else {
            // Replace the oldest one if all 3 slots are full
            equippedSpecialBees.shift();
            equippedSpecialBees.push(bee.id);
          }
          saveGame();
          buildUpgrades();
          buildBeeGrid();
          updateBeeAbilities();
          updateUI();
        };
      }
      
      bottom.appendChild(btn);
      f.appendChild(bottom);
      
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div'); 
      priceEl.className='price-label'; 
      priceEl.style.color=beeColor;
      priceEl.style.fontWeight='bold';
      priceEl.textContent = !isOwned ? (fmt(bee.price) + (bee.priceType === 'tickets' ? ' ðŸŽ«' : ' ðŸ¯')) : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      specialBeesContainer.appendChild(f);
    });
  }
  
  // 2. STAT UPGRADES section
  const statUpgradesContainer = createUpgradeSection('Stat Upgrades', '#f1c40f', [], 'stat_upgrades');
  
  // Add Player Rank first if it exists in TILE_UPGRADES
  if(typeof TILE_UPGRADES !== 'undefined' && Array.isArray(TILE_UPGRADES)){
    const playerRankUpgrade = TILE_UPGRADES.find(u => u.stat === 'playerRank');
    if(playerRankUpgrade){
      const u = playerRankUpgrade;
      const lvl = tileUpgradeLevels[u.id] || 0;
      const f = document.createElement('div');
      f.className = 'upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-upgrade-id', u.id);
      f.setAttribute('data-upgrade-name', u.name);

      const top = document.createElement('div'); top.className = 'upgrade-top';
      
      // Rank name and color based on next level
      const rankColors = {
        1: '#B87333',
        2: '#C0C0C0',
        3: '#FFD700',
        4: '#7EF9FF',
        5: '#FF1493',
        6: '#FF00FF',
        7: '#00FFFF'
      };
      const rankNames = {
        1: 'COPPER',
        2: 'SILVER',
        3: 'GOLDEN',
        4: 'DIAMOND',
        5: 'MYTHIC',
        6: 'CELESTIAL',
        7: 'TRANSCENDENT'
      };
      const nextRankLevel = lvl + 1;
      const rankColor = rankColors[nextRankLevel] || '#888';
      const rankName = rankNames[nextRankLevel] || 'UNKNOWN';
      
      const nameEl = document.createElement('div'); 
      nameEl.style.fontWeight='bold'; 
      nameEl.style.color=rankColor; 
      nameEl.style.fontSize='16px'; 
      nameEl.textContent = `ðŸ‘‘ ${rankName}`;
      top.appendChild(nameEl);
      
      const descEl = document.createElement('div'); 
      descEl.className='upgrade-desc'; 
      descEl.style.fontSize='13px'; 
      descEl.textContent = 'Ascend in rank and unlock powerful bonuses to your gameplay';
      top.appendChild(descEl);
      
      // Show buffs for next level if available
      if(lvl < u.levels.length){
        const L = u.levels[lvl];
        const buffsEl = document.createElement('div');
        buffsEl.style.cssText = 'margin-top:8px;font-size:12px;color:#fff;line-height:1.8;';
        let buffsHTML = `<div style="color:${rankColor};font-weight:bold;margin-bottom:4px;">âœ¨ Bonuses at ${rankName}:</div>`;
        if(L.pollenBonus) buffsHTML += `<div style="color:#90EE90;">â€¢ ðŸŒ¸ Pollen: <span style="color:${rankColor}">+${L.pollenBonus}%</span></div>`;
        if(L.convertBonus) buffsHTML += `<div style="color:#90EE90;">â€¢ ðŸ¯ Convert: <span style="color:${rankColor}">+${L.convertBonus}%</span></div>`;
        if(L.capacityBonus) buffsHTML += `<div style="color:#90EE90;">â€¢ ðŸ“¦ Capacity: <span style="color:${rankColor}">+${fmt(L.capacityBonus)}</span></div>`;
        if(L.criticalChance) buffsHTML += `<div style="color:#90EE90;">â€¢ ðŸ’¥ Crit Chance: <span style="color:${rankColor}">+${L.criticalChance}%</span></div>`;
        if(L.criticalPower) buffsHTML += `<div style="color:#90EE90;">â€¢ âš¡ Crit Power: <span style="color:${rankColor}">+${L.criticalPower.toFixed(1)}</span></div>`;
        if(L.honeyBonus) buffsHTML += `<div style="color:#90EE90;">â€¢ ðŸ¯ Honey: <span style="color:${rankColor}">+${L.honeyBonus}%</span></div>`;
        if(L.fireMultiplier) buffsHTML += `<div style="color:#FF6347;">â€¢ ðŸ”¥ Fire: <span style="color:${rankColor}">x${L.fireMultiplier.toFixed(1)}</span></div>`;
        if(L.darkFireMultiplier) buffsHTML += `<div style="color:#8B0000;">â€¢ ðŸŒ‘ Dark Fire: <span style="color:${rankColor}">x${L.darkFireMultiplier.toFixed(1)}</span></div>`;
        if(L.superCriticalChance) buffsHTML += `<div style="color:#FFD700;">â€¢ ðŸŒŸ Super-Crit: <span style="color:${rankColor}">+${L.superCriticalChance}%</span></div>`;
        if(L.gooMultiplier) buffsHTML += `<div style="color:#00FF00;">â€¢ ðŸ’š Goo: <span style="color:${rankColor}">x${L.gooMultiplier.toFixed(1)}</span></div>`;
        buffsEl.innerHTML = buffsHTML;
        top.appendChild(buffsEl);
      }
      
      f.appendChild(top);

      // Get rank image from level data - show image that matches the displayed rank name
      if(lvl <= u.levels.length){
        const art = document.createElement('div'); 
        art.style.gridColumn='2/3'; 
        art.style.gridRow='1/2'; 
        art.style.display='flex'; 
        art.style.alignItems='flex-start'; 
        art.style.justifyContent='center';
        
        // Get image from level data - match the rank that's displayed in the name
        // nextRankLevel is what's shown in text (lvl + 1)
        // So we need the image for that rank
        const nextRankLevelForImage = lvl + 1;
        const nextLevelData = u.levels[lvl]; // The next rank to unlock has data at current lvl index
        const displayRankColor = rankColors[nextRankLevelForImage] || '#888';
        const displayRankImg = nextLevelData && nextLevelData.img ? nextLevelData.img : 'rank.png';
        
        const imgEl = document.createElement('img'); 
        imgEl.src = `images/${displayRankImg}`; 
        imgEl.style.width='64px'; 
        imgEl.style.height='64px'; 
        imgEl.style.objectFit='contain'; 
        imgEl.style.borderRadius='50%'; 
        imgEl.style.boxShadow=`0 0 20px ${displayRankColor}, inset 0 0 10px ${displayRankColor}66`;
        imgEl.className = 'egg-art';
        imgEl.onerror = function() {
          this.src = 'images/rank.png'; // Fallback si la imagen no existe
        };
        art.appendChild(imgEl);
        f.appendChild(art);
      }

      const btn = document.createElement('button'); btn.className='small-btn';
      btn.style.minWidth = '50px';
      const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
      if(lvl >= u.levels.length){
        btn.textContent = 'MAX';
        btn.classList.add('btn-max-level');
        btn.disabled = true;
      } else {
        const L = u.levels[lvl];
        btn.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        btn.setAttribute('data-buy-btn', 'true');
        btn.setAttribute('data-price', L.price);
        btn.setAttribute('data-price-type', 'honey');
        
        const canAfford = stats.honey >= L.price;
        if(canAfford){
          btn.classList.add('btn-can-afford');
        } else {
          btn.classList.add('btn-cannot-afford');
          btn.disabled = true;
        }
        btn.onclick = ()=>{
          if(stats.honey < L.price) return showNotification('No tienes suficiente miel', 'error');
          stats.honey -= L.price;
          playerRankLevel = (lvl + 1);
          playerRankBuffs = {
            rank: L.rank,
            pollenBonus: L.pollenBonus || 0,
            convertBonus: L.convertBonus || 0,
            capacityBonus: L.capacityBonus || 0,
            criticalChance: L.criticalChance || 0,
            criticalPower: L.criticalPower || 0
          };
          tileUpgradeLevels[u.id] = (tileUpgradeLevels[u.id] || 0) + 1;
          saveGame(); buildUpgrades(); updateUI();
        };
      }
      bottom.appendChild(btn);
      f.appendChild(bottom);
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' ðŸ¯') : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      statUpgradesContainer.appendChild(f);
    }
  }
  
  // Then add regular upgrades
  UPGRADES.forEach(u => {
    const lvl = upgradeLevels[u.id] || 0;
    const f = document.createElement('div');
    f.className = 'upgrade-frame';
    f.setAttribute('data-frame', 'true');
    f.setAttribute('data-upgrade-id', u.id);
    f.setAttribute('data-upgrade-name', u.name);

    const top = document.createElement('div'); top.className = 'upgrade-top';
    const nameEl = document.createElement('div'); nameEl.style.fontWeight='bold'; nameEl.style.color='#f1c40f'; nameEl.style.fontSize='16px'; nameEl.textContent = u.name;
    top.appendChild(nameEl);
    const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.style.fontSize='13px'; descEl.textContent = u.description || 'No description available';
    top.appendChild(descEl);
    const levelEl = document.createElement('div'); levelEl.className='upgrade-desc'; levelEl.style.color='#aef1c4'; levelEl.style.marginTop='4px'; levelEl.textContent = u.levels && u.levels[lvl] ? `Next: ${u.levels[lvl].percent?`+${u.levels[lvl].percent}%`:(u.levels[lvl].amount?`+${u.levels[lvl].amount}`:'+0')}` : 'MAX';
    top.appendChild(levelEl);
    f.appendChild(top);

    if(u.img){
      const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
      const imgEl = document.createElement('img'); imgEl.src = `images/${u.img}`; imgEl.style.width='64px'; imgEl.style.height='64px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='0px'; imgEl.className = 'egg-art';
      art.appendChild(imgEl);
      if(u.name && (/legend|mythic|myth/i).test(u.name)){
        createParticles(art, /myth/i.test(u.name) ? '#9b59b6' : '#f1c40f', 6);
      }
      f.appendChild(art);
    }

    const btn = document.createElement('button'); btn.className='small-btn';
    btn.style.minWidth = '50px';
    const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
    if(lvl >= u.levels.length){
      btn.textContent = 'MAX';
      btn.classList.add('btn-max-level');
      btn.disabled = true;
    } else {
      const L = u.levels[lvl];
      btn.textContent = 'BUY';
      const canAfford = stats.honey >= L.price;
      if(canAfford){
        btn.classList.add('btn-can-afford');
      } else {
        btn.classList.add('btn-cannot-afford');
        btn.disabled = true;
      }
      // Agregar atributos para actualizaciÃ³n en tiempo real
      btn.setAttribute('data-buy-btn', 'true');
      btn.setAttribute('data-price', L.price);
      btn.setAttribute('data-price-type', 'honey');
      
      btn.onclick = ()=>{
        if(stats.honey < L.price) return; stats.honey -= L.price;
        if(u.stat === 'backpack'){
          stats[u.stat] += (L.amount||0);
          stats.pollenCapacity += (L.amount||0);
        } else if(u.stat === 'criticalPower'){
          stats[u.stat] += (L.percent||0);
        } else if(u.stat === 'maxSlots'){
          maxSlots += (L.amount||0);
        } else {
          stats[u.stat] += (L.percent||0);
        }
        upgradeLevels[u.id] = (upgradeLevels[u.id] || 0) + 1;
        saveGame(); buildUpgrades(); updateUI();
      };
    }
    bottom.appendChild(btn);
    f.appendChild(bottom);
    const priceWrap = document.createElement('div');
    priceWrap.className = 'upgrade-price-wrap';
    const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' ðŸ¯') : '';
    priceWrap.appendChild(priceEl);
    f.appendChild(priceWrap);
    statUpgradesContainer.appendChild(f);
  });
  
  // 3. POLLEN COLOR section
  if(typeof POLLEN_COLOR_UPGRADES !== 'undefined' && POLLEN_COLOR_UPGRADES.length > 0){
    const pollenContainer = createUpgradeSection('Pollen Color', '#ff69b4', [], 'pollen_color');
    POLLEN_COLOR_UPGRADES.forEach(u=>{
      const lvl = upgradeLevels[u.id] || 0;
      const f = document.createElement('div');
      f.className = 'upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-upgrade-id', u.id);
      f.setAttribute('data-upgrade-name', u.name);

      const top = document.createElement('div'); top.className = 'upgrade-top';
      const nameEl = document.createElement('div'); nameEl.style.fontWeight='bold'; nameEl.style.color='#ff69b4'; nameEl.style.fontSize='16px'; nameEl.textContent = u.name;
      top.appendChild(nameEl);
      const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.style.fontSize='13px'; descEl.textContent = u.description || 'No description available';
      top.appendChild(descEl);
      
      // Show current multiplier value
      const currentMultEl = document.createElement('div'); 
      currentMultEl.className='upgrade-desc'; 
      currentMultEl.style.color='#FFD700'; 
      currentMultEl.style.marginTop='4px'; 
      currentMultEl.style.fontWeight='bold';
      if(lvl > 0){
        let currentMult = 1.0;
        for(let i = 0; i < lvl; i++){
          if(u.levels[i]){
            const percentBonus = u.levels[i].percent || 0;
            currentMult *= (1 + percentBonus / 100);
          }
        }
        currentMultEl.textContent = `Current: x${currentMult.toFixed(3)}`;
      } else {
        currentMultEl.textContent = 'Current: x1.000';
      }
      top.appendChild(currentMultEl);
      
      const levelEl = document.createElement('div'); levelEl.className='upgrade-desc'; levelEl.style.color='#aef1c4'; levelEl.style.marginTop='4px'; levelEl.textContent = u.levels && u.levels[lvl] ? `Next: x${((1 + (u.levels[lvl].percent||0)/100)).toFixed(3)}` : 'MAX';
      top.appendChild(levelEl);
      f.appendChild(top);

      if(u.img){
        const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
        const imgEl = document.createElement('img'); imgEl.src = `images/${u.img}`; imgEl.style.width='64px'; imgEl.style.height='64px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='0px'; imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }

      const btn = document.createElement('button'); btn.className='small-btn';
      btn.style.minWidth = '50px';
      const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
      if(lvl >= u.levels.length){
        btn.textContent = 'MAX'; btn.disabled = true;
      } else {
        const L = u.levels[lvl];
        btn.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        btn.setAttribute('data-buy-btn', 'true');
        btn.setAttribute('data-price', L.price);
        btn.setAttribute('data-price-type', 'honey');
        
        const canAfford = stats.honey >= L.price;
        if(canAfford){
          btn.classList.add('btn-can-afford');
        } else {
          btn.classList.add('btn-cannot-afford');
          btn.disabled = true;
        }
        
        btn.onclick = ()=>{
          if(stats.honey < L.price) return; stats.honey -= L.price;
          if(u.stat === 'maxSlots'){
            maxSlots += (L.amount||0);
          } else {
            stats[u.stat] += (L.percent||0);
          }
          upgradeLevels[u.id] = (upgradeLevels[u.id] || 0) + 1;
          saveGame(); buildUpgrades(); updateUI();
        };
      }
      bottom.appendChild(btn);
      f.appendChild(bottom);
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' ðŸ¯') : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      pollenContainer.appendChild(f);
    });
  }
  
  // 4. TILE UPGRADES section
  if(typeof TILE_UPGRADES !== 'undefined' && Array.isArray(TILE_UPGRADES) && TILE_UPGRADES.length > 0){
    const tileContainer = createUpgradeSection('Tile Upgrades', '#00CED1', [], 'tile_upgrades');
    TILE_UPGRADES.filter(u => u.stat !== 'playerRank').forEach(u => {
      const lvl = tileUpgradeLevels[u.id] || 0;
      const f = document.createElement('div');
      f.className = 'upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-upgrade-id', u.id);
      f.setAttribute('data-upgrade-name', u.name);

      const top = document.createElement('div');
      top.className = 'upgrade-top';
      const nameEl = document.createElement('div');
      nameEl.style.fontWeight = 'bold';
      nameEl.style.color = '#00CED1';
      nameEl.style.fontSize = '16px';
      nameEl.textContent = u.name;
      top.appendChild(nameEl);
      
      const descEl = document.createElement('div');
      descEl.className = 'upgrade-desc';
      descEl.style.fontSize = '13px';
      descEl.textContent = u.description || 'No description available';
      top.appendChild(descEl);
      
      // Show current bonus value
      const currentBonusEl = document.createElement('div');
      currentBonusEl.className = 'upgrade-desc';
      currentBonusEl.style.color = '#FFD700';
      currentBonusEl.style.marginTop = '4px';
      currentBonusEl.style.fontWeight = 'bold';
      if(lvl > 0){
        let totalBonus = 0;
        for(let i = 0; i < lvl; i++){
          totalBonus += (u.levels[i].percent || u.levels[i].amount || 0);
        }
        currentBonusEl.textContent = `Current: +${totalBonus}${u.levels[0].percent ? '%' : u.levels[0].amount ? '' : ''}`;
      } else {
        currentBonusEl.textContent = 'Current: +0';
      }
      top.appendChild(currentBonusEl);
      
      const levelEl = document.createElement('div');
      levelEl.className = 'upgrade-desc';
      levelEl.style.color = '#aef1c4';
      levelEl.style.marginTop = '4px';
      levelEl.textContent = u.levels && u.levels[lvl] ? `Next: ${u.levels[lvl].percent?`+${u.levels[lvl].percent}%`:(u.levels[lvl].amount?`+${u.levels[lvl].amount}`:'+0')}` : 'MAX';
      top.appendChild(levelEl);
      f.appendChild(top);

      if(u.img){
        const art = document.createElement('div');
        art.style.gridColumn = '2/3';
        art.style.gridRow = '1/2';
        art.style.display = 'flex';
        art.style.alignItems = 'flex-start';
        art.style.justifyContent = 'center';
        const imgEl = document.createElement('img');
        imgEl.src = `images/${u.img}`;
        imgEl.style.width = '64px';
        imgEl.style.height = '64px';
        imgEl.style.objectFit = 'contain';
        imgEl.style.borderRadius = '6px';
        imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }

      const btn = document.createElement('button');
      btn.className = 'small-btn';
      btn.style.minWidth = '50px';
      const bottom = document.createElement('div');
      bottom.className = 'upgrade-bottom';
      if(lvl >= u.levels.length){
        btn.textContent = 'MAX';
        btn.disabled = true;
      } else {
        const L = u.levels[lvl];
        btn.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        btn.setAttribute('data-buy-btn', 'true');
        btn.setAttribute('data-price', L.price);
        btn.setAttribute('data-price-type', 'honey');
        
        const canAfford = stats.honey >= L.price;
        if(canAfford){
          btn.classList.add('btn-can-afford');
        } else {
          btn.classList.add('btn-cannot-afford');
          btn.disabled = true;
        }
        
        btn.onclick = ()=>{
          if(stats.honey < L.price) return showNotification('No tienes suficiente miel', 'error');
          stats.honey -= L.price;
          if(u.stat === 'gridSize'){
            gridSize = L.amount || gridSize;
          } else {
            stats[u.stat] = (stats[u.stat] || 0) + (L.amount || 0);
          }
          tileUpgradeLevels[u.id] = (tileUpgradeLevels[u.id] || 0) + 1;
          saveGame(); buildUpgrades(); updateUI();
        };
      }
      bottom.appendChild(btn);
      f.appendChild(bottom);
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div');
      priceEl.className = 'price-label';
      priceEl.textContent = lvl < u.levels.length ? (fmt(u.levels[lvl].price) + ' ðŸ¯') : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      tileContainer.appendChild(f);
    });
  }
  
  // 5. PLAYER GOODS section
  if(typeof PLAYER_GOODS !== 'undefined' && PLAYER_GOODS.length > 0){
    const goodsContainer = createUpgradeSection('Player Goods', '#FFD700', [], 'player_goods');
    PLAYER_GOODS.forEach(good => {
      const isOwned = ownedPlayerGoods && ownedPlayerGoods.includes(good.id);
      const f = document.createElement('div');
      f.className = 'upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-good-id', good.id);
      f.setAttribute('data-good-name', good.name);
      
      const top = document.createElement('div'); top.className = 'upgrade-top';
      const nameEl = document.createElement('div'); nameEl.style.fontWeight='bold'; nameEl.style.color='#FFD700'; nameEl.style.fontSize='16px'; nameEl.textContent = good.name;
      top.appendChild(nameEl);
      const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.style.fontSize='13px'; descEl.textContent = good.description || good.desc || 'Player good';
      top.appendChild(descEl);
      f.appendChild(top);
      
      if(good.img){
        const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
        const imgEl = document.createElement('img'); imgEl.src = `images/${good.img}`; imgEl.style.width='64px'; imgEl.style.height='64px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='6px'; imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }
      
      const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
      const btn = document.createElement('button'); btn.className='small-btn';
      btn.style.minWidth = '50px';
      if(isOwned){
        btn.textContent = 'OWNED'; btn.disabled = true;
      } else {
        btn.textContent = 'BUY';
        btn.onclick = () => showNotification('Player good - coming soon', 'info');
      }
      bottom.appendChild(btn);
      f.appendChild(bottom);
      
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = !isOwned ? (fmt(good.price || 0) + ' ðŸ¯') : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      goodsContainer.appendChild(f);
    });
  }
}

/* ================= BEES CATALOG ================= */
function buildBeesCatalog(){
  const beesEl = document.getElementById("bees");
  beesEl.innerHTML = "";
  
  // Count discovered bees (distinct bee IDs)
  const totalCount = BEES.length + SPECIAL_BEES.length;
  
  // Add counter at the top with ID for dynamic updates
  const counterDiv = document.createElement('div');
  counterDiv.id = 'beeCounterDiv';
  counterDiv.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:14px;margin-bottom:12px;padding:8px;background:#262626;border-radius:0px;text-align:center;';
  updateBeeCounter(counterDiv);
  beesEl.appendChild(counterDiv);
  
  // Add search input
  createSearchInput(beesEl, ['data-bee-name']);
  
  // Group bees by rarity
  const rarities = ['common', 'rare', 'epic', 'legendary', 'mythic', 'ultimate'];
  const beesByRarity = {};
  rarities.forEach(r => beesByRarity[r] = []);
  
  BEES.forEach(bee => {
    if(beesByRarity[bee.rarity]) beesByRarity[bee.rarity].push(bee);
  });
  
  // Add special bees to the catalog
  if(SPECIAL_BEES && SPECIAL_BEES.length > 0){
    beesByRarity['special'] = SPECIAL_BEES;
    rarities.push('special');
  }
  
  // Create sections for each rarity
  
  const categoryState = getCategoryState('bees');
  
  rarities.forEach(rarity => {
    const bees = beesByRarity[rarity];
    if(bees.length === 0) return;
    
    // Count discovered bees in this rarity
    const discoveredCount = bees.filter(b => discoveredBees.includes(b.id)).length;
    const totalCount = bees.length;
    const isComplete = discoveredCount === totalCount;
    
    // Rarity title with counter
    const titleContainer = document.createElement('div');
    titleContainer.className = 'rarity-title-container';
    
    // Define color and glow based on rarity
    const rarityColors = {
      'common': '#CD7F32',
      'rare': '#C0C0C0',
      'epic': '#FFD700',
      'legendary': '#00D9FF',
      'mythic': '#9b59b6',
      'ultimate': '#FF00FF',
      'special': '#1CFF7C'
    };
    const glowMap = {
      'mythic': 'rgba(155, 89, 182, 0.8)',
      'ultimate': '0 0 20px rgba(255, 0, 255, 0.8), 0 0 40px rgba(255, 20, 147, 0.6)',
      'special': 'rgba(28, 255, 124, 0.8)'
    };
    const titleColor = rarityColors[rarity] || '#f1c40f';
    const glowStyle = glowMap[rarity] ? (rarity === 'ultimate' ? `text-shadow: ${glowMap[rarity]}` : `text-shadow: 0 0 12px ${glowMap[rarity]}, 0 0 20px ${glowMap[rarity]}`) : '';
    
    const titleDiv = document.createElement('div');
    titleDiv.style.cssText = `color:${titleColor};font-weight:bold;font-size:18px;text-transform:uppercase;display:flex;gap:10px;align-items:center;${glowStyle}`;
    
    const rarityLabel = document.createElement('span');
    rarityLabel.textContent = rarity;
    
    // Add rainbow animation for ultimate rarity title
    if(rarity === 'ultimate') {
      rarityLabel.className = 'rarity-ultimate-title';
    }
    
    const counterText = document.createElement('span');
    counterText.style.cssText = 'color:#ccc;font-size:14px;font-weight:normal;';
    counterText.textContent = `${discoveredCount}/${totalCount}`;
    
    titleDiv.appendChild(rarityLabel);
    titleDiv.appendChild(counterText);
    
    // Add toggle button for rarity category
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'rarity-toggle-btn';
    toggleBtn.textContent = 'â–¼';
    toggleBtn.setAttribute('data-rarity', rarity);
    toggleBtn.style.marginLeft = 'auto';
    
    titleContainer.appendChild(titleDiv);
    titleContainer.appendChild(toggleBtn);
    beesEl.appendChild(titleContainer);
    
    // Create container for frames with rarity identifier
    const framesContainer = document.createElement('div');
    framesContainer.className = 'rarity-frames-container';
    framesContainer.setAttribute('data-rarity-container', rarity);
    
    // Check if this rarity was previously collapsed
    if(categoryState.collapsed[rarity]){
      framesContainer.style.display = 'none';
      toggleBtn.classList.add('collapsed');
      toggleBtn.textContent = 'â–¶';
    }
    
    // Attach toggle functionality
    toggleBtn.onclick = (e) => {
      e.stopPropagation();
      toggleCategoryVisibility(toggleBtn, framesContainer, 'bees', rarity);
    };
    
    beesEl.appendChild(framesContainer);
    
    // Bees in this rarity
    bees.forEach(bee => {
      const isDiscovered = discoveredBees.includes(bee.id);
      const countEquipped = equippedBees.filter(b => b === bee.id).length;
      
      const frame = document.createElement('div');
      frame.className = 'bee-catalog-frame';
      frame.setAttribute('data-frame', 'true');
      frame.setAttribute('data-bee-id', bee.id);
      frame.setAttribute('data-bee-name', bee.name);
      
      // Apply color background based on colorType
      let backgroundColor = '#333';
      let colorAnimation = '';
      if(bee.colorType === 'red'){
        backgroundColor = 'rgba(255, 69, 0, 0.3)';
      } else if(bee.colorType === 'blue'){
        backgroundColor = 'rgba(65, 105, 225, 0.3)';
      } else if(bee.colorType === 'yellow'){
        backgroundColor = 'rgba(255, 215, 0, 0.3)';
      } else if(bee.colorType === 'purple'){
        backgroundColor = 'rgba(157, 78, 221, 0.3)';
      } else if(bee.colorType === 'white'){
        backgroundColor = 'rgba(255, 215, 0, 0.2)';
      }
      
      frame.id = `frame-${bee.id}`;
      frame.className = 'bee-catalog-frame';
      frame.style.background = backgroundColor;
      frame.style.opacity = isDiscovered ? '0.85' : '0.3';
      frame.style.cursor = 'pointer';
      // Border color based on rarity
      const rarityBorderColors = {common:'#FFD700',rare:'#cecece',epic:'#fde723',legendary:'#00eeff',mythic:'#9b59b6',ultimate:'#FF00FF',special:'#4CAF50'};
      const catalogBorderColor = rarityBorderColors[bee.rarity] || bee.color;
      frame.style.border = `1px solid ${catalogBorderColor}`;
      // Add glow for mythic, ultimate and legendary
      if(bee.rarity === 'mythic'){
        frame.classList.add('catalog-mythic-bee');
      } else if(bee.rarity === 'ultimate'){
        frame.classList.add('catalog-ultimate-bee');
      } else if(bee.rarity === 'legendary'){
        frame.classList.add('catalog-legendary-bee');
      }
      
      // Add bee color type indicator
      const colorTypeLabel = bee.colorType === 'red' ? '' : bee.colorType === 'blue' ? '' : bee.colorType === 'yellow' ? '' : bee.colorType === 'purple' ? '' : '';
      const rarityLabel = rarity.toUpperCase();
      
      // Prepare color display label
      let colorDisplayLabel = bee.colorType === 'red' ? 'RED' : bee.colorType === 'blue' ? 'BLUE' : bee.colorType === 'yellow' ? 'YELLOW' : bee.colorType === 'purple' ? 'PURPLE' : 'COLORLESS';
      
      // Determine color for rarity/type text based on bee color type
      let colorTextColor = '#ddd'; // default
      if(bee.colorType === 'red') colorTextColor = '#FF4500';
      else if(bee.colorType === 'blue') colorTextColor = '#4169E1';
      else if(bee.colorType === 'yellow') colorTextColor = '#FFD700';
      else if(bee.colorType === 'purple') colorTextColor = '#9D4EDD';
      else if(bee.colorType === 'colorless') colorTextColor = '#ffffff';
      
      // Create color cycling style if mixed for the catalog
      const colorCycleStyleCatalog = '';
      
      // Get frame color and glow styles based on rarity
      const getRarityFrameColor = () => {
        switch(bee.rarity){
          case 'common': return '#CD7F32'; // Copper
          case 'rare': return '#C0C0C0'; // Silver
          case 'epic': return '#FFD700'; // Gold
          case 'legendary': return '#00D9FF'; // Diamond
          case 'mythic': return '#9b59b6'; // Purple
          case 'special': return '#1CFF7C'; // Emerald
          default: return '#999';
        }
      };
      
      const frameBorderColor = getRarityFrameColor();
      const frameGlowColor = bee.rarity === 'legendary' ? 'rgba(0,217,255,0.6)' : 
                             bee.rarity === 'mythic' ? 'rgba(155,89,182,0.6)' : 
                             bee.rarity === 'special' ? 'rgba(28,255,124,0.6)' : 
                             bee.rarity === 'ultimate' ? 'rgba(255,0,255,0.8)' : 'none';
      const frameBorderWidth = (bee.rarity === 'mythic' || bee.rarity === 'special' || bee.rarity === 'ultimate') ? '3px' : '2px';
      
      // Add glow animation styles for legendary, mythic, special, and ultimate
      const imgGlowStyle = (bee.rarity === 'legendary' || bee.rarity === 'mythic' || bee.rarity === 'special' || bee.rarity === 'ultimate') ? `<style id="img-glow-${bee.id}">
        #bee-catalog-img-${bee.id} {
          ${bee.rarity === 'ultimate' ? `animation: rainbow-border 5s linear infinite;` : `animation: bee-catalog-glow-${bee.id} 2.5s ease-in-out infinite;`}
        }
        ${bee.rarity === 'ultimate' ? '' : `@keyframes bee-catalog-glow-${bee.id} {
          0% { box-shadow: 0 0 12px ${frameGlowColor}, inset 0 0 10px ${frameGlowColor}; }
          50% { box-shadow: 0 0 20px ${frameGlowColor}, inset 0 0 10px ${frameGlowColor}; }
          100% { box-shadow: 0 0 12px ${frameGlowColor}, inset 0 0 10px ${frameGlowColor}; }
        }`}
      </style>` : '';
      
      // Generate tier stars
      const tierStars = () => {
        if(!bee.tier) return '';
        let html = '<div style="margin-top:4px;font-size:15px;letter-spacing:2px;">';
        for(let i = 1; i <= 5; i++){
          const isActive = i <= bee.tier;
          const starColor = isActive ? (i < bee.tier ? '#f1c40f' : '#FF69B4') : '#555';
          html += `<span style="color:${starColor};text-shadow:0 0 2px ${starColor}">â˜…</span>`;
        }
        html += '</div>';
        return html;
      };
      
      // Count how many of this bee the user owns
      const hiveCount = rarity === 'special' ? null : ownedBees.filter(b => b === bee.id).length;
      
      // Get color claro and oscuro based on colorType
      const getColorClaro = (colorType) => {
        switch(colorType) {
          case 'red': return 'rgba(255, 107, 107, 0.2)'; // Light red
          case 'blue': return 'rgba(100, 149, 237, 0.2)'; // Light blue
          case 'yellow': return 'rgba(255, 235, 59, 0.2)'; // Light yellow
          case 'purple': return 'rgba(186, 85, 211, 0.2)'; // Light purple
          case 'white': return 'rgba(220, 220, 220, 0.2)'; // Light white
          default: return 'rgba(200, 200, 200, 0.2)';
        }
      };
      
      const getColorOscuro = (colorType) => {
        switch(colorType) {
          case 'red': return '#AA2222'; // Dark red
          case 'blue': return '#1a3a7a'; // Dark blue
          case 'yellow': return '#8B8B00'; // Dark yellow
          case 'purple': return '#4a1a6a'; // Dark purple
          case 'white': return '#555555'; // Dark gray
          default: return '#444444';
        }
      };
      
      const colorClaro = getColorClaro(bee.colorType);
      const colorOscuro = getColorOscuro(bee.colorType);
      
      // Get name color and stroke based on rarity
      const getNameColor = (rarity) => {
        switch(rarity) {
          case 'common': return '#CD7F32';
          case 'rare': return '#C0C0C0';
          case 'epic': return '#FFD700';
          case 'legendary': return '#00D9FF';
          case 'mythic': return '#9b59b6';
          case 'ultimate': return '#FF00FF';
          case 'special': return '#1CFF7C';
          default: return '#ffffff';
        }
      };
      
      const nameColor = getNameColor(bee.rarity);
      
      frame.innerHTML = `
        ${colorCycleStyleCatalog}
        ${imgGlowStyle}
        <div style="display:flex;flex-direction:column;gap:6px;align-items:center;flex-shrink:0;">
          <div style="position:relative;">
            <img id="bee-catalog-img-${bee.id}" src="images/${bee.img}" style="width:90px;height:90px;object-fit:cover;border-radius:0px;${!isDiscovered ? 'filter:grayscale(100%);' : ''};border:${frameBorderWidth} solid ${frameBorderColor};${frameGlowColor !== 'none' ? `box-shadow:0 0 12px ${frameGlowColor}, inset 0 0 10px ${frameGlowColor}` : ''};background:${colorClaro};">
          </div>
          <div style="background:${colorOscuro};color:#fff;padding:4px 10px;border-radius:0px;font-size:10px;font-weight:bold;width:90px;text-align:center;border:1px solid ${colorOscuro};">${isDiscovered ? colorDisplayLabel : '???'}</div>
        </div>
        <div style="flex:1;min-width:0;position:relative;display:flex;flex-direction:column;justify-content:flex-start;padding-top:4px;">
          ${hiveCount !== null ? `<div style="position:absolute;top:0;right:0;color:#FFD700;font-size:12px;font-weight:bold;">${hiveCount}</div>` : ''}
          <div style="font-weight:bold;color:${nameColor};font-size:22px;white-space:normal;overflow:visible;text-overflow:clip;text-shadow:none;line-height:1.2;">${isDiscovered ? bee.name : '???'}</div>
          ${isDiscovered ? `<div style="font-size:12px;color:#AAA;margin-top:2px;line-height:1.4">${bee.desc ? bee.desc.substring(0, 70) + (bee.desc.length > 70 ? '...' : '') : ''}</div>` : ''}
          ${isDiscovered ? tierStars() : ''}
        </div>
      `;
      
      if(isDiscovered){
        frame.onmouseenter = () => { frame.style.opacity = '1'; frame.style.boxShadow = `0 0 12px ${bee.color}`; };
        frame.onmouseleave = () => { frame.style.opacity = '0.85'; frame.style.boxShadow = 'none'; };
      }
      frame.onclick = () => showBeeDetails(bee);
      
      framesContainer.appendChild(frame);
    });
  });
}

function updateBeeCounter(el){
  const discoveredCount = discoveredBees.length;
  const totalCount = BEES.length + SPECIAL_BEES.length;
  el.textContent = `${discoveredCount}/${totalCount} Bees Discovered`;
}

function showBeeDetails(bee){
  // Close existing modal
  const existing = document.getElementById('beeDetailsModal');
  if(existing) existing.remove();
  
  // Create modal
  const modal = document.createElement('div');
  modal.id = 'beeDetailsModal';
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;justify-content:flex-end;align-items:flex-start;z-index:3000;padding-top:60px;padding-right:20px;';
  
  const panel = document.createElement('div');
  panel.className = 'bee-details-panel' + (bee.rarity === 'ultimate' ? ' ultimate-bee' : '');
  
  // Get frame style based on bee color - sin transparencia
  let panelStyle = `background:${bee.color}cc;border-radius:0px;padding:16px;max-width:400px;box-shadow:0 10px 30px rgba(0,0,0,0.8);`;
  
  // Add rarity-based border and glow
  const getRarityBorder = () => {
    switch(bee.rarity){
      case 'common': return 'border:2px solid #CD7F32;';
      case 'rare': return 'border:2px solid #C0C0C0;box-shadow:0 0 12px rgba(192, 192, 192, 0.5);';
      case 'epic': return 'border:2px solid #FFD700;box-shadow:0 0 12px rgba(255, 215, 0, 0.6);';
      case 'legendary': return 'border:2px solid #00D9FF;box-shadow:0 0 15px rgba(0, 217, 255, 0.8);';
      case 'mythic': return 'border:2px solid #9b59b6;box-shadow:0 0 12px rgba(155, 89, 182, 0.6);';
      case 'ultimate': return 'border:3px solid #FF00FF;box-shadow:0 0 20px rgba(255, 0, 255, 0.8);';
      case 'special': return 'border:2px solid #1CFF7C;box-shadow:0 0 12px rgba(28, 255, 124, 0.6);';
      default: return 'border:2px solid #999;';
    }
  };
  
  panelStyle += getRarityBorder();
  
  panel.style.cssText = panelStyle;
  
  // Get synergies that include this bee
  const activeSynergies = SYNERGIES.filter(s => s.requirement.includes(bee.id));
  
  // Get color type label (uppercase)
  const colorTypeEmoji = bee.colorType === 'red' ? '' : bee.colorType === 'blue' ? '' : bee.colorType === 'yellow' ? '' : bee.colorType === 'purple' ? '' : '';
  const colorTypeLabel = bee.colorType === 'red' ? 'RED' : bee.colorType === 'blue' ? 'BLUE' : bee.colorType === 'yellow' ? 'YELLOW' : bee.colorType === 'purple' ? 'PURPLE' : 'COLORLESS';
  
  // Prepare color for text display
  let colorTextStyle = '';
  let colorTypeDisplay = colorTypeLabel;
  // Use bee color or default
  const displayColor = bee.colorType === 'red' ? '#FF4500' : bee.colorType === 'blue' ? '#4169E1' : bee.colorType === 'yellow' ? '#FFD700' : bee.colorType === 'purple' ? '#9D4EDD' : '#FFD700';
  colorTextStyle = `color:${displayColor};`;
  
  // Check if it's a special bee
  const isSpecialBee = bee.rarity === 'special';
  const isOwned = isSpecialBee ? ownedSpecialBees.includes(bee.id) : discoveredBees.includes(bee.id);
  const isEquipped = isSpecialBee ? equippedSpecialBees === bee.id : false;
  
  // Create color cycling style if mixed
  const colorCycleStyle = '';
  
  panel.innerHTML = `
    <!-- HEADER: Imagen y Nombre -->
    <div style="text-align:center;margin-bottom:16px;padding-bottom:12px;border-bottom:2px solid rgba(255,255,255,0.3);">
      <img src="images/${bee.img}" style="width:90px;height:90px;object-fit:cover;border-radius:0px;margin-bottom:10px;${
        (() => {
          const theme = RARITY_THEMES[bee.rarity];
          if(!theme || theme.frameSize === 0) return '';
          let style = `border:${theme.frameSize}px solid ${theme.frameBorderColor};`;
          if(bee.rarity === 'ultimate') {
            style += `animation:${theme.frameAnimation};`;
          } else if(theme.frameGlow && theme.frameGlow !== 'none') {
            style += `box-shadow:${theme.frameGlow};`;
          }
          return style;
        })()
      }${!isOwned ? 'filter:grayscale(100%);' : ''}">
      <div style="color:#fff;font-weight:bold;font-size:18px;text-shadow:2px 2px 4px rgba(0,0,0,0.7);margin-bottom:4px">${isOwned ? bee.name : '???'}</div>
      <div style="display:flex;justify-content:center;gap:12px;margin-bottom:6px;">
        <div style="background:rgba(255,255,255,0.2);padding:4px 10px;border-radius:0px;font-size:11px;text-transform:uppercase;font-weight:bold;color:#fff">${isOwned ? bee.rarity.toUpperCase() : '?'}</div>
        <div style="background:rgba(255,255,255,0.2);padding:4px 10px;border-radius:0px;font-size:11px;font-weight:bold;color:#fff">${colorTypeDisplay}</div>
      </div>
      ${isOwned && bee.tier ? `<div style="font-size:14px;letter-spacing:3px;margin-top:4px;">
        ${Array.from({length:5}).map((_, i) => {
          const isActive = i < bee.tier;
          const isLast = i === bee.tier - 1;
          const starColor = isActive ? (isLast ? '#FF69B4' : '#f1c40f') : '#666';
          return `<span style="color:${starColor};text-shadow:0 0 3px ${starColor};animation:starGrow 0.6s ease-in-out ${i*0.1}s both">â˜…</span>`;
        }).join('')}
      </div>` : ''}
    </div>

    <!-- SCROLL AREA -->
    <div class="bee-details-scroll" style="max-height:400px;overflow-y:auto;">
      
      <!-- DESCRIPTION -->
      <div style="margin-bottom:12px;">
        <div style="font-size:12px;font-weight:bold;color:#fff;margin-bottom:6px;text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.3);padding-bottom:4px;">Description</div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:0px;color:#fff;font-size:12px;line-height:1.5;border-left:3px solid #fff">
          ${bee.desc || 'No description available'}
        </div>
      </div>

      <!-- ABILITY NAME & DETAILS -->
      ${bee.ability && bee.ability !== 'ninguno' ? `
      <div style="margin-bottom:12px;">
        <div style="font-size:12px;font-weight:bold;color:#fff;margin-bottom:6px;text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.3);padding-bottom:4px;">Special Ability</div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:0px;border-left:3px solid #FFD700;margin-bottom:6px">
          <div style="color:#FFD700;font-weight:bold;font-size:13px;margin-bottom:4px">${bee.ability}</div>
          <div style="color:#fff;font-size:11px;line-height:1.4">
            ${bee.abilityDetails ? bee.abilityDetails : 'Special ability effect'}
          </div>
        </div>
      </div>
      ` : ''}

      <!-- CURRENT STATS -->
      ${isOwned ? (() => {
        const buffs = getBeeBuffs(bee.id);
        
        // Organize stats into categories
        const improves = [];
        const field = [];
        const capacity = [];
        const other = [];
        
        if (buffs.pollenBonus) improves.push({label: 'Pollen Bonus', value: `+${buffs.pollenBonus}%`});
        if (buffs.convertBonus) improves.push({label: 'Convert Rate', value: `+${buffs.convertBonus}%`});
        if (buffs.instantConversion) improves.push({label: 'Instant Conversion', value: `+${buffs.instantConversion}%`});
        if (buffs.criticalChance) improves.push({label: 'Critical Chance', value: `+${buffs.criticalChance}%`});
        if (buffs.criticalPower) improves.push({label: 'Critical Power', value: `+${(buffs.criticalPower * 100).toFixed(0)}%`});
        if (buffs.superCriticalChance) improves.push({label: 'Super Critical', value: `+${buffs.superCriticalChance}%`});
        if (buffs.honeyBonus) improves.push({label: 'Honey Bonus', value: `+${buffs.honeyBonus}%`});
        if (buffs.beePollenBonus) improves.push({label: 'Bee Pollen', value: `+${buffs.beePollenBonus}%`});
        if (buffs.beeConvertBonus) improves.push({label: 'Bee Convert', value: `+${buffs.beeConvertBonus}%`});
        if (buffs.beeCriticalChance) improves.push({label: 'Bee Crit Chance', value: `+${buffs.beeCriticalChance}%`});
        if (buffs.beeCriticalPower) improves.push({label: 'Bee Crit Power', value: `+${(buffs.beeCriticalPower * 100).toFixed(0)}%`});
        if (buffs.beeInstantConversion) improves.push({label: 'Bee Instant Conv', value: `+${buffs.beeInstantConversion}%`});
        if (buffs.beeHoneyBonus) improves.push({label: 'Bee Honey', value: `+${buffs.beeHoneyBonus}%`});
        
        if (buffs.fireMultiplier && buffs.fireMultiplier !== 1) field.push({label: 'Fire Boost', value: `x${buffs.fireMultiplier.toFixed(2)}`});
        if (buffs.darkFireMultiplier && buffs.darkFireMultiplier !== 1) field.push({label: 'Dark Fire', value: `x${buffs.darkFireMultiplier.toFixed(2)}`});
        if (buffs.gooMultiplier && buffs.gooMultiplier !== 1) field.push({label: 'Goo Multiplier', value: `x${buffs.gooMultiplier.toFixed(2)}`});
        if (buffs.bubbleMultiplier && buffs.bubbleMultiplier !== 1) field.push({label: 'Bubble Boost', value: `x${buffs.bubbleMultiplier.toFixed(2)}`});
        if (buffs.gooPollenCollected) field.push({label: 'Goo Pollen', value: `${buffs.gooPollenCollected.toLocaleString()}`});
        if (buffs.colorMultipliers) {
          Object.entries(buffs.colorMultipliers).forEach(([color, mult]) => {
            field.push({label: `${color.charAt(0).toUpperCase() + color.slice(1)} Pollen`, value: `x${mult.toFixed(2)}`});
          });
        }
        
        if (buffs.capacityBonus) capacity.push({label: 'Capacity', value: `+${buffs.capacityBonus.toLocaleString()}`});
        if (buffs.backpackBonus) capacity.push({label: 'Backpack', value: `+${buffs.backpackBonus.toLocaleString()}`});
        if (buffs.toolCooldownReduction) capacity.push({label: 'Tool Cooldown', value: `-${(buffs.toolCooldownReduction * 100).toFixed(0)}%`});
        
        const hasAnyStats = improves.length > 0 || field.length > 0 || capacity.length > 0;
        
        return hasAnyStats ? `
        <div style="margin-bottom:12px;">
          <div style="font-size:12px;font-weight:bold;color:#fff;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.3);padding-bottom:4px;">CURRENT STATS</div>
          
          ${improves.length > 0 ? `
          <div style="margin-bottom:10px;">
            <div style="font-size:11px;color:#ccc;font-weight:bold;margin-bottom:4px;">IMPROVES</div>
            <div style="background:rgba(0,0,0,0.4);padding:8px;border-radius:0px;border-left:3px solid #FFD700;">
              ${improves.map(({label, value}) => `<div style="color:#fff;font-size:11px;margin-bottom:2px;line-height:1.3;"><span style="color:#ccc">${label}:</span> <span style="color:#FFD700;font-weight:bold">${value}</span></div>`).join('')}
            </div>
          </div>
          ` : ''}
          
          ${field.length > 0 ? `
          <div style="margin-bottom:10px;">
            <div style="font-size:11px;color:#ccc;font-weight:bold;margin-bottom:4px;">FIELD</div>
            <div style="background:rgba(0,0,0,0.4);padding:8px;border-radius:0px;border-left:3px solid #00D9FF;">
              ${field.map(({label, value}) => `<div style="color:#fff;font-size:11px;margin-bottom:2px;line-height:1.3;"><span style="color:#ccc">${label}:</span> <span style="color:#00D9FF;font-weight:bold">${value}</span></div>`).join('')}
            </div>
          </div>
          ` : ''}
          
          ${capacity.length > 0 ? `
          <div style="margin-bottom:10px;">
            <div style="font-size:11px;color:#ccc;font-weight:bold;margin-bottom:4px;">CAPACITY</div>
            <div style="background:rgba(0,0,0,0.4);padding:8px;border-radius:0px;border-left:3px solid #4CAF50;">
              ${capacity.map(({label, value}) => `<div style="color:#fff;font-size:11px;margin-bottom:2px;line-height:1.3;"><div style="color:#ccc">${label}:</div> <span style="color:#4CAF50;font-weight:bold">${value}</span></div>`).join('')}
            </div>
          </div>
          ` : ''}
        </div>
        ` : '';
      })() : ''}

      <!-- IMPROVES BEES -->
      ${isSpecialBee && bee.bonusMultipliers && Object.keys(bee.bonusMultipliers).length > 0 ? `
      <div style="margin-bottom:12px;">
        <div style="font-size:12px;font-weight:bold;color:#fff;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.3);padding-bottom:4px;">Improves Bees</div>
        ${Object.entries(bee.bonusMultipliers).map(([beeId, mult]) => {
          const targetBee = BEES.find(b => b.id === beeId);
          const bonusPercent = ((mult - 1) * 100).toFixed(0);
          return `
            <div style="background:rgba(52,152,219,0.2);padding:8px;border-radius:0px;border-left:2px solid #2196F3;margin-bottom:6px;color:#fff;font-size:11px">
              <div style="font-weight:bold;color:#87CEEB">${targetBee?.name || beeId}</div>
              <div>Bonus: +${bonusPercent}%</div>
            </div>
          `;
        }).join('')}
      </div>
      ` : ''}

      <!-- SYNERGIES -->
      ${activeSynergies.length > 0 ? `
      <div style="margin-bottom:0;">
        <div style="font-size:12px;font-weight:bold;color:#fff;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.3);padding-bottom:4px;">Synergies</div>
        ${activeSynergies.map(s => `
          <div style="background:rgba(255,193,7,0.15);padding:10px;border-radius:0px;border-left:2px solid #FFD700;margin-bottom:8px">
            <div style="font-weight:bold;color:#FFD700;margin-bottom:4px;font-size:12px">${s.name}</div>
            <div style="color:#fff;font-size:11px;line-height:1.5;">
              ${Object.entries(s.bonus).map(([k,v]) => {
                const label = k.replace(/([A-Z])/g,' $1').trim();
                const val = (k.includes('chance') || k.includes('power')) ? `${v}` : `${v}%`;
                return `<div style="margin-bottom:2px">â€¢ ${label}: <span style="color:#FFD700;font-weight:bold">${val}</span></div>`;
              }).join('')}
            </div>
          </div>
        `).join('')}
      </div>
      ` : ''}

    </div>
  `;
  
  modal.appendChild(panel);
  
  // Add star particle effect on the last star
  if(bee.tier && isOwned) {
    setTimeout(() => {
      const lastStar = panel.querySelector('[style*="FF69B4"]');
      if(lastStar) {
        lastStar.addEventListener('mouseenter', () => {
          for(let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            const angle = (i / 8) * Math.PI * 2;
            const distance = 15 + Math.random() * 20;
            const x = Math.cos(angle) * distance;
            const y = -Math.abs(Math.sin(angle) * distance) - (40 + Math.random() * 30);
            
            particle.style.position = 'absolute';
            particle.style.left = lastStar.offsetLeft + 'px';
            particle.style.top = lastStar.offsetTop + 'px';
            particle.style.pointerEvents = 'none';
            particle.style.fontSize = '12px';
            particle.style.color = '#FF69B4';
            particle.innerHTML = 'âœ¨';
            particle.style.setProperty('--px', x + 'px');
            particle.style.setProperty('--py', y + 'px');
            particle.style.animation = `starParticle 1.2s ease-out forwards`;
            particle.style.textShadow = '0 0 8px #FF69B4';
            panel.appendChild(particle);
            
            setTimeout(() => particle.remove(), 1200);
          }
        });
      }
    }, 10);
  }
  
  // Close on click outside
  modal.onclick = (e) => {
    if(e.target === modal) modal.remove();
  };
  
  document.body.appendChild(modal);
}

function buildEggs(){
  const eggsEl = document.getElementById("eggs");
  eggsEl.innerHTML="";
  // Render egg shop cards instead of individual bees
  EGGS.forEach(egg => {
    const f = document.createElement("div");
    f.className = "egg-frame";
    // frame style (color or gradient)
    const rarityColor = {
      'egg_silver': '#C0C0C0',
      'egg_golden': '#FFD700',
      'egg_diamond': '#00D9FF',
      'egg_mythic': '#9b59b6'
    }[egg.id] || '#888';
    
    f.style.cssText = `background:linear-gradient(135deg, ${rarityColor}20 0%, ${rarityColor}10 100%);border-left:6px solid ${rarityColor};padding:12px;border-radius:0px;margin-bottom:8px;box-shadow:0 0 8px ${rarityColor}44;`;

    f.innerHTML = `
      <div style="display:flex;gap:12px;align-items:flex-start;">
        <div class="egg-art" style="width:80px;height:80px;flex-shrink:0;"><img src="images/${egg.img}" style="width:100%;height:100%;object-fit:contain;border-radius:0px;"/></div>
        <div style="flex:1;">
          <b style="font-size:16px;color:${rarityColor}">${egg.name}</b>
          <div style="font-size:12px;margin-top:6px;color:#aaa;"></div>
        </div>
      </div>
    `;
    // ensure mythic glow / particles and egg-art class are applied
    const artEl = f.querySelector('.egg-art');
    if(egg.id === 'egg_mythic') f.classList.add('mythic-egg');
    if(artEl){
      const artImg = artEl.querySelector('img');
      if(artImg) artImg.classList.add('egg-art');
      // add particles with color per egg rarity/type
      if(egg.probs){
        let col = null;
        if(egg.id === 'egg_golden') col = '#ffd700';
        else if(egg.id === 'egg_diamond') col = '#4fc3f7';
        else if(egg.id === 'egg_mythic') col = '#9b59b6';
        else if(egg.id === 'egg_silver') col = '#c0c0c0';
        // if egg has legendary/mythic chances, add particles
        if(col && (egg.probs.legendary > 0 || egg.probs.mythic > 0 || egg.id === 'egg_golden' || egg.id === 'egg_diamond')){
          createParticles(artEl, col, 8);
        }
      }
    }
    const probList = document.createElement('ul');
    probList.className = 'prob-list';
    probList.style.fontSize = '14px';
    ['common','rare','epic','legendary','mythic','ultimate'].forEach(r=>{
      const li = document.createElement('li');
      const rarityPercent = egg.probs[r] || 0;
      
      // Rainbow animation for ultimate
      if(r === 'ultimate'){
        li.style.cssText = 'animation: rainbow-text 4s linear infinite; font-weight: bold;';
      }
      
      li.textContent = `${r.charAt(0).toUpperCase()+r.slice(1)}: ${rarityPercent}%`;
      probList.appendChild(li);
    });
    f.appendChild(probList);

    // no color/gradient controls (removed)

    const btn = document.createElement("button");
    btn.className = 'small-btn';
    btn.style.minWidth = '50px';
    const getPrice = () => eggPrices[egg.id] || egg.price;
    btn.textContent = `BUY`;
    
    // Determine if player can afford the egg
    const priceNow = getPrice();
    const canAfford = stats.honey >= priceNow;
    if(canAfford){
      btn.classList.add('btn-can-afford');
    } else {
      btn.classList.add('btn-cannot-afford');
      btn.disabled = true;
    }
    
    btn.onclick = () => {
      const priceNow = getPrice();
      if(stats.honey < priceNow){ showNotification('No tienes suficiente miel', 'error'); return; }
      if(equippedBees.length >= maxSlots){ showNotification(`Tienes el nÃºmero mÃ¡ximo de abejas equipadas (${maxSlots}). Compra mÃ¡s slots en la tienda.`, 'warning'); return; }
      stats.honey -= priceNow;
      // hatch
      const hatchedBeeId = hatchBeeFromEgg(egg);
      if(hatchedBeeId){
        ownedBees.push(hatchedBeeId);
        const bee = BEES.find(b => b.id === hatchedBeeId);
        
        // Always show notification with egg name and bee details
        if(bee) {
          showNotification(`${egg.name}: ${bee.name} - ${bee.rarity}!`, 'success', 7000);
        }
        
        // Add to discovered bees if not already discovered
        if(!discoveredBees.includes(hatchedBeeId)){
          discoveredBees.push(hatchedBeeId);
          if(bee) {
            showNotification(`You have just discovered for the first time the ${bee.name}, ${bee.rarity}!`, 'success', 5000);
          }
        }
        equipBee(hatchedBeeId);
      }
      // increase price by egg.mult and cap
      const mult = egg.mult || 1.5;
      const cap = egg.cap || Infinity;
      const newPrice = Math.min(Math.ceil(priceNow * mult), cap);
      eggPrices[egg.id] = newPrice;
      // refresh UI & save - call buildBeeGrid AFTER buildEggs to ensure bee grid updates last
      buildEggs();
      updateUI();
      saveGame();
      buildBeeGrid(); // MUST be called last to ensure hive panel displays correctly
    };

    // f.appendChild(colorWrap);
    const priceWrap = document.createElement('div');
    priceWrap.style.display='flex';
    priceWrap.style.justifyContent='space-between';
    priceWrap.style.marginTop='8px';
    priceWrap.appendChild(btn);
    const priceLabel = document.createElement('div');
    priceLabel.style.alignSelf='center';
    priceLabel.style.paddingLeft='8px';
    priceLabel.className = 'price-label';
    priceLabel.textContent = fmt(getPrice()) + ' ðŸ¯';
    priceWrap.appendChild(priceLabel);
    f.appendChild(priceWrap);

    eggsEl.appendChild(f);
  });

  // synergies are shown in player stats panel now
}

function buildSynergiesDisplay(){
  // kept for backward compatibility but not used; synergies are displayed in stats panel
}

// Hatch logic: pick a bee id based on egg probabilities
function hatchBeeFromEgg(egg){
  // build cumulative distribution of rarities
  const probs = egg.probs;
  const entries = ['common','rare','epic','legendary','mythic','ultimate'];
  const rank = {common:0, rare:1, epic:2, legendary:3, mythic:4, ultimate:5};
  // enforce upgraded eggs which guarantee higher rarities
  let minRank = 0;
  if(egg.id === 'egg_silver') minRank = 1; // superior a common -> at least rare
  else if(egg.id === 'egg_golden') minRank = 2; // superior a epic -> at least legendary
  
  else if(egg.id === 'egg_diamond') minRank = 3; // superior a epic -> at least legendary
  else if(egg.id === 'egg_mythic') minRank = 4; // mythic only or ultimate with 0.1% chance

  // Build filtered list of entries taking into account minRank
  const filtered = entries.filter(e => rank[e] >= minRank && (probs[e]||0) > 0);
  const useEntries = (filtered.length > 0) ? filtered : entries.slice();

  const total = useEntries.reduce((s,k)=>s+(probs[k]||0),0);
  if(total <= 0) return null;
  let r = Math.random()*total;
  let chosenRarity = useEntries[0];
  for(const k of useEntries){
    r -= (probs[k]||0);
    if(r <= 0){ chosenRarity = k; break; }
  }

  // Filter BEES by chosenRarity, fallback to broader pools if empty
  let pool = BEES.filter(b=>b.rarity === chosenRarity);
  if(pool.length === 0 && rank[chosenRarity] < 5){
    // try to find any with higher rarities
    pool = BEES.filter(b => rank[b.rarity] >= rank[chosenRarity]);
  }
  const pickPool = pool.length ? pool : BEES;
  const chosen = pickPool[Math.floor(Math.random()*pickPool.length)];
  return chosen ? chosen.id : null;
}

/* ================= SHOP ================= */
function openShop(id){
document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
document.getElementById(id).classList.add("active");
if(id === "tools") buildTools();
if(id === "bees") buildBeesCatalog();
if(id === "eggs") buildEggs();
if(id === "storage") buildStorage();
// Save current section to save file
currentSection = id;
}

// highlight active shop tab
function highlightShopTab(id){
  document.querySelectorAll('.shop-tabs button').forEach(b=>b.classList.remove('active-tab'));
  const btn = Array.from(document.querySelectorAll('.shop-tabs button')).find(b=>b.getAttribute('onclick') && b.getAttribute('onclick').includes(`openShop('${id}')`));
  if(btn) btn.classList.add('active-tab');
}

// wrap openShop to also highlight tab
const _openShop = openShop;
openShop = function(id){ _openShop(id); highlightShopTab(id); };

// STORAGE array loaded from configs/storage.js
// buildStorage() uses the STORAGE constant

function buildStorage(){
  const storageEl = document.getElementById('storage');
  storageEl.innerHTML = '';
  
  // Add category title
  const categoryTitle = document.createElement('div');
  categoryTitle.style.cssText = 'color:#f1c40f;font-weight:bold;font-size:18px;margin:0 0 12px 0;text-transform:uppercase;padding-bottom:8px;border-bottom:2px solid #444;';
  categoryTitle.textContent = 'Storage';
  storageEl.appendChild(categoryTitle);
  
  // Add search input
  createSearchInput(storageEl, ['data-storage-name']);
  
  // Rarity order and colors
  const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'mythic', 'ultimate'];
  const rarityColors = {
    'common': '#CD7F32',
    'rare': '#C0C0C0',
    'epic': '#FFD700',
    'legendary': '#00D9FF',
    'mythic': '#9b59b6',
    'ultimate': '#ff0000'
  };
  
  // Group storage by rarity
  const storageByRarity = {};
  rarityOrder.forEach(r => {
    storageByRarity[r] = STORAGE.filter(s => s.rarity === r);
    // Sort storage within each rarity by price (ascending - cheapest first)
    storageByRarity[r].sort((a, b) => {
      return (a.price || 0) - (b.price || 0);
    });
  });
  
  // Render each rarity category
  const storageCategoryState = getCategoryState('storage');
  
  rarityOrder.forEach(rarity => {
    const storageInRarity = storageByRarity[rarity];
    if(storageInRarity.length === 0) return;
    
    // Add rarity header with toggle
    const { container: headerContainer, button: toggleBtn } = createCategoryHeader(
      rarity.charAt(0).toUpperCase() + rarity.slice(1) + ' Storage',
      rarity,
      rarityColors
    );
    storageEl.appendChild(headerContainer);
    
    // Create container for this rarity's items
    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'rarity-frames-container';
    itemsContainer.setAttribute('data-rarity-container', rarity);
    
    // Check if this rarity was previously collapsed
    if(storageCategoryState.collapsed[rarity]){
      itemsContainer.style.display = 'none';
      toggleBtn.classList.add('collapsed');
      toggleBtn.textContent = 'â–¶';
    }
    
    // Attach toggle functionality
    toggleBtn.onclick = (e) => {
      e.stopPropagation();
      toggleCategoryVisibility(toggleBtn, itemsContainer, 'storage', rarity);
    };
    
    storageEl.appendChild(itemsContainer);
    
    // Render storage in this rarity
    storageInRarity.forEach(s=>{
      const f = document.createElement('div'); f.className='upgrade-frame';
      f.setAttribute('data-frame', 'true');
      f.setAttribute('data-storage-id', s.id);
      f.setAttribute('data-storage-name', s.name);
      f.setAttribute('data-rarity', s.rarity);
      const top = document.createElement('div'); top.className='upgrade-top';
      const nameEl = document.createElement('div'); 
      nameEl.style.fontWeight='bold'; 
      nameEl.style.color = rarityColors[s.rarity] || '#f1c40f';
      nameEl.style.fontSize='16px'; 
      if(s.rarity === 'ultimate') nameEl.className = 'ultimate-name';
      else if(s.rarity === 'mythic') nameEl.style.textShadow = '0 0 12px rgba(155, 89, 182, 0.8), 0 0 20px rgba(155, 89, 182, 0.8)';
      else if(s.rarity === 'legendary') nameEl.style.textShadow = `0 0 8px ${rarityColors[s.rarity]}`;
      nameEl.textContent = s.name;
      const descEl = document.createElement('div'); descEl.className='upgrade-desc'; descEl.style.fontSize='13px'; descEl.textContent = s.desc;
      top.appendChild(nameEl); 
      top.appendChild(descEl);
      
      // Add ability/feature info
      if(s.ability){
        const abilityEl = document.createElement('div');
        abilityEl.className='upgrade-desc';
        abilityEl.style.color='#FFD700';
        abilityEl.style.marginTop='4px';
        abilityEl.style.fontWeight='bold';
        abilityEl.innerHTML = ` 
        <div style="margin-bottom:2px">
          
          * ABILITY:</div><div style="color:#AEF1C4;font-weight:normal;font-size:12px">${s.ability}</div>`;
        top.appendChild(abilityEl);
      }
      
      // Add capacity info
      const capacityEl = document.createElement('div'); 
      capacityEl.className='upgrade-desc'; 
      capacityEl.style.color='#FFD700';
      capacityEl.style.marginTop='4px';
      capacityEl.textContent = `Capacity: +${fmt(s.bonuses.pollenCapacity)}`;
      top.appendChild(capacityEl);
      
      // Add bonuses info if any
      if(s.bonuses && Object.keys(s.bonuses).length > 1){
        const bonusesEl = document.createElement('div');
        bonusesEl.className='upgrade-desc';
        bonusesEl.style.color='#aef1c4';
        bonusesEl.style.marginTop='4px';
        const bonusTexts = [];
        if(s.bonuses.pollenBonus) bonusTexts.push(`Pollen Bonus: +${s.bonuses.pollenBonus}%`);
        if(s.bonuses.convertBonus) bonusTexts.push(`Convert Bonus: +${s.bonuses.convertBonus}%`);
        bonusesEl.textContent = bonusTexts.join(', ');
        if(bonusTexts.length > 0) top.appendChild(bonusesEl);
      }
      
      f.appendChild(top);
      // top-right storage image (animated like egg)
      if(s.img){
        const art = document.createElement('div'); art.style.gridColumn='2/3'; art.style.gridRow='1/2'; art.style.display='flex'; art.style.alignItems='flex-start'; art.style.justifyContent='center';
        const imgEl = document.createElement('img'); imgEl.src = `images/${s.img}`; imgEl.style.width='64px'; imgEl.style.height='64px'; imgEl.style.objectFit='contain'; imgEl.style.borderRadius='6px'; imgEl.className = 'egg-art';
        art.appendChild(imgEl);
        f.appendChild(art);
      }

      const bottom = document.createElement('div'); bottom.className='upgrade-bottom';
      const b = document.createElement('button'); b.className='small-btn';
      b.style.minWidth = '50px';
      const owned = ownedStorages.includes(s.id);
      const equipped = (equippedStorageId === s.id);
      if(!owned){
        b.textContent = 'BUY';
        // Agregar atributos para actualizaciÃ³n en tiempo real
        b.setAttribute('data-buy-btn', 'true');
        b.setAttribute('data-price', s.price);
        b.setAttribute('data-price-type', 'honey');
        
        const canAfford = stats.honey >= s.price;
        if(canAfford){
          b.classList.add('btn-can-afford');
        } else {
          b.classList.add('btn-cannot-afford');
          b.disabled = true;
        }
        b.onclick = ()=>{
          if(stats.honey < s.price) return showNotification('No tienes suficiente miel', 'error');
          stats.honey -= s.price; ownedStorages.push(s.id); saveGame(); buildStorage(); updateUI();
        };
      } else if(!equipped){
        b.textContent = 'EQUIP';
        b.classList.add('btn-purchased');
        b.onclick = ()=>{ equipStorage(s.id); };
      } else {
        b.textContent = 'EQUIPPED';
        b.classList.add('btn-equipped');
        b.disabled = true;
      }
      bottom.appendChild(b);
      f.appendChild(bottom);
      
      const priceWrap = document.createElement('div');
      priceWrap.className = 'upgrade-price-wrap';
      const priceEl = document.createElement('div'); priceEl.className='price-label'; priceEl.textContent = !owned ? (fmt(s.price) + ' ðŸ¯') : '';
      priceWrap.appendChild(priceEl);
      f.appendChild(priceWrap);
      
      itemsContainer.appendChild(f);
    });
  });
}

function equipStorage(id){
  // remove previous storage bonuses
  const prev = STORAGE.find(s=>s.id===equippedStorageId);
  if(prev && prev.bonuses){
    for(const [k,v] of Object.entries(prev.bonuses)){
      stats[k] = (stats[k] || 0) - v;
    }
  }
  equippedStorageId = id;
  const s = STORAGE.find(x=>x.id===id);
  if(s && s.bonuses){
    for(const [k,v] of Object.entries(s.bonuses)){
      stats[k] = (stats[k] || 0) + v;
    }
    showNotification(`Storage equipado: ${s.name}`, 'success');
  }
  saveGame();
  buildStorage();
  updateUI();
}

/* ================= INIT ================= */

// VerificaciÃ³n pre-init para diagnosticar problemas de config
window.configLoadStatus = {
  bees: typeof BEES !== 'undefined',
  storage: typeof STORAGE !== 'undefined',
  fields: typeof fields !== 'undefined',
  tools: typeof TOOLS !== 'undefined',
  upgrades: typeof UPGRADES !== 'undefined',
  playerStats: typeof PLAYER_STATS !== 'undefined',
  tileBuffs: typeof TILE_BUFFS !== 'undefined',
  rarities: typeof RARITY_CONFIG !== 'undefined'
};

console.log('ðŸ“‹ Config Load Status:', window.configLoadStatus);
const configsOk = Object.values(window.configLoadStatus).every(v => v === true);
if(!configsOk) {
  console.error('âŒ ALGUNOS CONFIGS NO CARGARON:');
  Object.entries(window.configLoadStatus).forEach(([k, v]) => {
    console.log(`  ${v ? 'âœ…' : 'âŒ'} ${k}`);
  });
}

// CRÃTICO: Inicializar upgradeLevels desde los configs ANTES de usarlos
function initializeUpgradesFromConfig() {
  try {
    console.log('ðŸ”„ Inicializando upgrades desde config...');
    
    // Verificar que los configs existan
    if(typeof UPGRADES === 'undefined') {
      console.error('âŒ UPGRADES config no cargÃ³!');
      console.log('Variables disponibles:', {
        UPGRADES: typeof UPGRADES,
        POLLEN_COLOR_UPGRADES: typeof POLLEN_COLOR_UPGRADES,
        TILE_UPGRADES: typeof TILE_UPGRADES
      });
      return false;
    }
    
    // Reinicializar upgradeLevels desde los configs
    upgradeLevels = {};
    
    // Inicializar desde UPGRADES
    if(Array.isArray(UPGRADES)) {
      UPGRADES.forEach(u => {
        if(!upgradeLevels.hasOwnProperty(u.id)) {
          upgradeLevels[u.id] = 0;
        }
      });
      console.log(`âœ… ${UPGRADES.length} stat upgrades registrados`);
    }
    
    // Inicializar desde POLLEN_COLOR_UPGRADES
    if(typeof POLLEN_COLOR_UPGRADES !== 'undefined' && Array.isArray(POLLEN_COLOR_UPGRADES)) {
      POLLEN_COLOR_UPGRADES.forEach(u => {
        if(!upgradeLevels.hasOwnProperty(u.id)) {
          upgradeLevels[u.id] = 0;
        }
      });
      console.log(`âœ… ${POLLEN_COLOR_UPGRADES.length} pollen color upgrades registrados`);
    }
    
    // Inicializar tileUpgradeLevels
    tileUpgradeLevels = {};
    if(typeof TILE_UPGRADES !== 'undefined' && Array.isArray(TILE_UPGRADES)) {
      TILE_UPGRADES.forEach(t => {
        if(!tileUpgradeLevels.hasOwnProperty(t.id)) {
          tileUpgradeLevels[t.id] = 0;
        }
      });
      console.log(`âœ… ${TILE_UPGRADES.length} tile upgrades registrados`);
    }
    
    console.log('ðŸ“Š upgradeLevels:', Object.keys(upgradeLevels).length, 'upgrades');
    console.log('ðŸ“Š tileUpgradeLevels:', Object.keys(tileUpgradeLevels).length, 'tile upgrades');
    
    return true;
  } catch(e) {
    console.error('âŒ ERROR en initializeUpgradesFromConfig:', e);
    console.error('Stack:', e.stack);
    return false;
  }
}

// Ejecutar inicializaciÃ³n
try {
  const initOk = initializeUpgradesFromConfig();
  if(!initOk) {
    console.warn('âš ï¸ ADVERTENCIA: upgradeLevels podrÃ­a no estar completamente inicializado');
    console.log('Continuando de todas formas...');
  }
} catch(e) {
  console.error('âŒ ERROR CRÃTICO durante inicializaciÃ³n:', e);
  console.log('Continuando sin alerts bloqueantes...');
}

try {
  loadGame();
} catch(e) {
  console.error('âŒ ERROR en loadGame():', e);
}

try {
  recalculateAllBuffs(); // Initialize buff tracking after loading
} catch(e) {
  console.error('âŒ ERROR en recalculateAllBuffs():', e);
}

try {
  buildFieldList();
} catch(e) {
  console.error('âŒ ERROR en buildFieldList():', e);
}

try {
  buildGrid();
} catch(e) {
  console.error('âŒ ERROR en buildGrid():', e);
}

try {
  buildUpgrades();
} catch(e) {
  console.error('âŒ ERROR en buildUpgrades():', e);
}

try {
  updateUI();
} catch(e) {
  console.error('âŒ ERROR en updateUI():', e);
}

try {
  buildTools();
} catch(e) {
  console.error('âŒ ERROR en buildTools():', e);
}
// Toggle button for field list (overlay)
const _toggleBtn = document.getElementById('toggleFieldListBtn');
if(_toggleBtn){
  _toggleBtn.onclick = ()=>{
    const panel = document.getElementById('fieldList');
    if(panel) panel.classList.toggle('open');
  };
}

// Convert button: hold to convert pollen -> honey at 20x speed
const _convertBtn = document.getElementById('convertBtn');
let _convertInterval = null;
let _convertParticleInterval = null;

function spawnHoneyDrop(){
  if(!_convertBtn) return;
  const r = _convertBtn.getBoundingClientRect();
  const x = r.left + r.width * (0.3 + Math.random()*0.4);
  const y = r.top + r.height - 6;
  const drop = document.createElement('div');
  drop.className = 'honey-drop';
  drop.style.left = (x) + 'px';
  drop.style.top = (y) + 'px';
  document.body.appendChild(drop);
  setTimeout(()=>{ try{ drop.remove(); }catch(e){} }, 900);
}
function doConvertTick(mult=20, tickMs=200){
  const totalConvertBonus = stats.convertBonus + stats.beeConvertBonus;
  // Base: 1 honey per 1 pollen/sec
  // For every +50% conversion, add +10 to the conversion amount
  // Example: 100% conversion = 1 + (100/50)*10 = 1 + 20 = 21 honey per pollen
  const bonusStacks = Math.floor(totalConvertBonus / 50);
  const baseConversionRate = 1 + (bonusStacks * 10);
  const amount = Math.min(stats.pollen, baseConversionRate * mult * (tickMs/1000));
  if(amount <= 0) return;
  stats.pollen -= amount;
  const honeyGain = amount;
  stats.honey += honeyGain;
  stats.totalHoney += honeyGain;
  honeyThisSec = honeyGain;
  pollenThisSec = 0;
  
  updateUI();
}
function startConvertHold(){ if(_convertInterval) return; _convertBtn.classList.add('convert-active'); _convertInterval = setInterval(()=>doConvertTick(20,200),200); _convertParticleInterval = setInterval(spawnHoneyDrop, 160); }
function stopConvertHold(){ if(!_convertInterval) return; clearInterval(_convertInterval); _convertInterval = null; if(_convertParticleInterval){ clearInterval(_convertParticleInterval); _convertParticleInterval = null; } _convertBtn.classList.remove('convert-active'); saveGame(); }
if(_convertBtn){
  _convertBtn.addEventListener('pointerdown',(e)=>{ e.preventDefault(); startConvertHold(); });
  window.addEventListener('pointerup',()=>{ stopConvertHold(); });
  _convertBtn.addEventListener('pointerleave',()=>{ stopConvertHold(); });
  // touch fallback
  _convertBtn.addEventListener('touchstart',(e)=>{ e.preventDefault(); startConvertHold(); });
  _convertBtn.addEventListener('touchend',()=>{ stopConvertHold(); });
  window.addEventListener('blur',()=>{ stopConvertHold(); });
}

// click outside to close field list overlay
document.addEventListener('click', (e)=>{
  const panel = document.getElementById('fieldList');
  if(!panel) return;
  if(!panel.classList.contains('open')) return;
  const target = e.target;
  if(panel.contains(target)) return;
  if(_toggleBtn && _toggleBtn.contains(target)) return;
  panel.classList.remove('open');
});

buildBeeGrid();

// Developer command para probar destrucciÃ³n de tiles
window.testDestroyTile = function(index = 0) {
  console.log(`ðŸ§ª TEST: Destroying tile ${index}`);
  if (!fieldData[currentField]) {
    console.error("âŒ fieldData[currentField] does not exist!");
    return;
  }
  const tile = fieldData[currentField][index];
  console.log(`Tile ${index} before:`, tile);
  
  // Manually set to empty
  fieldData[currentField][index] = {c: "", ty: 0, transparent: true};
  
  // Get DOM element
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl.querySelector(`[data-idx="${index}"]`);
  if (tileEl) {
    // Re-render it
    renderTile(tileEl, fieldData[currentField][index]);
    // Fade it out
    tileEl.style.transition = "opacity 0.4s";
    tileEl.style.opacity = "0";
    console.log(`âœ… Tile ${index} destroyed and rendered`);
    
    // Regenerate after 2 seconds
    setTimeout(() => {
      fieldData[currentField][index] = createTile(currentField);
      renderTile(tileEl, fieldData[currentField][index]);
      tileEl.style.opacity = "1";
      console.log(`âœ… Tile ${index} regenerated:`, fieldData[currentField][index]);
    }, 2000);
  } else {
    console.error(`âŒ Tile element not found in DOM for index ${index}`);
    console.log("Available tiles:", gridEl.querySelectorAll('[data-idx]').length);
  }
  updateUI();
};

// Quick test: destroy first 5 tiles
window.testAll = function() {
  for(let i = 0; i < 5; i++) {
    setTimeout(() => testDestroyTile(i), i * 500);
  }
};

// Developer command para aÃ±adir honey
window.addHoney = function(amount = 1000) {
  stats.honey += amount;
  stats.totalHoney += amount;
  saveGame();
  updateUI();
  console.log(`âœ“ AÃ±adidas ${amount} miel. Total: ${stats.honey}`);
};

// Test new buff effects
window.testCrimsonBuff = function(tileIndex = 0) {
  if(!fieldData[currentField] || !fieldData[currentField][tileIndex]) {
    console.error('âŒ Tile not found');
    return;
  }
  
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl?.querySelector(`[data-idx="${tileIndex}"]`);
  
  crimsonTilesActive[tileIndex] = { createdAt: Date.now() };
  if(tileEl) {
    tileEl.classList.add("crimson-effect");
    console.log(`âœ“ Crimson buff aplicado a tile ${tileIndex} - DurarÃ¡ 30 segundos`);
  }
};

window.testEnhancedGooBuff = function(tileIndex = 0) {
  if(!fieldData[currentField] || !fieldData[currentField][tileIndex]) {
    console.error('âŒ Tile not found');
    return;
  }
  
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl?.querySelector(`[data-idx="${tileIndex}"]`);
  
  enhancedGooTiles[tileIndex] = { createdAt: Date.now() };
  if(tileEl) {
    tileEl.classList.add("enhanced-goo-effect");
    console.log(`âœ“ Enhanced Goo buff aplicado a tile ${tileIndex} - DurarÃ¡ 30 segundos`);
  }
};

window.testCriticalErrorBuff = function(tileIndex = 0) {
  if(!fieldData[currentField] || !fieldData[currentField][tileIndex]) {
    console.error('âŒ Tile not found');
    return;
  }
  
  const gridEl = document.getElementById("grid");
  const tileEl = gridEl?.querySelector(`[data-idx="${tileIndex}"]`);
  
  criticalErrorTiles[tileIndex] = { createdAt: Date.now() };
  if(tileEl) {
    tileEl.classList.add("critical-error-effect");
    console.log(`âœ“ Critical Error buff aplicado a tile ${tileIndex} - Se destruirÃ¡ en 10 segundos`);
  }
};

// Developer command para testear habilidades
window.testAbilities = function() {
  console.log('=== ABILITY TEST ===');
  console.log(`Grandmaster tiles: ${grandmasterTilesDestroyed}/200, Active: ${grandmasterActive}`);
  console.log(`Porcelain Dipper tiles: ${porcelainTilesDestroyed}/100, Buff: ${porcelainBuffActive}`);
  console.log(`Coconut Bag pollen: ${coconutBagPollenStored}/1000000, Buff: ${coconutBagBuffActive}`);
};

// Manually test Grandmaster effect
window.testGrandmaster = function() {
  activateGrandmasterEffect();
  console.log('âœ“ Grandmaster effect activated for 30s');
};

// Manually test Porcelain Dipper
window.testDipper = function() {
  applyPorcelainDipperBuff();
  console.log('âœ“ Dipper buff activated for 60s');
};

// Manually test Coconut Bag
window.testCoconut = function() {
  applyCoconutBagBuff();
  console.log('âœ“ Coconut buff activated for 30s');
};

// Developer command para aÃ±adir miel

// Developer command para descubrir todas las bees
window.discoverAllBees = function() {
  const totalBees = BEES.length + SPECIAL_BEES.length;
  
  // Descubrir todas las bees regulares
  BEES.forEach(bee => {
    if(!discoveredBees.includes(bee.id)) {
      discoveredBees.push(bee.id);
    }
  });
  
  // Descubrir todas las special bees
  SPECIAL_BEES.forEach(bee => {
    if(!discoveredBees.includes(bee.id)) {
      discoveredBees.push(bee.id);
    }
  });
  
  saveGame();
  updateUI();
  buildBeeGrid();
  console.log(`âœ“ Descubiertas todas las ${totalBees} bees`);
};

// Developer command para poner todos los precios a 1
window.setPricesTo1 = function() {
  // Poner precios de huevos a 1
  EGGS.forEach(egg => {
    egg.price = 1;
  });
  
  // Poner precios de herramientas a 1
  TOOLS.forEach(tool => {
    tool.price = 1;
  });
  
  // Poner precios de upgrades a 1
  UPGRADES.forEach(upgrade => {
    if(upgrade.levels) {
      upgrade.levels.forEach(level => {
        level.price = 1;
      });
    }
  });
  
  // Poner precios de special bees a 1
  SPECIAL_BEES.forEach(bee => {
    bee.price = 1;
  });
  
  updateUI();
  buildShop();
  console.log('âœ“ Â¡Todos los precios estÃ¡n ahora en 1!');
};

// Developer command para borrar todos los datos del jugador
window.resetAllData = function() {
  if(confirm('âš ï¸ Â¿EstÃ¡s seguro de que quieres borrar TODOS los datos? Esta acciÃ³n no se puede deshacer.')) {
    // Limpiar localStorage
    localStorage.removeItem(SAVE_KEY);
    
    // Resetear todas las variables globales
    stats = {
      pollen:0,
      honey:0,
      totalHoney:0,
      pollenCapacity:120,
      pollenBonus:0,
      convertBonus:0,
      cooldown:2000,
      redBonus:0,
      blueBonus:0,
      whiteBonus:0,
      yellowBonus:0,
      purpleBonus:0,
      redTotal:0,
      blueTotal:0,
      whiteTotal:0,
      yellowTotal:0,
      purpleTotal:0,
      backpack:0,
      criticalPower:2,
      criticalChance:5,
      instantConversion:20,
      beePollenBonus:0,
      beeConvertBonus:0,
      beeCriticalChance:0,
      beeCriticalPower:0,
      beeInstantConversion:0,
      beeHoneyBonus:0,
      beeCapacityBonus:0,
      superCriticalChance:3,
      gooPollenCollected:0,
      gooMultiplier:1,
      fireMultiplier:2,
      darkFireMultiplier:7
    };
    
    upgradeLevels = {};
    currentField = 'dandelion';
    fieldData = {};
    playTime = 0;
    equippedTool = null;
    equippedToolId = 'shovel';
    ownedTools = ['shovel'];
    ownedBees = [];
    equippedBees = [];
    discoveredBees = [];
    ownedSpecialBees = [];
    equippedSpecialBees = [];
    maxEquippedBeesEver = 0;
    maxSlots = 5;
    eggPrices = {};
    ownedStorages = [];
    equippedStorageId = null;
    fieldStats = {};
    claimedRewards = [];
    bouyanbeeStackCount = 0;
    bouyanbeeMultiplier = 1.0;
    bouyanbeeBlueCount = 0;
    bouyanbeeLastBlueTime = Date.now();
    bouyanbeeBaseCapacity = 0;
    fuzzyDestructionCount = 0;
    gooDestroyedCount = 0;
    redPollenMultiplier = 1;
    bluePollenMultiplier = 1;
    whitePollenMultiplier = 1;
    yellowPollenMultiplier = 1;
    purplePollenMultiplier = 1;
    tickets = 0;
    ticketBeeAbilityTime = 0;
    goldenBeeAbilityTime = 0;
    tileTicketProbBonus = 0;
    honeyLastValue = 0;
    ticketsLastValue = 0;
    
    // Recargar la UI
    updateUI();
    buildBeeGrid();
    buildShop();
    
    console.log('âœ“ Â¡Todos los datos han sido borrados! El juego se reiniciÃ³.');
  }
};

/* ================= FUNCIONES DE DEBUG Y VERIFICACIÃ“N ================= */

/**
 * Funciones para verificar que los buffs y stats funcionan correctamente.
 * Usar en la consola del navegador (F12) para debugging.
 */

window.debugBeeSystem = {
  // Mostrar todos los buffs de las bees equipadas
  showEquippedBeeBuffs() {
    console.log('=== BEES EQUIPADAS Y SUS BUFFS ===');
    equippedBees.forEach((beeId, index) => {
      const bee = BEES.find(b => b.id === beeId);
      const buffs = getBeeBuffs(beeId);
      console.log(`[${index}] ${bee ? bee.name : 'Desconocida'} (${beeId}):`, buffs);
    });
  },
  
  // Mostrar los stats finales
  showStats() {
    console.log('=== STATS FINALES ===');
    console.table({
      'Pollen Bonus': stats.beePollenBonus,
      'Convert Bonus': stats.beeConvertBonus,
      'Crit Chance': stats.beeCriticalChance + '%',
      'Crit Power': stats.beeCriticalPower,
      'Instant Conversion': stats.beeInstantConversion + '%',
      'Capacity Bonus': stats.beeCapacityBonus,
      'Red Multiplier': redPollenMultiplier + 'x',
      'Blue Multiplier': bluePollenMultiplier + 'x',
      'White Multiplier': whitePollenMultiplier + 'x',
      'Yellow Multiplier': yellowPollenMultiplier + 'x',
      'Purple Multiplier': purplePollenMultiplier + 'x'
    });
  },
  
  // Verificar que una bee especÃ­fica existe y tiene buffs
  checkBee(beeId) {
    const bee = BEES.find(b => b.id === beeId);
    if (!bee) {
      console.error(`âŒ Bee ${beeId} no encontrada!`);
      return false;
    }
    const buffs = getBeeBuffs(beeId);
    console.log(`âœ“ Bee ${bee.name} (${beeId}) encontrada`);
    console.log(`  Buffs:`, buffs);
    console.log(`  DescripciÃ³n:`, bee.desc);
    return true;
  },
  
  // Equipar una bee y ver sus efectos
  equipAndTest(beeId) {
    const bee = BEES.find(b => b.id === beeId);
    if (!bee) {
      console.error(`âŒ Bee ${beeId} no encontrada!`);
      return;
    }
    
    console.log(`\nðŸ“Š TEST: Equipando ${bee.name}...`);
    
    // Stats antes
    const statsBefore = {
      pollen: stats.beePollenBonus,
      convert: stats.beeConvertBonus,
      crit: stats.beeCriticalChance,
      capacity: stats.beeCapacityBonus
    };
    
    // Equipar la bee
    equippedBees.push(beeId);
    updateBeeAbilities();
    
    // Stats despuÃ©s
    const statsAfter = {
      pollen: stats.beePollenBonus,
      convert: stats.beeConvertBonus,
      crit: stats.beeCriticalChance,
      capacity: stats.beeCapacityBonus
    };
    
    console.log(`\n  Cambios de stats:`);
    console.table({
      'Pollen': `${statsBefore.pollen} â†’ ${statsAfter.pollen}`,
      'Convert': `${statsBefore.convert} â†’ ${statsAfter.convert}`,
      'Crit Chance': `${statsBefore.crit} â†’ ${statsAfter.crit}`,
      'Capacity': `${statsBefore.capacity} â†’ ${statsAfter.capacity}`
    });
    
    console.log(`âœ“ Bee equipada. Total bees equipadas: ${equippedBees.length}`);
  },
  
  // Verificar que todos los buffs se aplican sin duplicados
  verifyAllBees() {
    console.log('=== VERIFICACIÃ“N DE TODAS LAS BEES ===');
    let errors = [];
    let warnings = [];
    
    BEES.forEach(bee => {
      const buffs = getBeeBuffs(bee.id);
      
      // Si la bee dice tener un buff en desc pero no estÃ¡ registrado
      if (bee.desc && bee.desc.toLowerCase().includes('buff') && Object.keys(buffs).length === 0) {
        warnings.push(`âš ï¸  ${bee.name} (${bee.id}) menciona buffs pero no tiene ninguno registrado`);
      }
      
      // Si tiene multiplicadores de color, verificar que sea un multiplicador vÃ¡lido
      if (buffs.colorMultipliers) {
        for (let [color, value] of Object.entries(buffs.colorMultipliers)) {
          if (value <= 0) {
            errors.push(`âŒ ${bee.name} tiene multiplicador invÃ¡lido: ${color} = ${value}`);
          }
        }
      }
    });
    
    if (errors.length === 0 && warnings.length === 0) {
      console.log('âœ“ Â¡Todas las bees estÃ¡n correctamente configuradas!');
    } else {
      errors.forEach(e => console.error(e));
      warnings.forEach(w => console.warn(w));
    }
    
    return { errors, warnings };
  },
  
  // Test rÃ¡pido: equipar mÃºltiples bees y ver resultado
  testMultipleBees(...beeIds) {
    console.log(`\nðŸ”¬ TEST: Equipando ${beeIds.length} bees...`);
    equippedBees = [];
    
    beeIds.forEach(beeId => {
      const bee = BEES.find(b => b.id === beeId);
      if (bee) {
        equippedBees.push(beeId);
        console.log(`  + ${bee.name}`);
      } else {
        console.warn(`  âš ï¸  ${beeId} no encontrada`);
      }
    });
    
    updateBeeAbilities();
    this.showStats();
    console.log(`\nTotal bees equipadas: ${equippedBees.length}`);
  },
  
  // Test de acumulaciÃ³n (Golden Bee, Lion Bee, etc)
  testStackingBee(beeId, count = 3) {
    const bee = BEES.find(b => b.id === beeId);
    if (!bee) {
      console.error(`âŒ Bee ${beeId} no encontrada!`);
      return;
    }
    
    console.log(`\nðŸ§ª TEST ACUMULACIÃ“N: Equipando ${count}x ${bee.name}...`);
    equippedBees = Array(count).fill(beeId);
    updateBeeAbilities();
    
    this.showStats();
    console.log(`âœ“ Stats mostrados arriba - verifica que los buffs se multiplicaron por ${count}`);
  },
  
  // Limpiar bees equipadas
  clear() {
    equippedBees = [];
    updateBeeAbilities();
    console.log('âœ“ Todas las bees han sido desequipadas');
  }
};

// Notification system function
function showNotification(message, type = 'info', duration = 5000) {
  const container = document.getElementById('notificationsContainer');
  const notif = document.createElement('div');
  notif.className = `notification ${type}`;
  notif.textContent = message;
  
  container.appendChild(notif);
  
  // Auto-remove after duration
  setTimeout(() => {
    notif.classList.add('removing');
    setTimeout(() => {
      try { notif.remove(); } catch(e) {}
    }, 300);
  }, duration);
}

// Replace alerts with notifications
window.notifyError = (message) => showNotification(message, 'error');
window.notifySuccess = (message) => showNotification(message, 'success');
window.notifyWarning = (message) => showNotification(message, 'warning');
window.notifyInfo = (message) => showNotification(message, 'info');

// Tutorial System
const TUTORIAL_PAGES = [
  {
    title: 'Â¿QuÃ© son las Abejas?',
    image: 'images/bee1.png',
    text: 'Las abejas son tus unidades principales. Cada abeja tiene un color especial (rojo, azul, amarillo, pÃºrpura o incoloro) que determina su tipo de habilidad.',
    list: ['Colecta miel automÃ¡ticamente', 'Tiene habilidades especiales segÃºn su tipo', 'Puede ser equipada o desactivada']
  },
  {
    title: 'Sistema de Rareza',
    image: 'images/bees_common.png',
    text: 'Cada abeja tiene una rareza que determina su poder y valor:',
    list: ['ComÃºn (Cobre) - MÃ¡s dÃ©bil', 'Rara (Plata) - Media', 'Ã‰pica (Oro)', 'Legendaria (Diamante)', 'MÃ­tica (PÃºrpura)', 'Ultimate (Magenta)', 'Especial (Esmeralda)']
  },
  {
    title: 'Habilidades',
    image: 'images/ability.png',
    text: 'Cada abeja tiene una habilidad Ãºnica que proporciona un buff o efecto especial cuando estÃ¡ equipada.',
    list: ['Las habilidades pueden combinarse', 'Abejas mÃºltiples del mismo tipo apilan sus efectos', 'Verifica tu panel de habilidades en la parte inferior']
  },
  {
    title: 'CÃ³mo Ganar',
    image: 'images/honey.png',
    text: 'El objetivo es acumular la mayor cantidad de miel posible. Puedes obtener miel de varias maneras:',
    list: ['RecolecciÃ³n automÃ¡tica de abejas', 'Bonificadores de habilidades', 'Mejoras de almacenamiento', 'Herramientas especiales']
  },
  {
    title: 'Consejos',
    image: 'images/star.png',
    text: 'AquÃ­ hay algunos consejos para optimizar tu progreso:',
    list: ['Equipa abejas del mismo tipo para abusar de sinergias', 'Mejora tus almacenes regularmente', 'Usa herramientas estratÃ©gicamente', 'Descubre nuevas abejas explorando']
  }
];

let currentTutorialPage = 0;

function openTutorial() {
  currentTutorialPage = 0;
  showTutorialPage();
}

function showTutorialPage() {
  const page = TUTORIAL_PAGES[currentTutorialPage];
  
  // Remove existing overlay if any
  const existing = document.getElementById('tutorialOverlay');
  if(existing) existing.remove();
  
  const overlay = document.createElement('div');
  overlay.id = 'tutorialOverlay';
  overlay.className = 'tutorial-overlay';
  overlay.onclick = (e) => {
    if(e.target === overlay) closeTutorial();
  };
  
  const modal = document.createElement('div');
  modal.className = 'tutorial-modal';
  modal.onclick = (e) => e.stopPropagation();
  
  const img = document.createElement('img');
  img.src = page.image;
  img.onerror = () => { img.style.display = 'none'; };
  
  const title = document.createElement('h2');
  title.textContent = page.title;
  
  const text = document.createElement('p');
  text.textContent = page.text;
  
  let listHTML = '';
  if(page.list && page.list.length > 0) {
    listHTML = '<ul>' + page.list.map(item => `<li>${item}</li>`).join('') + '</ul>';
  }
  
  const nav = document.createElement('div');
  nav.className = 'tutorial-nav';
  
  const prevBtn = document.createElement('button');
  prevBtn.textContent = 'â† Anterior';
  prevBtn.disabled = currentTutorialPage === 0;
  prevBtn.onclick = () => {
    if(currentTutorialPage > 0) {
      currentTutorialPage--;
      closeTutorial();
      showTutorialPage();
    }
  };
  
  const counter = document.createElement('span');
  counter.className = 'tutorial-counter';
  counter.textContent = `${currentTutorialPage + 1} / ${TUTORIAL_PAGES.length}`;
  
  const nextBtn = document.createElement('button');
  nextBtn.textContent = 'Siguiente â†’';
  nextBtn.disabled = currentTutorialPage === TUTORIAL_PAGES.length - 1;
  nextBtn.onclick = () => {
    if(currentTutorialPage < TUTORIAL_PAGES.length - 1) {
      currentTutorialPage++;
      closeTutorial();
      showTutorialPage();
    }
  };
  
  nav.appendChild(prevBtn);
  nav.appendChild(counter);
  nav.appendChild(nextBtn);
  
  modal.appendChild(img);
  modal.appendChild(title);
  modal.appendChild(text);
  if(listHTML) modal.innerHTML += listHTML;
  modal.appendChild(nav);
  
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
}

function closeTutorial() {
  const overlay = document.getElementById('tutorialOverlay');
  if(overlay) {
    overlay.style.animation = 'fadeOut 0.3s ease-in-out forwards';
    setTimeout(() => overlay.remove(), 300);
  }
}

// Helper function to create category header with toggle button
function createCategoryHeader(text, rarity, rarityColors) {
  const headerContainer = document.createElement('div');
  headerContainer.style.cssText = 'display:flex;gap:12px;align-items:center;margin:18px 0 12px 0;justify-content:space-between;';
  
  const header = document.createElement('div');
  let headerStyle = `color:${rarityColors[rarity]};font-weight:bold;font-size:16px;text-transform:uppercase;padding:10px;border-left:4px solid ${rarityColors[rarity]};flex:1;`;
  
  if(rarity === 'legendary') {
    headerStyle += `text-shadow:0 0 8px ${rarityColors[rarity]};`;
  } else if(rarity === 'mythic') {
    headerStyle += `text-shadow:0 0 10px ${rarityColors[rarity]}, 0 0 20px ${rarityColors[rarity]};`;
  } else if(rarity === 'ultimate') {
    headerStyle += `animation:color-shift 3s ease-in-out infinite;text-shadow:0 0 12px ${rarityColors[rarity]};`;
  }
  
  header.style.cssText = headerStyle;
  header.textContent = text;
  
  const toggleBtn = document.createElement('button');
  toggleBtn.className = 'rarity-toggle-btn';
  toggleBtn.textContent = 'â–¼';
  toggleBtn.setAttribute('data-rarity', rarity);
  
  headerContainer.appendChild(header);
  headerContainer.appendChild(toggleBtn);
  
  return { container: headerContainer, button: toggleBtn };
}

// Category state management
function getCategoryState(categoryKey) {
  const saved = localStorage.getItem(`category_${categoryKey}`);
  return saved ? JSON.parse(saved) : { collapsed: {} };
}

function saveCategoryState(categoryKey, collapsed) {
  localStorage.setItem(`category_${categoryKey}`, JSON.stringify({ collapsed }));
}

function toggleCategoryVisibility(toggleBtn, itemsContainer, categoryKey, rarityName) {
  const isCollapsed = itemsContainer.classList.contains('collapsing');
  if(!isCollapsed && itemsContainer.children.length > 0){
    itemsContainer.classList.add('collapsing');
    toggleBtn.classList.add('collapsed');
    toggleBtn.textContent = 'â–¶';
    setTimeout(() => {
      itemsContainer.style.display = 'none';
      const state = getCategoryState(categoryKey);
      state.collapsed[rarityName] = true;
      saveCategoryState(categoryKey, state.collapsed);
    }, 400);
  } else if(isCollapsed || itemsContainer.style.display === 'none'){
    itemsContainer.style.display = 'block';
    itemsContainer.classList.remove('collapsing');
    itemsContainer.classList.add('expanding');
    toggleBtn.classList.remove('collapsed');
    toggleBtn.textContent = 'â–¼';
    setTimeout(() => {
      itemsContainer.classList.remove('expanding');
      const state = getCategoryState(categoryKey);
      state.collapsed[rarityName] = false;
      saveCategoryState(categoryKey, state.collapsed);
    }, 400);
  }
}

</script>
</body>
</html>
